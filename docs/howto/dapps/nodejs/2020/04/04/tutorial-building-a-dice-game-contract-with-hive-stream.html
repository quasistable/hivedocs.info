<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Tutorial: Building A Dice Game Contract With Hive Stream | Hive Chain Documentation</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Tutorial: Building A Dice Game Contract With Hive Stream" />
<meta name="author" content="beggars" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Hot off the heels of announcing [some huge updates](https://peakd.com/hive-139531/@beggars/hive-stream-update-support-for-writing-custom-contracts-on-the-hive-blockchain) to Hive Stream which features the ability to write &quot;smart&quot; contracts, I promised a tutorial would be coming showing you how to write one and what could be more fitting than writing a contract for a dice game? Basing this off of the dice contract that Hive Engine ships with as an example, I&#39;ve created a contract that accepts a roll value which needs to be above the server roll. By the end of this tutorial, you&#39;ll have an understanding of how contracts are written (they&#39;re just classes) and how you can create your own smart dApps using them. If you&#39;re the kind of person who just wants to see the code, I have you covered. The code for the dice smart contract can be found [here](https://github.com/Vheissu/hive-stream/blob/master/src/contracts/dice.contract.ts). It is written in TypeScript but resembles Javascript basically if you&#39;re not familiar. This contract is based off of the dice contract in Hive Engine, except they&#39;re both fundamentally different in how they&#39;re pieced together. ## Install the Hive Stream package In your application, install the `hive-stream` package by running `npm install hive-stream` it&#39;s a published package on Npm. We also want to install seedrandom and bignumber.js as well since those are used in our contract code. ``` npm install seedrandom bignumber.js ``` ## Writing the contract Save the following as `dice.contract.js` in your application. ```javascript import { Streamer, Utils } from &#39;hive-stream&#39;; import seedrandom from &#39;seedrandom&#39;; import BigNumber from &#39;bignumber.js&#39;; const CONTRACT_NAME = &#39;hivedice&#39;; const ACCOUNT = &#39;&#39;; // Replace with the account const TOKEN_SYMBOL = &#39;HIVE&#39;; const HOUSE_EDGE = 0.05; const MIN_BET = 1; const MAX_BET = 10; // Random Number Generator const rng = (previousBlockId, blockId, transactionId) =&gt; { const random = seedrandom(`${previousBlockId}${blockId}${transactionId}`).double(); const randomRoll = Math.floor(random * 100) + 1; return randomRoll; }; // Valid betting currencies const VALID_CURRENCIES = [&#39;HIVE&#39;]; class DiceContract { client; config; blockNumber; blockId; previousBlockId; transactionId; create() { // Runs every time register is called on this contract // Do setup logic and code in here (creating a database, etc) } destroy() { // Runs every time unregister is run for this contract // Close database connections, write to a database with state, etc } // Updates the contract with information about the current block // This is a method automatically called if it exists updateBlockInfo(blockNumber, blockId, previousBlockId, transactionId) { // Lifecycle method which sets block info this.blockNumber = blockNumber; this.blockId = blockId; this.previousBlockId = previousBlockId; this.transactionId = transactionId; } /** * Get Balance * * Helper method for getting the contract account balance. In the case of our dice contract * we want to make sure the account has enough money to pay out any bets * * @returns number */ async getBalance() { const account = await this._client.database.getAccounts([ACCOUNT]); if (account?.[0]) { const balance = (account[0].balance as string).split(&#39; &#39;); const amount = balance[0]; return parseFloat(amount); } } /** * Roll * * Automatically called when a custom JSON action matches the following method * * @param payload * @param param1 - sender and amount */ async roll(payload, { sender, amount }) { // Destructure the values from the payload const { roll } = payload; // The amount is formatted like 100 HIVE // The value is the first part, the currency symbol is the second const amountTrim = amount.split(&#39; &#39;); // Parse the numeric value as a real value const amountParsed = parseFloat(amountTrim[0]); // Format the amount to 3 decimal places const amountFormatted = parseFloat(amountTrim[0]).toFixed(3); // Trim any space from the currency symbol const amountCurrency = amountTrim[1].trim(); console.log(`Roll: ${roll} Amount parsed: ${amountParsed} Amount formatted: ${amountFormatted} Currency: ${amountCurrency}`); // Get the transaction from the blockchain const transaction = await Utils.getTransaction(this._client, this.blockNumber, this.transactionId); // Call the verifyTransfer method to confirm the transfer happened const verify = await Utils.verifyTransfer(transaction, sender, &#39;beggars&#39;, amount); // Get the balance of our contract account const balance = await this.getBalance(); // Transfer is valid if (verify) { // Server balance is less than the max bet, cancel and refund if (balance &lt; MAX_BET) { // Send back what was sent, the server is broke await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, amountTrim[0], amountTrim[1], `[Refund] The server could not fufill your bet.`); return; } // Bet amount is valid if (amountParsed &gt;= MIN_BET &amp;&amp; amountParsed &lt;= MAX_BET) { // Validate roll is valid if ((roll &gt;= 2 &amp;&amp; roll &lt;= 96) &amp;&amp; (direction === &#39;lesserThan&#39; || direction === &#39;greaterThan&#39;) &amp;&amp; VALID_CURRENCIES.includes(amountCurrency)) { // Roll a random value const random = rng(this.previousBlockId, this.blockId, this.transactionId); // Calculate the multiplier percentage const multiplier = new BigNumber(1).minus(HOUSE_EDGE).multipliedBy(100).dividedBy(roll); // Calculate the number of tokens won const tokensWon = new BigNumber(amountParsed).multipliedBy(multiplier).toFixed(3, BigNumber.ROUND_DOWN); // Memo that shows in users memo when they win const winningMemo = `You won ${tokensWon} ${TOKEN_SYMBOL}. Roll: ${random}, Your guess: ${roll}`; // Memo that shows in users memo when they lose const losingMemo = `You lost ${amountParsed} ${TOKEN_SYMBOL}. Roll: ${random}, Your guess: ${roll}`; // User won more than the server can afford, refund the bet amount if (parseFloat(tokensWon) &gt; balance) { await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, amountTrim[0], amountTrim[1], `[Refund] The server could not fufill your bet.`); return; } // If random value is less than roll if (random &lt; roll) { await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, tokensWon, TOKEN_SYMBOL, winningMemo); } else { await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, &#39;0.001&#39;, TOKEN_SYMBOL, losingMemo); } } else { // Invalid bet parameters, refund the user their bet await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, amountTrim[0], amountTrim[1], `[Refund] Invalid bet params.`); } } else { try { // We need to refund the user const transfer = await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, amountTrim[0], amountTrim[1], `[Refund] You sent an invalid bet amount.`); console.log(transfer); } catch (e) { console.log(e); } } } } } export default new DiceContract(); ``` ## Adding it to your application Create a file called `app.js` and add in the following. ```javascript import { Streamer } from &#39;hive-stream&#39;; import DiceContract from &#39;./dice.contract&#39;; const streamer = new Streamer({ ACTIVE_KEY: &#39;&#39;, // Needed for transfers JSON_ID: &#39;testdice&#39; // Identifier in the custom JSON payloads }); // Register the contract streamer.registerContract(&#39;hivedice&#39;, DiceContract); // Starts the streamer watching the blockchain streamer.start(); ``` ## Test it out In the contract code, put in your Hive username as the account and then transfer some Hive tokens to your own account (to you from you). Make sure you also supply your active key in the streamer constructor call in the above code (between the single quotes). In the memo field, enter stringified JSON like this: ``{&quot;hiveContract&quot;:{&quot;id&quot;:&quot;testdice&quot;, &quot;name&quot;:&quot;hivedice&quot;,&quot;action&quot;:&quot;roll&quot;,&quot;payload&quot;:{&quot;roll&quot;:10 }}}`` The ID in the memo must match what is provided to the config property `JSON_ID` this is what it uses to match transactions. In this case, it is `testdice` as the ID. The value `name` must match the value of the `registerContract` method&#39;s first argument value which is `hivedice` in our example. The `action` property matches the function name in the contract and finally the `payload` object is the data provided to the function call. I took the liberty of testing it out using my own account, to show you how the transfer for testing process works. ![transfer.PNG](https://files.peakd.com/file/peakd-hive/beggars/am5ZNZEA-transfer.PNG) As you can see from my two transactions showing the winning and losing, it works (which can be verified by checking my transactions on my wallet or blockchain explorer): ![transactions.PNG](https://files.peakd.com/file/peakd-hive/beggars/HnyJ7w4d-transactions.PNG) ## Conclusion This is just a rudimentary example of a basic dice contract. Some improvements might include support for direction as well as different odds, supporting different tokens and more. But, hopefully you can see what you can build with Hive Stream now. See: Tutorial: Building A Dice Game Contract With Hive Stream by @beggars" />
<meta property="og:description" content="Hot off the heels of announcing [some huge updates](https://peakd.com/hive-139531/@beggars/hive-stream-update-support-for-writing-custom-contracts-on-the-hive-blockchain) to Hive Stream which features the ability to write &quot;smart&quot; contracts, I promised a tutorial would be coming showing you how to write one and what could be more fitting than writing a contract for a dice game? Basing this off of the dice contract that Hive Engine ships with as an example, I&#39;ve created a contract that accepts a roll value which needs to be above the server roll. By the end of this tutorial, you&#39;ll have an understanding of how contracts are written (they&#39;re just classes) and how you can create your own smart dApps using them. If you&#39;re the kind of person who just wants to see the code, I have you covered. The code for the dice smart contract can be found [here](https://github.com/Vheissu/hive-stream/blob/master/src/contracts/dice.contract.ts). It is written in TypeScript but resembles Javascript basically if you&#39;re not familiar. This contract is based off of the dice contract in Hive Engine, except they&#39;re both fundamentally different in how they&#39;re pieced together. ## Install the Hive Stream package In your application, install the `hive-stream` package by running `npm install hive-stream` it&#39;s a published package on Npm. We also want to install seedrandom and bignumber.js as well since those are used in our contract code. ``` npm install seedrandom bignumber.js ``` ## Writing the contract Save the following as `dice.contract.js` in your application. ```javascript import { Streamer, Utils } from &#39;hive-stream&#39;; import seedrandom from &#39;seedrandom&#39;; import BigNumber from &#39;bignumber.js&#39;; const CONTRACT_NAME = &#39;hivedice&#39;; const ACCOUNT = &#39;&#39;; // Replace with the account const TOKEN_SYMBOL = &#39;HIVE&#39;; const HOUSE_EDGE = 0.05; const MIN_BET = 1; const MAX_BET = 10; // Random Number Generator const rng = (previousBlockId, blockId, transactionId) =&gt; { const random = seedrandom(`${previousBlockId}${blockId}${transactionId}`).double(); const randomRoll = Math.floor(random * 100) + 1; return randomRoll; }; // Valid betting currencies const VALID_CURRENCIES = [&#39;HIVE&#39;]; class DiceContract { client; config; blockNumber; blockId; previousBlockId; transactionId; create() { // Runs every time register is called on this contract // Do setup logic and code in here (creating a database, etc) } destroy() { // Runs every time unregister is run for this contract // Close database connections, write to a database with state, etc } // Updates the contract with information about the current block // This is a method automatically called if it exists updateBlockInfo(blockNumber, blockId, previousBlockId, transactionId) { // Lifecycle method which sets block info this.blockNumber = blockNumber; this.blockId = blockId; this.previousBlockId = previousBlockId; this.transactionId = transactionId; } /** * Get Balance * * Helper method for getting the contract account balance. In the case of our dice contract * we want to make sure the account has enough money to pay out any bets * * @returns number */ async getBalance() { const account = await this._client.database.getAccounts([ACCOUNT]); if (account?.[0]) { const balance = (account[0].balance as string).split(&#39; &#39;); const amount = balance[0]; return parseFloat(amount); } } /** * Roll * * Automatically called when a custom JSON action matches the following method * * @param payload * @param param1 - sender and amount */ async roll(payload, { sender, amount }) { // Destructure the values from the payload const { roll } = payload; // The amount is formatted like 100 HIVE // The value is the first part, the currency symbol is the second const amountTrim = amount.split(&#39; &#39;); // Parse the numeric value as a real value const amountParsed = parseFloat(amountTrim[0]); // Format the amount to 3 decimal places const amountFormatted = parseFloat(amountTrim[0]).toFixed(3); // Trim any space from the currency symbol const amountCurrency = amountTrim[1].trim(); console.log(`Roll: ${roll} Amount parsed: ${amountParsed} Amount formatted: ${amountFormatted} Currency: ${amountCurrency}`); // Get the transaction from the blockchain const transaction = await Utils.getTransaction(this._client, this.blockNumber, this.transactionId); // Call the verifyTransfer method to confirm the transfer happened const verify = await Utils.verifyTransfer(transaction, sender, &#39;beggars&#39;, amount); // Get the balance of our contract account const balance = await this.getBalance(); // Transfer is valid if (verify) { // Server balance is less than the max bet, cancel and refund if (balance &lt; MAX_BET) { // Send back what was sent, the server is broke await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, amountTrim[0], amountTrim[1], `[Refund] The server could not fufill your bet.`); return; } // Bet amount is valid if (amountParsed &gt;= MIN_BET &amp;&amp; amountParsed &lt;= MAX_BET) { // Validate roll is valid if ((roll &gt;= 2 &amp;&amp; roll &lt;= 96) &amp;&amp; (direction === &#39;lesserThan&#39; || direction === &#39;greaterThan&#39;) &amp;&amp; VALID_CURRENCIES.includes(amountCurrency)) { // Roll a random value const random = rng(this.previousBlockId, this.blockId, this.transactionId); // Calculate the multiplier percentage const multiplier = new BigNumber(1).minus(HOUSE_EDGE).multipliedBy(100).dividedBy(roll); // Calculate the number of tokens won const tokensWon = new BigNumber(amountParsed).multipliedBy(multiplier).toFixed(3, BigNumber.ROUND_DOWN); // Memo that shows in users memo when they win const winningMemo = `You won ${tokensWon} ${TOKEN_SYMBOL}. Roll: ${random}, Your guess: ${roll}`; // Memo that shows in users memo when they lose const losingMemo = `You lost ${amountParsed} ${TOKEN_SYMBOL}. Roll: ${random}, Your guess: ${roll}`; // User won more than the server can afford, refund the bet amount if (parseFloat(tokensWon) &gt; balance) { await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, amountTrim[0], amountTrim[1], `[Refund] The server could not fufill your bet.`); return; } // If random value is less than roll if (random &lt; roll) { await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, tokensWon, TOKEN_SYMBOL, winningMemo); } else { await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, &#39;0.001&#39;, TOKEN_SYMBOL, losingMemo); } } else { // Invalid bet parameters, refund the user their bet await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, amountTrim[0], amountTrim[1], `[Refund] Invalid bet params.`); } } else { try { // We need to refund the user const transfer = await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, amountTrim[0], amountTrim[1], `[Refund] You sent an invalid bet amount.`); console.log(transfer); } catch (e) { console.log(e); } } } } } export default new DiceContract(); ``` ## Adding it to your application Create a file called `app.js` and add in the following. ```javascript import { Streamer } from &#39;hive-stream&#39;; import DiceContract from &#39;./dice.contract&#39;; const streamer = new Streamer({ ACTIVE_KEY: &#39;&#39;, // Needed for transfers JSON_ID: &#39;testdice&#39; // Identifier in the custom JSON payloads }); // Register the contract streamer.registerContract(&#39;hivedice&#39;, DiceContract); // Starts the streamer watching the blockchain streamer.start(); ``` ## Test it out In the contract code, put in your Hive username as the account and then transfer some Hive tokens to your own account (to you from you). Make sure you also supply your active key in the streamer constructor call in the above code (between the single quotes). In the memo field, enter stringified JSON like this: ``{&quot;hiveContract&quot;:{&quot;id&quot;:&quot;testdice&quot;, &quot;name&quot;:&quot;hivedice&quot;,&quot;action&quot;:&quot;roll&quot;,&quot;payload&quot;:{&quot;roll&quot;:10 }}}`` The ID in the memo must match what is provided to the config property `JSON_ID` this is what it uses to match transactions. In this case, it is `testdice` as the ID. The value `name` must match the value of the `registerContract` method&#39;s first argument value which is `hivedice` in our example. The `action` property matches the function name in the contract and finally the `payload` object is the data provided to the function call. I took the liberty of testing it out using my own account, to show you how the transfer for testing process works. ![transfer.PNG](https://files.peakd.com/file/peakd-hive/beggars/am5ZNZEA-transfer.PNG) As you can see from my two transactions showing the winning and losing, it works (which can be verified by checking my transactions on my wallet or blockchain explorer): ![transactions.PNG](https://files.peakd.com/file/peakd-hive/beggars/HnyJ7w4d-transactions.PNG) ## Conclusion This is just a rudimentary example of a basic dice contract. Some improvements might include support for direction as well as different odds, supporting different tokens and more. But, hopefully you can see what you can build with Hive Stream now. See: Tutorial: Building A Dice Game Contract With Hive Stream by @beggars" />
<link rel="canonical" href="https://hive.blog/hive-139531/@beggars/tutorial-building-a-dice-game-contract-with-hive-stream" />
<meta property="og:url" content="https://hive.blog/hive-139531/@beggars/tutorial-building-a-dice-game-contract-with-hive-stream" />
<meta property="og:site_name" content="Hive Chain Documentation" />
<meta property="og:image" content="https://files.peakd.com/file/peakd-hive/beggars/am5ZNZEA-transfer.PNG" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-04-04T03:59:09-07:00" />
<script type="application/ld+json">
{"description":"Hot off the heels of announcing [some huge updates](https://peakd.com/hive-139531/@beggars/hive-stream-update-support-for-writing-custom-contracts-on-the-hive-blockchain) to Hive Stream which features the ability to write &quot;smart&quot; contracts, I promised a tutorial would be coming showing you how to write one and what could be more fitting than writing a contract for a dice game? Basing this off of the dice contract that Hive Engine ships with as an example, I&#39;ve created a contract that accepts a roll value which needs to be above the server roll. By the end of this tutorial, you&#39;ll have an understanding of how contracts are written (they&#39;re just classes) and how you can create your own smart dApps using them. If you&#39;re the kind of person who just wants to see the code, I have you covered. The code for the dice smart contract can be found [here](https://github.com/Vheissu/hive-stream/blob/master/src/contracts/dice.contract.ts). It is written in TypeScript but resembles Javascript basically if you&#39;re not familiar. This contract is based off of the dice contract in Hive Engine, except they&#39;re both fundamentally different in how they&#39;re pieced together. ## Install the Hive Stream package In your application, install the `hive-stream` package by running `npm install hive-stream` it&#39;s a published package on Npm. We also want to install seedrandom and bignumber.js as well since those are used in our contract code. ``` npm install seedrandom bignumber.js ``` ## Writing the contract Save the following as `dice.contract.js` in your application. ```javascript import { Streamer, Utils } from &#39;hive-stream&#39;; import seedrandom from &#39;seedrandom&#39;; import BigNumber from &#39;bignumber.js&#39;; const CONTRACT_NAME = &#39;hivedice&#39;; const ACCOUNT = &#39;&#39;; // Replace with the account const TOKEN_SYMBOL = &#39;HIVE&#39;; const HOUSE_EDGE = 0.05; const MIN_BET = 1; const MAX_BET = 10; // Random Number Generator const rng = (previousBlockId, blockId, transactionId) =&gt; { const random = seedrandom(`${previousBlockId}${blockId}${transactionId}`).double(); const randomRoll = Math.floor(random * 100) + 1; return randomRoll; }; // Valid betting currencies const VALID_CURRENCIES = [&#39;HIVE&#39;]; class DiceContract { client; config; blockNumber; blockId; previousBlockId; transactionId; create() { // Runs every time register is called on this contract // Do setup logic and code in here (creating a database, etc) } destroy() { // Runs every time unregister is run for this contract // Close database connections, write to a database with state, etc } // Updates the contract with information about the current block // This is a method automatically called if it exists updateBlockInfo(blockNumber, blockId, previousBlockId, transactionId) { // Lifecycle method which sets block info this.blockNumber = blockNumber; this.blockId = blockId; this.previousBlockId = previousBlockId; this.transactionId = transactionId; } /** * Get Balance * * Helper method for getting the contract account balance. In the case of our dice contract * we want to make sure the account has enough money to pay out any bets * * @returns number */ async getBalance() { const account = await this._client.database.getAccounts([ACCOUNT]); if (account?.[0]) { const balance = (account[0].balance as string).split(&#39; &#39;); const amount = balance[0]; return parseFloat(amount); } } /** * Roll * * Automatically called when a custom JSON action matches the following method * * @param payload * @param param1 - sender and amount */ async roll(payload, { sender, amount }) { // Destructure the values from the payload const { roll } = payload; // The amount is formatted like 100 HIVE // The value is the first part, the currency symbol is the second const amountTrim = amount.split(&#39; &#39;); // Parse the numeric value as a real value const amountParsed = parseFloat(amountTrim[0]); // Format the amount to 3 decimal places const amountFormatted = parseFloat(amountTrim[0]).toFixed(3); // Trim any space from the currency symbol const amountCurrency = amountTrim[1].trim(); console.log(`Roll: ${roll} Amount parsed: ${amountParsed} Amount formatted: ${amountFormatted} Currency: ${amountCurrency}`); // Get the transaction from the blockchain const transaction = await Utils.getTransaction(this._client, this.blockNumber, this.transactionId); // Call the verifyTransfer method to confirm the transfer happened const verify = await Utils.verifyTransfer(transaction, sender, &#39;beggars&#39;, amount); // Get the balance of our contract account const balance = await this.getBalance(); // Transfer is valid if (verify) { // Server balance is less than the max bet, cancel and refund if (balance &lt; MAX_BET) { // Send back what was sent, the server is broke await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, amountTrim[0], amountTrim[1], `[Refund] The server could not fufill your bet.`); return; } // Bet amount is valid if (amountParsed &gt;= MIN_BET &amp;&amp; amountParsed &lt;= MAX_BET) { // Validate roll is valid if ((roll &gt;= 2 &amp;&amp; roll &lt;= 96) &amp;&amp; (direction === &#39;lesserThan&#39; || direction === &#39;greaterThan&#39;) &amp;&amp; VALID_CURRENCIES.includes(amountCurrency)) { // Roll a random value const random = rng(this.previousBlockId, this.blockId, this.transactionId); // Calculate the multiplier percentage const multiplier = new BigNumber(1).minus(HOUSE_EDGE).multipliedBy(100).dividedBy(roll); // Calculate the number of tokens won const tokensWon = new BigNumber(amountParsed).multipliedBy(multiplier).toFixed(3, BigNumber.ROUND_DOWN); // Memo that shows in users memo when they win const winningMemo = `You won ${tokensWon} ${TOKEN_SYMBOL}. Roll: ${random}, Your guess: ${roll}`; // Memo that shows in users memo when they lose const losingMemo = `You lost ${amountParsed} ${TOKEN_SYMBOL}. Roll: ${random}, Your guess: ${roll}`; // User won more than the server can afford, refund the bet amount if (parseFloat(tokensWon) &gt; balance) { await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, amountTrim[0], amountTrim[1], `[Refund] The server could not fufill your bet.`); return; } // If random value is less than roll if (random &lt; roll) { await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, tokensWon, TOKEN_SYMBOL, winningMemo); } else { await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, &#39;0.001&#39;, TOKEN_SYMBOL, losingMemo); } } else { // Invalid bet parameters, refund the user their bet await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, amountTrim[0], amountTrim[1], `[Refund] Invalid bet params.`); } } else { try { // We need to refund the user const transfer = await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, amountTrim[0], amountTrim[1], `[Refund] You sent an invalid bet amount.`); console.log(transfer); } catch (e) { console.log(e); } } } } } export default new DiceContract(); ``` ## Adding it to your application Create a file called `app.js` and add in the following. ```javascript import { Streamer } from &#39;hive-stream&#39;; import DiceContract from &#39;./dice.contract&#39;; const streamer = new Streamer({ ACTIVE_KEY: &#39;&#39;, // Needed for transfers JSON_ID: &#39;testdice&#39; // Identifier in the custom JSON payloads }); // Register the contract streamer.registerContract(&#39;hivedice&#39;, DiceContract); // Starts the streamer watching the blockchain streamer.start(); ``` ## Test it out In the contract code, put in your Hive username as the account and then transfer some Hive tokens to your own account (to you from you). Make sure you also supply your active key in the streamer constructor call in the above code (between the single quotes). In the memo field, enter stringified JSON like this: ``{&quot;hiveContract&quot;:{&quot;id&quot;:&quot;testdice&quot;, &quot;name&quot;:&quot;hivedice&quot;,&quot;action&quot;:&quot;roll&quot;,&quot;payload&quot;:{&quot;roll&quot;:10 }}}`` The ID in the memo must match what is provided to the config property `JSON_ID` this is what it uses to match transactions. In this case, it is `testdice` as the ID. The value `name` must match the value of the `registerContract` method&#39;s first argument value which is `hivedice` in our example. The `action` property matches the function name in the contract and finally the `payload` object is the data provided to the function call. I took the liberty of testing it out using my own account, to show you how the transfer for testing process works. ![transfer.PNG](https://files.peakd.com/file/peakd-hive/beggars/am5ZNZEA-transfer.PNG) As you can see from my two transactions showing the winning and losing, it works (which can be verified by checking my transactions on my wallet or blockchain explorer): ![transactions.PNG](https://files.peakd.com/file/peakd-hive/beggars/HnyJ7w4d-transactions.PNG) ## Conclusion This is just a rudimentary example of a basic dice contract. Some improvements might include support for direction as well as different odds, supporting different tokens and more. But, hopefully you can see what you can build with Hive Stream now. See: Tutorial: Building A Dice Game Contract With Hive Stream by @beggars","mainEntityOfPage":{"@type":"WebPage","@id":"https://hive.blog/hive-139531/@beggars/tutorial-building-a-dice-game-contract-with-hive-stream"},"@type":"BlogPosting","url":"https://hive.blog/hive-139531/@beggars/tutorial-building-a-dice-game-contract-with-hive-stream","headline":"Tutorial: Building A Dice Game Contract With Hive Stream","dateModified":"2020-04-04T03:59:09-07:00","datePublished":"2020-04-04T03:59:09-07:00","author":{"@type":"Person","name":"beggars"},"image":"https://files.peakd.com/file/peakd-hive/beggars/am5ZNZEA-transfer.PNG","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://hivedocs.info/feed.xml" title="Hive Chain Documentation" /><script>
if(!(window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1")) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-161692811-1', 'auto');
  ga('send', 'pageview');
}
</script>
  
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/turbolinks/5.2.0/turbolinks.js" integrity="sha256-iM4Yzi/zLj/IshPWMC1IluRxTtRjMqjPGd97TZ9yYpU=" crossorigin="anonymous"></script>
  <script src='https://unpkg.com/steem-content-renderer'></script>
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Cousine|Inconsolata" rel="stylesheet">
  <link rel="shortcut icon" type="image/png" href="/assets/images/favicon.png">
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Hive Chain Documentation</a>

      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/news/">News</a><a class="page-link" href="/howto/">How To</a><a class="page-link" href="/links/">Useful Links</a><!-- HTML elements for search -->
          <input type="text" id="search-input" placeholder="Search" />
          
          <ul id="results-container"></ul>

          <script src="/assets/javascript/search.js"></script>
          <script>
            var sjs = SimpleJekyllSearch({
              searchInput: document.getElementById('search-input'),
              resultsContainer: document.getElementById('results-container'),
              json: '/search.json'
            })
          </script>
          <!-- <form style="float: right;" class="form-inline" method="get" action="http://www.google.com/search">
            <input type="hidden" name="sitesearch" value="hivedocs.info" />
            <input type="text" name="q" maxlength="255" placeholder="Search" />
          </form> -->
        </div>
      </nav>
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Tutorial: Building A Dice Game Contract With Hive Stream</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-04-04T03:59:09-07:00" itemprop="datePublished">Apr 4, 2020
      </time>â€¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">
          <a href="https://hive.blog/@beggars">beggars</a>
        </span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <div id="content-beggars-tutorial-building-a-dice-game-contract-with-hive-stream">Hot off the heels of announcing [some huge updates](https://peakd.com/hive-139531/@beggars/hive-stream-update-support-for-writing-custom-contracts-on-the-hive-blockchain) to Hive Stream which features the ability to write "smart" contracts, I promised a tutorial would be coming showing you how to write one and what could be more fitting than writing a contract for a dice game?

Basing this off of the dice contract that Hive Engine ships with as an example, I've created a contract that accepts a roll value which needs to be above the server roll. By the end of this tutorial, you'll have an understanding of how contracts are written (they're just classes) and how you can create your own smart dApps using them.

If you're the kind of person who just wants to see the code, I have you covered. The code for the dice smart contract can be found [here](https://github.com/Vheissu/hive-stream/blob/master/src/contracts/dice.contract.ts). It is written in TypeScript but resembles Javascript basically if you're not familiar. This contract is based off of the dice contract in Hive Engine, except they're both fundamentally different in how they're pieced together.

## Install the Hive Stream package

In your application, install the `hive-stream` package by running `npm install hive-stream` it's a published package on Npm. We also want to install seedrandom and bignumber.js as well since those are used in our contract code.

```
npm install seedrandom bignumber.js
```

## Writing the contract

Save the following as `dice.contract.js` in your application.

```javascript
import { Streamer, Utils } from 'hive-stream';
import seedrandom from 'seedrandom';
import BigNumber from 'bignumber.js';

const CONTRACT_NAME = 'hivedice';

const ACCOUNT = ''; // Replace with the account
const TOKEN_SYMBOL = 'HIVE';

const HOUSE_EDGE = 0.05;
const MIN_BET = 1;
const MAX_BET = 10;

// Random Number Generator
const rng = (previousBlockId, blockId, transactionId) =&gt; {
    const random = seedrandom(`${previousBlockId}${blockId}${transactionId}`).double();
    const randomRoll = Math.floor(random * 100) + 1;

    return randomRoll;
};

// Valid betting currencies
const VALID_CURRENCIES = ['HIVE'];

class DiceContract {
    client;
    config;

    blockNumber;
    blockId;
    previousBlockId;
    transactionId;

    create() {
        // Runs every time register is called on this contract
        // Do setup logic and code in here (creating a database, etc)
    }

    destroy() {
        // Runs every time unregister is run for this contract
        // Close database connections, write to a database with state, etc
    }

    // Updates the contract with information about the current block
    // This is a method automatically called if it exists
    updateBlockInfo(blockNumber, blockId, previousBlockId, transactionId) {
        // Lifecycle method which sets block info 
        this.blockNumber = blockNumber;
        this.blockId = blockId;
        this.previousBlockId = previousBlockId;
        this.transactionId = transactionId;
    }

    /**
     * Get Balance
     * 
     * Helper method for getting the contract account balance. In the case of our dice contract
     * we want to make sure the account has enough money to pay out any bets
     * 
     * @returns number
     */
    async getBalance() {
        const account = await this._client.database.getAccounts([ACCOUNT]);

        if (account?.[0]) {
            const balance = (account[0].balance as string).split(' ');
            const amount = balance[0];

            return parseFloat(amount);
        }
    }

    /**
     * Roll
     * 
     * Automatically called when a custom JSON action matches the following method
     * 
     * @param payload 
     * @param param1 - sender and amount
     */
    async roll(payload, { sender, amount }) {
        // Destructure the values from the payload
        const { roll } = payload;

        // The amount is formatted like 100 HIVE
        // The value is the first part, the currency symbol is the second
        const amountTrim = amount.split(' ');

        // Parse the numeric value as a real value
        const amountParsed = parseFloat(amountTrim[0]);

        // Format the amount to 3 decimal places
        const amountFormatted = parseFloat(amountTrim[0]).toFixed(3);

        // Trim any space from the currency symbol
        const amountCurrency = amountTrim[1].trim();

        console.log(`Roll: ${roll} 
                     Amount parsed: ${amountParsed} 
                     Amount formatted: ${amountFormatted} 
                     Currency: ${amountCurrency}`);

        // Get the transaction from the blockchain
        const transaction = await Utils.getTransaction(this._client, this.blockNumber, this.transactionId);

        // Call the verifyTransfer method to confirm the transfer happened
        const verify = await Utils.verifyTransfer(transaction, sender, 'beggars', amount);

        // Get the balance of our contract account
        const balance = await this.getBalance();

        // Transfer is valid
        if (verify) {
            // Server balance is less than the max bet, cancel and refund
            if (balance &lt; MAX_BET) {
                // Send back what was sent, the server is broke
                await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, amountTrim[0], amountTrim[1], `[Refund] The server could not fufill your bet.`);

                return;
            }

            // Bet amount is valid
            if (amountParsed &gt;= MIN_BET &amp;&amp; amountParsed &lt;= MAX_BET) {
                // Validate roll is valid
                if ((roll &gt;= 2 &amp;&amp; roll &lt;= 96) &amp;&amp; (direction === 'lesserThan' || direction === 'greaterThan') &amp;&amp; VALID_CURRENCIES.includes(amountCurrency)) {
                    // Roll a random value
                    const random = rng(this.previousBlockId, this.blockId, this.transactionId);

                    // Calculate the multiplier percentage
                    const multiplier = new BigNumber(1).minus(HOUSE_EDGE).multipliedBy(100).dividedBy(roll);

                    // Calculate the number of tokens won
                    const tokensWon = new BigNumber(amountParsed).multipliedBy(multiplier).toFixed(3, BigNumber.ROUND_DOWN);

                    // Memo that shows in users memo when they win
                    const winningMemo = `You won ${tokensWon} ${TOKEN_SYMBOL}. Roll: ${random}, Your guess: ${roll}`;

                    // Memo that shows in users memo when they lose
                    const losingMemo = `You lost ${amountParsed} ${TOKEN_SYMBOL}. Roll: ${random}, Your guess: ${roll}`;

                    // User won more than the server can afford, refund the bet amount
                    if (parseFloat(tokensWon) &gt; balance) {
                        await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, amountTrim[0], amountTrim[1], `[Refund] The server could not fufill your bet.`);

                        return;
                    }

                    // If random value is less than roll
                    if (random &lt; roll) {                            
                        await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, tokensWon, TOKEN_SYMBOL, winningMemo);
                    } else {
                        await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, '0.001', TOKEN_SYMBOL, losingMemo);
                    }
                } else {
                    // Invalid bet parameters, refund the user their bet
                    await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, amountTrim[0], amountTrim[1], `[Refund] Invalid bet params.`);
                }
            } else {
                try {
                    // We need to refund the user
                    const transfer = await Utils.transferHiveTokens(this._client, this._config, ACCOUNT, sender, amountTrim[0], amountTrim[1], `[Refund] You sent an invalid bet amount.`);

                    console.log(transfer);
                } catch (e) {
                    console.log(e);
                }
            }
        }
    }
}

export default new DiceContract();
```


## Adding it to your application

Create a file called `app.js` and add in the following.

```javascript
import { Streamer } from 'hive-stream';
import DiceContract from './dice.contract';

const streamer = new Streamer({
    ACTIVE_KEY: '', // Needed for transfers
    JSON_ID: 'testdice' // Identifier in the custom JSON payloads
});

// Register the contract
streamer.registerContract('hivedice', DiceContract);

// Starts the streamer watching the blockchain
streamer.start();
```

## Test it out

In the contract code, put in your Hive username as the account and then transfer some Hive tokens to your own account (to you from you). Make sure you also supply your active key in the streamer constructor call in the above code (between the single quotes).

In the memo field, enter stringified JSON like this: 

``{"hiveContract":{"id":"testdice", "name":"hivedice","action":"roll","payload":{"roll":10 }}}``

The ID in the memo must match what is provided to the config property `JSON_ID` this is what it uses to match transactions. In this case, it is `testdice` as the ID. The value `name` must match the value of the `registerContract` method's first argument value which is `hivedice` in our example. The `action` property matches the function name in the contract and finally the `payload` object is the data provided to the function call.

I took the liberty of testing it out using my own account, to show you how the transfer for testing process works.

![transfer.PNG](https://files.peakd.com/file/peakd-hive/beggars/am5ZNZEA-transfer.PNG)

As you can see from my two transactions showing the winning and losing, it works (which can be verified by checking my transactions on my wallet or blockchain explorer):

![transactions.PNG](https://files.peakd.com/file/peakd-hive/beggars/HnyJ7w4d-transactions.PNG)

## Conclusion

This is just a rudimentary example of a basic dice contract. Some improvements might include support for direction as well as different odds, supporting different tokens and more. But, hopefully you can see what you can build with Hive Stream now.</div>
<script crossorigin="anonymous" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>

<script src="https://unpkg.com/steem-content-renderer"></script>

<script>
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: "https://hive.blog/",
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: "",
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) => url,
        usertagUrlFn: (account) => "/@beggars",
        hashtagUrlFn: (hashtag) => "/tutorial-building-a-dice-game-contract-with-hive-stream",
        isLinkSafeFn: (url) => true,
      });
      
      const inputElem = $('#content-beggars-tutorial-building-a-dice-game-contract-with-hive-stream').html();
      const outputElem = $('#content-beggars-tutorial-building-a-dice-game-contract-with-hive-stream');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
</script>

<style>
  #content-beggars-tutorial-building-a-dice-game-contract-with-hive-stream {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-beggars-tutorial-building-a-dice-game-contract-with-hive-stream code {
    background: white;
  }
  #content-beggars-tutorial-building-a-dice-game-contract-with-hive-stream a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-beggars-tutorial-building-a-dice-game-contract-with-hive-stream a:hover {
    border-bottom: 0;
  }
  #content-beggars-tutorial-building-a-dice-game-contract-with-hive-stream h1 {
    font-size: 2.2em;
  }
  #content-beggars-tutorial-building-a-dice-game-contract-with-hive-stream h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-beggars-tutorial-building-a-dice-game-contract-with-hive-stream header small {
    color: #999;
    font-size: 50%;
  }
  #content-beggars-tutorial-building-a-dice-game-contract-with-hive-stream img {
    max-width: 100%;
  }
</style>

<hr />

<p>
  See: <a href="https://peakd.com/hive-139531/@beggars/tutorial-building-a-dice-game-contract-with-hive-stream">Tutorial: Building A Dice Game Contract With Hive Stream</a>
  by
  <a href="https://hive.blog/@beggars">@beggars</a>
</p>

<p><a href="/nodejs">More About Node.js</a></p>

  </div><a class="u-url" href="/howto/dapps/nodejs/2020/04/04/tutorial-building-a-dice-game-contract-with-hive-stream.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading"><a rel="author" href="/">Hive Chain Documentation</a></h2>
    
    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">site curated by: @inertia</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Your resource for various levels of Hive Documentation.</p>
      </div>
    </div>
  </div>

</footer>
</body>

</html>
