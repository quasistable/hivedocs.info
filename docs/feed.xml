<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://hivedocs.info/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hivedocs.info/" rel="alternate" type="text/html" /><updated>2020-12-21T10:29:57-08:00</updated><id>https://hivedocs.info/feed.xml</id><title type="html">Hive Chain Documentation</title><subtitle>Your resource for various levels of Hive Documentation.</subtitle><author><name>site curated by: @inertia</name></author><entry><title type="html">Verify blocktivity numbers for Hive and Blurt</title><link href="https://hivedocs.info/howto/beem/python/blocktivity/2020/12/20/verify-blocktivity-numbers-for-hive-and-blurt.html" rel="alternate" type="text/html" title="Verify blocktivity numbers for Hive and Blurt" /><published>2020-12-20T03:27:33-08:00</published><updated>2020-12-20T03:27:33-08:00</updated><id>https://hivedocs.info/howto/beem/python/blocktivity/2020/12/20/verify-blocktivity-numbers-for-hive-and-blurt</id><content type="html" xml:base="https://hivedocs.info/howto/beem/python/blocktivity/2020/12/20/verify-blocktivity-numbers-for-hive-and-blurt.html"></content><author><name>holger80</name></author><category term="howto" /><category term="beem" /><category term="python" /><category term="blocktivity" /><summary type="html">@therealwolf was wondering on twitter on the high activity numbers on blocktivity.info for blurt: https://twitter.com/therealwolf42/status/1340374495899561986 The stats can be seen here: ![blocktivity on 20.12.2020](https://images.hive.blog/DQmQeoNNWui7sVCdwHZWntJwaKRkzyzZymwKxFRvwuM1HPi/blocktivity%20on%2020.12.2020) Lets validate them using [beem](https://github.com/holgern/beem). I added the script also to my beem github: [blockactivity.py](https://github.com/holgern/beem/blob/master/examples/blockactivity.py). ``` import sys from datetime import datetime, timedelta import argparse from timeit import default_timer as timer import logging from beem.blockchain import Blockchain from beem.block import Block from beem import Hive, Blurt, Steem from beem.utils import parse_time from beem.nodelist import NodeList log = logging.getLogger(__name__) logging.basicConfig(level=logging.INFO) def parse_args(args=None): d = 'Verify blocktivity by counting operations and trx for the last 24 hours.' parser = argparse.ArgumentParser(description=d) parser.add_argument('blockchain', type=str, nargs='?', default=sys.stdin, help='Blockchain (hive, blurt or steem)') return parser.parse_args(args) def main(args=None): args = parse_args(args) blockchain = args.blockchain nodelist = NodeList() if blockchain == &quot;hive&quot; or blockchain is None: max_batch_size = 50 threading = False thread_num = 16 block_debug = 1000 nodes = nodelist.get_hive_nodes() blk_inst = Hive(node=nodes, num_retries=3, num_retries_call=3, timeout=30) elif blockchain == &quot;blurt&quot;: max_batch_size = None threading = False thread_num = 8 block_debug = 20 nodes = [&quot;https://api.blurt.blog&quot;, &quot;https://rpc.blurtworld.com&quot;, &quot;https://rpc.blurtworld.com&quot;] blk_inst = Blurt(node=nodes, num_retries=3, num_retries_call=3, timeout=30) elif blockchain == &quot;steem&quot;: max_batch_size = 50 threading = False thread_num = 16 block_debug = 1000 nodes = nodelist.get_steem_nodes() blk_inst = Steem(node=nodes, num_retries=3, num_retries_call=3, timeout=30) else: raise Exception(&quot;Wrong parameter, can be hive, blurt or steem&quot;) print(blk_inst) block_count = 0 total_ops = 0 total_trx = 0 blocksperday = 20 * 60 * 24 blockchain = Blockchain(blockchain_instance=blk_inst) last_block_id = blockchain.get_current_block_num() - blocksperday last_block = Block(last_block_id, blockchain_instance=blk_inst) stopTime = last_block.time() + timedelta(seconds=60 * 60 * 24) start = timer() for entry in blockchain.blocks(start=last_block_id, max_batch_size=max_batch_size, threading=threading, thread_num=thread_num): block_count += 1 if &quot;block&quot; in entry: trxs = entry[&quot;block&quot;][&quot;transactions&quot;] else: trxs = entry[&quot;transactions&quot;] for tx in trxs: total_trx += 1 for op in tx[&quot;operations&quot;]: total_ops += 1 if &quot;block&quot; in entry: block_time = parse_time(entry[&quot;block&quot;][&quot;timestamp&quot;]) else: block_time = entry[&quot;timestamp&quot;] ops_per_day = total_ops / block_count * blocksperday if block_count % (block_debug) == 0: print(&quot;%d blocks remaining... estimated ops per day: %.1f&quot; % (blocksperday - block_count, ops_per_day)) if block_time &amp;gt; stopTime: break duration = timer() - start print(&quot;Received %.2f blocks/s.&quot; % (block_count / duration)) print(&quot;Bocks: %d, duration %.3f s&quot; % (block_count, duration)) print(&quot;Operations per day: %d&quot; % total_ops) print(&quot;Trx per day: %d&quot; % total_trx) if __name__ == '__main__': sys.exit(main()) ``` Just save the script as blocktivity.py and call it with the blockchain name (can be hive, steem or blurt). ## Checking the blockchain activity I started the script in three terminals to check the activity on hive, steem and blurt: ``` python3 blocktivity.py hive python3 blocktivity.py steem python3 blocktivity.py blurt ``` ## Results The following table shows the obtained: | | Hive | Steem | Blurt | |---|---| --- | --- | | Blocks | 28756 | 28466 | 28634 | | Duration | 128.855 | 117.712 | 8016.021 | | Blocks/s | 223.17 | 241.83 | 3.57 | | Trx | 883929 | 195892 | 6942 | | Ops | 894856 | 200968 | 7461 | | Ratio of Trx to Bitcion Trx | 0.98 | 0.221 | 0.008 | ### Hive It seems that the activity shown at https://blocktivity.info/ counted every operation twice or it sums up the activity for 48 hours. The block count reaches 99.84% of the maximum block count 28800. ### Steem The block count reaches 98.84% of the maximum block count 28800. ### Blurt The speed for receiving blocks from the API is really slow, it took 62 times longer as on hive. The shown activity numbers are completely wrong. 549405 operations are reached in around 74 days and not in 24 hours. The block count reaches 99.42% of the maximum block count 28800. It seems that the bug was already found and will be fixed soon: https://twitter.com/eastmaels/status/1340477277788753920 ___ *If you like what I do, consider casting a vote for me as witness on [Hivesigner](https://hivesigner.com/sign/account-witness-vote?witness=holger80&amp;amp;approve=1) or on [PeakD](https://peakd.com/witnesses)* See: Verify blocktivity numbers for Hive and Blurt by @holger80</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://images.hive.blog/DQmQeoNNWui7sVCdwHZWntJwaKRkzyzZymwKxFRvwuM1HPi/blocktivity%20on%2020.12.2020" /><media:content medium="image" url="https://images.hive.blog/DQmQeoNNWui7sVCdwHZWntJwaKRkzyzZymwKxFRvwuM1HPi/blocktivity%20on%2020.12.2020" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Updated on BlockTrades Hive work (as of Dec 9th 2020)</title><link href="https://hivedocs.info/news/core/development/2020/12/09/updated-on-blocktrades-hive-work-as-of-dec-9th-2020.html" rel="alternate" type="text/html" title="Updated on BlockTrades Hive work (as of Dec 9th 2020)" /><published>2020-12-09T16:47:18-08:00</published><updated>2020-12-09T16:47:18-08:00</updated><id>https://hivedocs.info/news/core/development/2020/12/09/updated-on-blocktrades-hive-work-as-of-dec-9th-2020</id><content type="html" xml:base="https://hivedocs.info/news/core/development/2020/12/09/updated-on-blocktrades-hive-work-as-of-dec-9th-2020.html">&lt;div id=&quot;content-blocktrades-updated-on-blocktrades-hive-work-as-of-dec-9th-2020&quot;&gt;I decided to skip last week’s progress report, since I wanted to keep the focus on our roadmap post. In the meantime, we’ve continued to make good progress over past two weeks. Below is a summary of the work done over this period:

# Hived work (blockchain node software)

As mentioned previously, we’re currently creating a hived plugin that can directly write the needed data into hivemind’s database during hive reindexing and normal block reception. Most of the data being provided by get_block_api is of no interest to hivemind, so using this API to get the data is unnecessarily wasting cpu, in addition to slowing down hivemind. I expect that using the plugin approach will lead to significant speedup in the initial sync time for hivemind (my guess now is 2x at least) and it should also reduce normal hivemind live-sync write time. Work is ongoing here:
https://gitlab.syncad.com/hive/hive/-/commits/km_live_postgres_dump/

We made a change to hived so that proposals aren’t automatically removed after they expire:
https://gitlab.syncad.com/hive/hive/-/merge_requests/154
This allows the API to report on proposals after they have ended.

We used memory-mapped IO to speed up rebuild of the block_log.index file from the block log. It’s now over 3x faster on a fast nvme drive (and the speedup is even better on a magnetic drive).
https://gitlab.syncad.com/hive/hive/-/merge_requests/156


# Hivemind (2nd layer microservice for social media applications)

Most of our Hive devs continued to working on hivemind last week. Below are some of the merge requests incorporated into the develop branch of the hivemind repo:

various bug fixes and optimization work:
https://gitlab.syncad.com/hive/hivemind/-/merge_requests/410
https://gitlab.syncad.com/hive/hivemind/-/merge_requests/405
https://gitlab.syncad.com/hive/hivemind/-/merge_requests/413
https://gitlab.syncad.com/hive/hivemind/-/merge_requests/416
https://gitlab.syncad.com/hive/hivemind/-/merge_requests/400
https://gitlab.syncad.com/hive/hivemind/-/merge_requests/418
https://gitlab.syncad.com/hive/hivemind/-/merge_requests/424
https://gitlab.syncad.com/hive/hivemind/-/merge_requests/426
https://gitlab.syncad.com/hive/hivemind/-/merge_requests/411
https://gitlab.syncad.com/hive/hivemind/-/merge_requests/428

enable decentralized muting:
https://gitlab.syncad.com/hive/hivemind/-/merge_requests/407
https://gitlab.syncad.com/hive/hivemind/-/merge_requests/421
https://gitlab.syncad.com/hive/hivemind/-/merge_requests/422

new tests:
https://gitlab.syncad.com/hive/hivemind/-/merge_requests/415


test system improvement:
https://gitlab.syncad.com/hive/hivemind/-/merge_requests/380

We also ran a full sync test on hivemind (4 day long test currently), which allowed us to catch and fix a few more bugs.

We are currently during real-world testing the [head of develop branch]( https://gitlab.syncad.com/hive/hivemind/-/commit/7872ef7e4d3642c61606fb6302f16452f6aa1b60) on api.hive.blog.

# Support for decentralized lists/muting in condenser (https://hive.blog)

We made several fixes and improvements to the UI based on feedback from beta-testers:
https://gitlab.syncad.com/hive/condenser/-/merge_requests/165
https://gitlab.syncad.com/hive/condenser/-/merge_requests/166

# What’s the plan for next week?

* Finish hivemind and condenser decentralized list changes (likely done tomorrow)
* Continue creating hivemind tests (long term task).
* Automate running of hived/hivemind full sync tests and run it once a week.
* Continue work on speedup of hivemind full sync via hived plugin as the slow sync time has a big impact on the speed of hivemind CI (which sets an upper limit on how fast we can validate changes).
* As a stopgap to the above, we’re also trying to speedup the current full sync code by making more concurrent API calls to hived from hive sync (we’ll probably be able to get a 2x speedup this way, in other words, bringing the full sync time down to 2 days on a server with sufficient cores to handle the additional hived load).
* Make an official hivemind release to master branch and create a hivemind snapshot so that API node operators can update their nodes quickly. After all API nodes have updated, we can deploy the new changes to condenser for decentralized lists and decentralized muting.&lt;/div&gt;
&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;

&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@blocktrades&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/updated-on-blocktrades-hive-work-as-of-dec-9th-2020&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-blocktrades-updated-on-blocktrades-hive-work-as-of-dec-9th-2020').html();
      const outputElem = $('#content-blocktrades-updated-on-blocktrades-hive-work-as-of-dec-9th-2020');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;

&lt;style&gt;
  #content-blocktrades-updated-on-blocktrades-hive-work-as-of-dec-9th-2020 {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-blocktrades-updated-on-blocktrades-hive-work-as-of-dec-9th-2020 code {
    background: white;
  }
  #content-blocktrades-updated-on-blocktrades-hive-work-as-of-dec-9th-2020 a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-blocktrades-updated-on-blocktrades-hive-work-as-of-dec-9th-2020 a:hover {
    border-bottom: 0;
  }
  #content-blocktrades-updated-on-blocktrades-hive-work-as-of-dec-9th-2020 h1 {
    font-size: 2.2em;
  }
  #content-blocktrades-updated-on-blocktrades-hive-work-as-of-dec-9th-2020 h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-blocktrades-updated-on-blocktrades-hive-work-as-of-dec-9th-2020 header small {
    color: #999;
    font-size: 50%;
  }
  #content-blocktrades-updated-on-blocktrades-hive-work-as-of-dec-9th-2020 img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;

&lt;p&gt;
  See: &lt;a href=&quot;https://hive.blog/hive-139531/@blocktrades/updated-on-blocktrades-hive-work-as-of-dec-9th-2020&quot;&gt;Updated on BlockTrades Hive work (as of Dec 9th 2020)&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@blocktrades&quot;&gt;@blocktrades&lt;/a&gt;
&lt;/p&gt;</content><author><name>blocktrades</name></author><category term="news" /><category term="core" /><category term="development" /><summary type="html">I decided to skip last week’s progress report, since I wanted to keep the focus on our roadmap post. In the meantime, we’ve continued to make good progress over past two weeks. Below is a summary of the work done over this period: # Hived work (blockchain node software) As mentioned previously, we’re currently creating a hived plugin that can directly write the needed data into hivemind’s database during hive reindexing and normal block reception. Most of the data being provided by get_block_api is of no interest to hivemind, so using this API to get the data is unnecessarily wasting cpu, in addition to slowing down hivemind. I expect that using the plugin approach will lead to significant speedup in the initial sync time for hivemind (my guess now is 2x at least) and it should also reduce normal hivemind live-sync write time. Work is ongoing here: https://gitlab.syncad.com/hive/hive/-/commits/km_live_postgres_dump/ We made a change to hived so that proposals aren’t automatically removed after they expire: https://gitlab.syncad.com/hive/hive/-/merge_requests/154 This allows the API to report on proposals after they have ended. We used memory-mapped IO to speed up rebuild of the block_log.index file from the block log. It’s now over 3x faster on a fast nvme drive (and the speedup is even better on a magnetic drive). https://gitlab.syncad.com/hive/hive/-/merge_requests/156 # Hivemind (2nd layer microservice for social media applications) Most of our Hive devs continued to working on hivemind last week. Below are some of the merge requests incorporated into the develop branch of the hivemind repo: various bug fixes and optimization work: https://gitlab.syncad.com/hive/hivemind/-/merge_requests/410 https://gitlab.syncad.com/hive/hivemind/-/merge_requests/405 https://gitlab.syncad.com/hive/hivemind/-/merge_requests/413 https://gitlab.syncad.com/hive/hivemind/-/merge_requests/416 https://gitlab.syncad.com/hive/hivemind/-/merge_requests/400 https://gitlab.syncad.com/hive/hivemind/-/merge_requests/418 https://gitlab.syncad.com/hive/hivemind/-/merge_requests/424 https://gitlab.syncad.com/hive/hivemind/-/merge_requests/426 https://gitlab.syncad.com/hive/hivemind/-/merge_requests/411 https://gitlab.syncad.com/hive/hivemind/-/merge_requests/428 enable decentralized muting: https://gitlab.syncad.com/hive/hivemind/-/merge_requests/407 https://gitlab.syncad.com/hive/hivemind/-/merge_requests/421 https://gitlab.syncad.com/hive/hivemind/-/merge_requests/422 new tests: https://gitlab.syncad.com/hive/hivemind/-/merge_requests/415 test system improvement: https://gitlab.syncad.com/hive/hivemind/-/merge_requests/380 We also ran a full sync test on hivemind (4 day long test currently), which allowed us to catch and fix a few more bugs. We are currently during real-world testing the [head of develop branch]( https://gitlab.syncad.com/hive/hivemind/-/commit/7872ef7e4d3642c61606fb6302f16452f6aa1b60) on api.hive.blog. # Support for decentralized lists/muting in condenser (https://hive.blog) We made several fixes and improvements to the UI based on feedback from beta-testers: https://gitlab.syncad.com/hive/condenser/-/merge_requests/165 https://gitlab.syncad.com/hive/condenser/-/merge_requests/166 # What’s the plan for next week? * Finish hivemind and condenser decentralized list changes (likely done tomorrow) * Continue creating hivemind tests (long term task). * Automate running of hived/hivemind full sync tests and run it once a week. * Continue work on speedup of hivemind full sync via hived plugin as the slow sync time has a big impact on the speed of hivemind CI (which sets an upper limit on how fast we can validate changes). * As a stopgap to the above, we’re also trying to speedup the current full sync code by making more concurrent API calls to hived from hive sync (we’ll probably be able to get a 2x speedup this way, in other words, bringing the full sync time down to 2 days on a server with sufficient cores to handle the additional hived load). * Make an official hivemind release to master branch and create a hivemind snapshot so that API node operators can update their nodes quickly. After all API nodes have updated, we can deploy the new changes to condenser for decentralized lists and decentralized muting. See: Updated on BlockTrades Hive work (as of Dec 9th 2020) by @blocktrades</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://hivedocs.info/assets/images/favicon.png" /><media:content medium="image" url="https://hivedocs.info/assets/images/favicon.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">How to use a coldcard MK3 to derive your new account password from a 24 word seed</title><link href="https://hivedocs.info/news/python/wallet/2020/12/05/how-to-use-a-coldcard-mk3-to-derive-your-new-account-password-from-a-24-word-seed.html" rel="alternate" type="text/html" title="How to use a coldcard MK3 to derive your new account password from a 24 word seed" /><published>2020-12-05T15:10:18-08:00</published><updated>2020-12-05T15:10:18-08:00</updated><id>https://hivedocs.info/news/python/wallet/2020/12/05/how-to-use-a-coldcard-mk3-to-derive-your-new-account-password-from-a-24-word-seed</id><content type="html" xml:base="https://hivedocs.info/news/python/wallet/2020/12/05/how-to-use-a-coldcard-mk3-to-derive-your-new-account-password-from-a-24-word-seed.html">&lt;div id=&quot;content-holger80-how-to-use-a-coldcard-mk3-to-derive-your-new-account-password-from-a-24-word-seed&quot;&gt;
Each hive account has four keys which can be used to sign broadcast operations. As the key name says (owner key, active key, posting key), they have different use cases. Normally, a single password is used to derive these four keys from it. This has the advantage that only one passphrase needs to be securely stored.

I can change my account keys by generating a new password:
![New Password](https://images.hive.blog/DQmWagwVQs2GsJFQMMFpQCbLFSWxKS5jmDK5WYsfNAC6tkq/New%20Password)

You need to `BACK IT UP BY STORING IN YOUR PASSWORD MANAGER OR A TEXT FILE.`, but what happens when your hard drive is failing or your password manager (lost the master password, ...)? You can print it, but what happens in case of a fire or water damage?

## Using your bitcoin seed for Hive
When you have stored your bitcoin seed (consisting normally of 24 words) in metal, it would be great if you could use this also to store your Hive password.

It is possible to use [BIP-85 (Deterministic Entropy From BIP32 Keychains)](https://github.com/bitcoin/bips/blob/master/bip-0085.mediawiki) for creating a new password for a hive account using a coldcard mk3 hardware wallet (As far as I know this is the only device that support BIP85).

![coldcard](https://images.hive.blog/DQmYZebd2XQzeyxR2LhQEuiCmvAZpweC1ywThuBnkmAtHVb/coldcard)


When I use the derived WIF to create a new Password for my Hive account, I do not need to store my Hive keys and Password anymore, as they can be recreated from the securely stored bitcoin seed (I need to remember the used index number, or I need to try all possible numbers from 0 to 9999).

Thus I can increase my account security when I do not store the password and the owner key in my computer.



## How to use the coldcard mk3 to create a new Password for Hive
This guide will use the [coldcard mk3](https://coldcardwallet.com/) which has the necessary bip-85 support and python (beem) for generating and changing the account keys.

### Storing a WIF on a sdcard
At first we use the coldcard to derive a new WIF and store it on a sdcard.


![Go to Advanced](https://images.hive.blog/DQmUJxn6RzUbxNrXMMkP6PnT1UTMQC4kbHe6Ad1PYLiFyqD/Go%20to%20Advanced)
![Then to Derive Entropy](https://images.hive.blog/DQmVjNSAtvVtuiDPnM4u91D8VypYkdhx1UeVsooFzkhSFVs/Then%20to%20Derive%20Entropy)
We need to select WIF:
![Then to WIF](https://images.hive.blog/DQmSn5u2kBPRsf7V5EiM2VrUSdKgS7VDQhkJjJCte8ZDS3f/Then%20to%20WIF)
Select a number you can remember:
![Select a number](https://images.hive.blog/DQmRrywjVhNWgscazDfVV9f1UrmVZKhpU1R9xj6xEjN7DT4/Select%20a%20number)
Store the WIF to the MicroSD:
![Press 1 to store the WIF on the sd card](https://images.hive.blog/DQmQiWagr6YLFoPCjrBBptJqGAhP5GP5ZzbGomEio1xYfAa/Press%201%20to%20store%20the%20WIF%20on%20the%20sd%20card)

## Reading the WIF from the sdcard and change the HIVE keys
We need the following python packages:
```
pip3 install beem
```

The WIF from the coldcard needs firstly converted into a HIVE WIF and then a password is derived by applying `PasswordKey` to it and adding a `P`:

```
from beemgraphenebase.account import PrivateKey, PasswordKey
WIF=&quot;xxx&quot; # from coldcard
wif = PrivateKey(WIF)
pk = PasswordKey(&quot;&quot;, str(wif), role=&quot;&quot;)
password = 'P' + str(pk.get_private())
print(password)
```
`password` is the new account password that can be set in `https://wallet.hive.blog/@&lt;username&gt;/password`

After changing the account password, the new posting, active and memo key should be stored and the Password and the WIF on the sdcard should be deleted.

Whenever, an account key is getting lost or when the owner key is needed, 
it can be created from the derive WIF which is created by the coldcard.


It is also possible to automate everything. The following script will
* Read the sdcard and extract the WIF
* Create a new Password for the account
* Change the account password by broadcasting `update_account`

```
from beem import Hive
from beemgraphenebase.account import PrivateKey, PasswordKey
import argparse
from prettytable import PrettyTable
import sys
import getpass


if __name__ == &quot;__main__&quot;:
    parser = argparse.ArgumentParser(description=&quot;Derives a new password from a coldcard WIF&quot;)
    parser.add_argument('wiffile', type=str, nargs='?',
                        help='colcard wif key file to read.')
    parser.add_argument('account', type=str, nargs='?',
                        help='account name.')    
    args = parser.parse_args()
    wiffile = args.wiffile
    account = args.account
    next_var = &quot;&quot;
    wif = &quot;&quot;
    path = &quot;&quot;
    with open(wiffile) as fp: 
        for line in fp:
            if line.strip() == &quot;&quot;:
                continue
            if line.strip() == &quot;WIF (privkey):&quot;:
                next_var = &quot;wif&quot;
                continue
            elif &quot;Path Used&quot; in line.strip():
                next_var = &quot;path&quot;
                continue
            if next_var == &quot;wif&quot;:
                wif = line.strip()
            elif next_var == &quot;path&quot;:
                path = line
            next_var = &quot;&quot;
    wif = PrivateKey(wif)
    pk = PasswordKey(&quot;&quot;, str(wif), role=&quot;&quot;)
    password = 'P' + str(pk.get_private())
    
    owner_key = PasswordKey(account, password, role=&quot;owner&quot;)
    owner_pubkey = format(owner_key.get_public_key(), &quot;STM&quot;)
    
    active_key = PasswordKey(account, password, role=&quot;active&quot;)
    active_pubkey = format(active_key.get_public_key(), &quot;STM&quot;)
    
    posting_key = PasswordKey(account, password, role=&quot;posting&quot;)
    posting_pubkey = format(posting_key.get_public_key(), &quot;STM&quot;)
    
    memo_key = PasswordKey(account, password, role=&quot;memo&quot;)
    memo_pubkey = format(memo_key.get_public_key(), &quot;STM&quot;)
    
    
    t = PrettyTable([&quot;Key&quot;, &quot;Value&quot;])
    t.align = &quot;l&quot;
    t.add_row([&quot;Account&quot;, account])
    t.add_row([&quot;Path&quot;, path])   
    t.add_row([&quot;New owner pubkey&quot;, owner_pubkey])
    t.add_row([&quot;New active pubkey&quot;, active_pubkey])   
    t.add_row([&quot;New posting pubkey&quot;, posting_pubkey])   
    t.add_row([&quot;New memo pubkey&quot;, memo_pubkey])   
    print(t)
    ret = input(&quot;Broadcast update_account with new keys? [y/n]&quot;)
    if ret in [&quot;y&quot;, &quot;yes&quot;]:
        owner_key = getpass.getpass(prompt=&quot;current owner key:&quot;)
        hive = Hive(keys=[owner_key])
        tx = hive.update_account(account, owner_key=owner_pubkey, active_key=active_pubkey,
                                 posting_key=posting_pubkey, memo_key=memo_pubkey)
        print(tx)
    
    ret = input(&quot;Show private keys? [y/n]&quot;)
    if ret in [&quot;y&quot;, &quot;yes&quot;]:
        t = PrettyTable([&quot;Key&quot;, &quot;Value&quot;])
        t.align = &quot;l&quot;
        t.add_row([&quot;active privkey&quot;, str(active_key.get_private_key())])   
        t.add_row([&quot;posting privkey&quot;, str(posting_key.get_private_key())])   
        t.add_row([&quot;memo privkey&quot;, str(memo_key.get_private_key())])
        print(t)
    ret = input(&quot;Show owner key and password? [y/n]&quot;)
    if ret in [&quot;y&quot;, &quot;yes&quot;]:
        t = PrettyTable([&quot;Key&quot;, &quot;Value&quot;])
        t.align = &quot;l&quot;
        t.add_row([&quot;owner privkey&quot;, str(owner_key.get_private_key())])
        t.add_row([&quot;Password&quot;, str(password)])
        print(t)
    del owner_key
    del memo_key
    del posting_key
    del active_key
    del password
```
This needs to be stored as py file (e.g. new_password.py) and can then be called:
```
python3 new_password.py F:\drv-wif-idx0.txt holger80
```
where `F:\drv-wif-idx0.txt` is the path to the exported WIF file.

Deleting the WIF text file on the sdcard needs to be done by hand (remember to store the used index number).

I'm currently adding this also to beempy, the CLI tool in beem.
There is also a second way in creating a new password from a seed using hardware wallet (signing a message), which I'm investigating right now.


___

*If you like what I do, consider casting a vote for me as witness on [Hivesigner](https://hivesigner.com/sign/account-witness-vote?witness=holger80&amp;amp;approve=1) or on [PeakD](https://peakd.com/witnesses)*&amp;lt;/div&amp;gt;
&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@holger80&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/how-to-use-a-coldcard-mk3-to-derive-your-new-account-password-from-a-24-word-seed&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-holger80-how-to-use-a-coldcard-mk3-to-derive-your-new-account-password-from-a-24-word-seed').html();
      const outputElem = $('#content-holger80-how-to-use-a-coldcard-mk3-to-derive-your-new-account-password-from-a-24-word-seed');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;
&lt;style&gt;
  #content-holger80-how-to-use-a-coldcard-mk3-to-derive-your-new-account-password-from-a-24-word-seed {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-holger80-how-to-use-a-coldcard-mk3-to-derive-your-new-account-password-from-a-24-word-seed code {
    background: white;
  }
  #content-holger80-how-to-use-a-coldcard-mk3-to-derive-your-new-account-password-from-a-24-word-seed a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-holger80-how-to-use-a-coldcard-mk3-to-derive-your-new-account-password-from-a-24-word-seed a:hover {
    border-bottom: 0;
  }
  #content-holger80-how-to-use-a-coldcard-mk3-to-derive-your-new-account-password-from-a-24-word-seed h1 {
    font-size: 2.2em;
  }
  #content-holger80-how-to-use-a-coldcard-mk3-to-derive-your-new-account-password-from-a-24-word-seed h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-holger80-how-to-use-a-coldcard-mk3-to-derive-your-new-account-password-from-a-24-word-seed header small {
    color: #999;
    font-size: 50%;
  }
  #content-holger80-how-to-use-a-coldcard-mk3-to-derive-your-new-account-password-from-a-24-word-seed img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;
&lt;p&gt;
  See: &lt;a href=&quot;https://hive.blog/hive-139531/@holger80/how-to-use-a-coldcard-mk3-to-derive-your-new-account-password-from-a-24-word-seed&quot;&gt;How to use a coldcard MK3 to derive your new account password from a 24 word seed&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@holger80&quot;&gt;@holger80&lt;/a&gt;
&lt;/p&gt;

&lt;/username&gt;&lt;/div&gt;</content><author><name>holger80</name></author><category term="news" /><category term="python" /><category term="wallet" /><summary type="html">Each hive account has four keys which can be used to sign broadcast operations. As the key name says (owner key, active key, posting key), they have different use cases. Normally, a single password is used to derive these four keys from it. This has the advantage that only one passphrase needs to be securely stored. I can change my account keys by generating a new password: ![New Password](https://images.hive.blog/DQmWagwVQs2GsJFQMMFpQCbLFSWxKS5jmDK5WYsfNAC6tkq/New%20Password) You need to `BACK IT UP BY STORING IN YOUR PASSWORD MANAGER OR A TEXT FILE.`, but what happens when your hard drive is failing or your password manager (lost the master password, ...)? You can print it, but what happens in case of a fire or water damage? ## Using your bitcoin seed for Hive When you have stored your bitcoin seed (consisting normally of 24 words) in metal, it would be great if you could use this also to store your Hive password. It is possible to use [BIP-85 (Deterministic Entropy From BIP32 Keychains)](https://github.com/bitcoin/bips/blob/master/bip-0085.mediawiki) for creating a new password for a hive account using a coldcard mk3 hardware wallet (As far as I know this is the only device that support BIP85). ![coldcard](https://images.hive.blog/DQmYZebd2XQzeyxR2LhQEuiCmvAZpweC1ywThuBnkmAtHVb/coldcard) When I use the derived WIF to create a new Password for my Hive account, I do not need to store my Hive keys and Password anymore, as they can be recreated from the securely stored bitcoin seed (I need to remember the used index number, or I need to try all possible numbers from 0 to 9999). Thus I can increase my account security when I do not store the password and the owner key in my computer. ## How to use the coldcard mk3 to create a new Password for Hive This guide will use the [coldcard mk3](https://coldcardwallet.com/) which has the necessary bip-85 support and python (beem) for generating and changing the account keys. ### Storing a WIF on a sdcard At first we use the coldcard to derive a new WIF and store it on a sdcard. ![Go to Advanced](https://images.hive.blog/DQmUJxn6RzUbxNrXMMkP6PnT1UTMQC4kbHe6Ad1PYLiFyqD/Go%20to%20Advanced) ![Then to Derive Entropy](https://images.hive.blog/DQmVjNSAtvVtuiDPnM4u91D8VypYkdhx1UeVsooFzkhSFVs/Then%20to%20Derive%20Entropy) We need to select WIF: ![Then to WIF](https://images.hive.blog/DQmSn5u2kBPRsf7V5EiM2VrUSdKgS7VDQhkJjJCte8ZDS3f/Then%20to%20WIF) Select a number you can remember: ![Select a number](https://images.hive.blog/DQmRrywjVhNWgscazDfVV9f1UrmVZKhpU1R9xj6xEjN7DT4/Select%20a%20number) Store the WIF to the MicroSD: ![Press 1 to store the WIF on the sd card](https://images.hive.blog/DQmQiWagr6YLFoPCjrBBptJqGAhP5GP5ZzbGomEio1xYfAa/Press%201%20to%20store%20the%20WIF%20on%20the%20sd%20card) ## Reading the WIF from the sdcard and change the HIVE keys We need the following python packages: ``` pip3 install beem ``` The WIF from the coldcard needs firstly converted into a HIVE WIF and then a password is derived by applying `PasswordKey` to it and adding a `P`: ``` from beemgraphenebase.account import PrivateKey, PasswordKey WIF=&quot;xxx&quot; # from coldcard wif = PrivateKey(WIF) pk = PasswordKey(&quot;&quot;, str(wif), role=&quot;&quot;) password = 'P' + str(pk.get_private()) print(password) ``` `password` is the new account password that can be set in `https://wallet.hive.blog/@/password` After changing the account password, the new posting, active and memo key should be stored and the Password and the WIF on the sdcard should be deleted. Whenever, an account key is getting lost or when the owner key is needed, it can be created from the derive WIF which is created by the coldcard. It is also possible to automate everything. The following script will * Read the sdcard and extract the WIF * Create a new Password for the account * Change the account password by broadcasting `update_account` ``` from beem import Hive from beemgraphenebase.account import PrivateKey, PasswordKey import argparse from prettytable import PrettyTable import sys import getpass if __name__ == &quot;__main__&quot;: parser = argparse.ArgumentParser(description=&quot;Derives a new password from a coldcard WIF&quot;) parser.add_argument('wiffile', type=str, nargs='?', help='colcard wif key file to read.') parser.add_argument('account', type=str, nargs='?', help='account name.') args = parser.parse_args() wiffile = args.wiffile account = args.account next_var = &quot;&quot; wif = &quot;&quot; path = &quot;&quot; with open(wiffile) as fp: for line in fp: if line.strip() == &quot;&quot;: continue if line.strip() == &quot;WIF (privkey):&quot;: next_var = &quot;wif&quot; continue elif &quot;Path Used&quot; in line.strip(): next_var = &quot;path&quot; continue if next_var == &quot;wif&quot;: wif = line.strip() elif next_var == &quot;path&quot;: path = line next_var = &quot;&quot; wif = PrivateKey(wif) pk = PasswordKey(&quot;&quot;, str(wif), role=&quot;&quot;) password = 'P' + str(pk.get_private()) owner_key = PasswordKey(account, password, role=&quot;owner&quot;) owner_pubkey = format(owner_key.get_public_key(), &quot;STM&quot;) active_key = PasswordKey(account, password, role=&quot;active&quot;) active_pubkey = format(active_key.get_public_key(), &quot;STM&quot;) posting_key = PasswordKey(account, password, role=&quot;posting&quot;) posting_pubkey = format(posting_key.get_public_key(), &quot;STM&quot;) memo_key = PasswordKey(account, password, role=&quot;memo&quot;) memo_pubkey = format(memo_key.get_public_key(), &quot;STM&quot;) t = PrettyTable([&quot;Key&quot;, &quot;Value&quot;]) t.align = &quot;l&quot; t.add_row([&quot;Account&quot;, account]) t.add_row([&quot;Path&quot;, path]) t.add_row([&quot;New owner pubkey&quot;, owner_pubkey]) t.add_row([&quot;New active pubkey&quot;, active_pubkey]) t.add_row([&quot;New posting pubkey&quot;, posting_pubkey]) t.add_row([&quot;New memo pubkey&quot;, memo_pubkey]) print(t) ret = input(&quot;Broadcast update_account with new keys? [y/n]&quot;) if ret in [&quot;y&quot;, &quot;yes&quot;]: owner_key = getpass.getpass(prompt=&quot;current owner key:&quot;) hive = Hive(keys=[owner_key]) tx = hive.update_account(account, owner_key=owner_pubkey, active_key=active_pubkey, posting_key=posting_pubkey, memo_key=memo_pubkey) print(tx) ret = input(&quot;Show private keys? [y/n]&quot;) if ret in [&quot;y&quot;, &quot;yes&quot;]: t = PrettyTable([&quot;Key&quot;, &quot;Value&quot;]) t.align = &quot;l&quot; t.add_row([&quot;active privkey&quot;, str(active_key.get_private_key())]) t.add_row([&quot;posting privkey&quot;, str(posting_key.get_private_key())]) t.add_row([&quot;memo privkey&quot;, str(memo_key.get_private_key())]) print(t) ret = input(&quot;Show owner key and password? [y/n]&quot;) if ret in [&quot;y&quot;, &quot;yes&quot;]: t = PrettyTable([&quot;Key&quot;, &quot;Value&quot;]) t.align = &quot;l&quot; t.add_row([&quot;owner privkey&quot;, str(owner_key.get_private_key())]) t.add_row([&quot;Password&quot;, str(password)]) print(t) del owner_key del memo_key del posting_key del active_key del password ``` This needs to be stored as py file (e.g. new_password.py) and can then be called: ``` python3 new_password.py F:\drv-wif-idx0.txt holger80 ``` where `F:\drv-wif-idx0.txt` is the path to the exported WIF file. Deleting the WIF text file on the sdcard needs to be done by hand (remember to store the used index number). I'm currently adding this also to beempy, the CLI tool in beem. There is also a second way in creating a new password from a seed using hardware wallet (signing a message), which I'm investigating right now. ___ *If you like what I do, consider casting a vote for me as witness on [Hivesigner](https://hivesigner.com/sign/account-witness-vote?witness=holger80&amp;amp;approve=1) or on [PeakD](https://peakd.com/witnesses)*&amp;lt;/div&amp;gt; See: How to use a coldcard MK3 to derive your new account password from a 24 word seed by @holger80</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://images.hive.blog/DQmWagwVQs2GsJFQMMFpQCbLFSWxKS5jmDK5WYsfNAC6tkq/New%20Password" /><media:content medium="image" url="https://images.hive.blog/DQmWagwVQs2GsJFQMMFpQCbLFSWxKS5jmDK5WYsfNAC6tkq/New%20Password" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Roadmap for Hive-related work by BlockTrades in the next 6 months</title><link href="https://hivedocs.info/news/core/development/2020/12/02/roadmap-for-hive-related-work-by-blocktrades-in-the-next-6-months.html" rel="alternate" type="text/html" title="Roadmap for Hive-related work by BlockTrades in the next 6 months" /><published>2020-12-02T15:36:21-08:00</published><updated>2020-12-02T15:36:21-08:00</updated><id>https://hivedocs.info/news/core/development/2020/12/02/roadmap-for-hive-related-work-by-blocktrades-in-the-next-6-months</id><content type="html" xml:base="https://hivedocs.info/news/core/development/2020/12/02/roadmap-for-hive-related-work-by-blocktrades-in-the-next-6-months.html">&lt;div id=&quot;content-blocktrades-roadmap-for-hive-related-work-by-blocktrades-in-the-next-6-months&quot;&gt;The BlockTrades team is planning a lot of future work to the Hive ecosystem. This posts details some of the changes we’re planning so far. 

I want to apologize in advance, as this is still a somewhat raw dump of my thoughts about sometimes complicated issues. This means that some of the topics are written for everyone, but other topics contain fairly technical details that will likely be difficult to grasp at first reading (and maybe subsequent ones). As we get closer to implementation of some of these ideas, I’ll try to elaborate more on individual ideas from this post in later posts (if someone else hasn’t taken on that challenge in the meantime).

I’m dividing these changes up into several categories, because they impact different systems and therefore have different scheduling needs.


# Blockchain-consensus changes (hardfork changes)

These are changes to Hive’s governance model, so they require a hardfork and approval by the top 20 witnesses. 

Hardfork changes require all nodes to update to continue operating on the Hive network, which is a bit of a pain to coordinate, so Hive devs try to avoid requiring too many hardforks (usually by scheduling several hardfork changes at once). 

The current plan is to schedule hardfork 25 for around 6 months from now (mainly to avoid requiring exchanges from having too upgrade too soon after the last hardfork). The protocol changes planned for hardfork 25 are expected to be rather easy changes and will likely be coded much sooner than 6 months from now.

The changes planned for the hardfork are NOT required in order to execute on our other planned changes to the Hive ecosystem: this means we can make many important and useful changes to Hive before the next hardfork.

# What about HMTs (user-defined tokens)?

The only potential change we might conceivably make to the blockchain rules in hardfork 25 that wouldn’t necessarily be easy would be enabling HMTs (mainly because the HMT code hasn’t been tested well yet and would likely need improvements prior to release). 

At this point, we haven’t made any decision about whether or not to enable HMTs, because we think there’s a reasonable chance that we can do something more useful in the way of tokenization at the 2nd layer. In short, the topic needs more research, and will be discussed in depth in a later post, after we’ve fully explored the options. 

My personal preference at the moment is to implement user-defined tokens at the 2nd layer using a smart contract evaluation system, which will allow for much more flexibility than is possible with HMTs. But to make this feasible, we have to define a robust model for decentralized 2nd layer apps (to be discussed more in later sections of this post). 

It’s also worth noting that these don’t have to be exclusive options: it’s possible to implement HMTs at the first layer and smart contract-based tokens at the 2nd layer. But this could be more confusing for Hive users and may offer no real benefit.

# Governance changes planned for hardfork 25

##  Vote expiration for witnesses, proxies, and proposals

Currently governance votes don’t expire, which can lead to votes that never change, either due to inattention of the voter or in worse cases, because the owner loses their keys or passes away (yes, on Hive, dead people really can still be voting). This can lead to non-optimal voting, since the stake isn’t properly monitoring the people and proposals being voted for.

To address this issue, we’ll set governance votes to automatically expire one year after the last governance action by an account. This will be implemented by storing a “last governance action time” for each Hive account (this information will be part of an account’s profile information).

Whenever a user sets a voting proxy, or vote/unvotes a witness or a proposal, this last governance action time will be updated to the current time. If a year passes without a governance action by the account, the account’s votes for witnesses and proposals will be canceled, and any proxying of the account will be reset.

User interfaces like Hive wallets and browsers will be updated to report a warning when an account’s votes are getting near to expiration. Such warnings should prevent any active user from forgetting to take a governance action that keeps their votes from expiring.

Just to be clear about how this works in practice: your votes will only expire if you don’t take any governance action for an entire year. So this change should only impact people who are no longer “paying attention” to what’s going on (or who have lost control of their keys).

##  Change 5min vote window to longer window and provide proportional rewards during the window

Currently, voting earlier than 5 minutes after a post is published results in less curation rewards for the voter. This led to the rise of auto-vote bots that vote at or near the end of this 5 minute window, severely disadvantaging manual voters.

With this change, there will no longer be a penalty for early voting of a post/comment. Furthermore, there will be no advantage to voting earlier than anyone else who votes within the new longer time period. 

There will still be an advantage for voters who vote within the time window, but the idea is that the new window time should be long enough for manual curators to find good content, putting them on equal footing with the vote bots. 

How long should the new window be? I’d argue for somewhere between 2 hours and 24 hours at most. I generally favor it being closer to 2 hours, to allow for some friendly competition between manual voters, and to encourage somewhat rapid curation that brings good content to the trending page quicker.

This change isn’t expected to eliminate auto-vote bots, but it should remove the financial incentive to use an auto-vote bot instead of voting manually. 

This change will still lead to an incentive to select “popular” content, since voters during the first 2 hours will gain somewhat more rewards than later voters on a post.

The above means that “Smart” auto-vote bots will likely begin trailing successful manual curators by voting near the end of the 2 hour period in an attempt to maximize their rewards. On the whole, this incentive seems beneficial, since it should lead to good manual curation being the guiding force for how the bots vote as well.

# Non-consensus changes to hived blockchain software

These are changes that can be made without a hardfork, and often don’t require everyone to upgrade their node. Changes of this type include: 1) speed and memory optimizations, 2) minor bug fixes, 3) addition and changes to API functionality. They are also usually not very controversial, because they don’t affect governance.

Because non-consensus changes usually don’t require everyone to upgrade their node, these changes can be released whenever they are ready, instead of being scheduled as part of a big planned release. As a simple example, we’ve had 7 such non-consensus releases since HF 24 (we’re at hived v1.24.7 right now). 

Most of these changes only impacted API node operators, so normal witnesses and exchanges didn’t need to upgrade their nodes (most hived nodes are still running v1.24.2).

There’s several areas we can explore making non-consensus improvements to the blockchain:
1) further reductions to memory usage
2) improvements to peer-to-peer networking layer
3) improvements to API services
4) a hived plugin to provide real-time data to 2nd layer apps

Of the above areas, I believe 4) is the most critical change. Currently it takes over 4 days to sync all the existing blockchain data to a new hivemind instance. We should be able to significantly reduce this time by creating a custom plugin that can fill a hivemind database (we’ve made measurements that show that hivemind database filling time is the main bottleneck in hivemind full sync timing on a system with fast IO, because of cpu bottlenecking on the hived side).

Another issue is that the current hivemind “live sync” process intentionally lags 2 blocks behind the head block, because hivemind isn’t able to handle micro-forking by hived. The creation of a plugin that directly writes to hivemind’s database will allow for faster data filling and also allow hived to manage the required changes to hivemind’s database in the case of microforks. This, in turn, means that hivemind will be able to operate with the most recent block data, eliminating the 6 second lag (2 blocks behind the head block at 3s block intervals = 6s) that it currently has. This is very important for an interactive experience by Hive users on the various Hive frontends.

# Development of 2nd layer ecosystem

This is one of the areas where I expect we’ll be devoting the most time in the next few months. The most important thing I want to do is to create an easy framework for the creation of new Hive apps.

Right now, apps usually rely on API nodes to supply a lot of their blockchain information via API calls  (with the data coming from a hived blockchain node and the hivemind social media microservice). Some apps also directly process custom_json operations to implement functionality that is generally unique to their application. This approach “works”, but it could definitely be improved. 


## Implementation challenges for 2nd layer apps

One issue is that apps either need to run their own heavy weight API node or rely on the API nodes provided by others. Ideally, it should be possible for an app to run a lightweight node that provides all the data needed by the app, avoiding reliance on uptime and data integrity of external API nodes.

Another issue is the processing of custom_json streams (and other operations) in the face of forks, where operations in blocks that have already been processed have to be discarded in favor of new data. This is one of the most potentially problematic issues for any blockchain-based app.

## A lightweight framework for 2nd layer apps (via “modular hivemind” nodes)

To address, the above issues, we plan to create a lightweight framework using much of the technology stack of hivemind, combined with the new hived plugin we’re developing that will simplify real-time reception and processing of blockchain data and support easy fork-handling via a generic undo mechanism. 

However, unlike in a traditional hivemind installation, the operator of a 2nd layer node of this type will get to decide what data he wants to store and what APIs he wants to support. For example, a 2nd layer node that supports a game might initially only track account balances and game history, but no social media data. But if the node operator later wants to add more data and API support to their 2nd layer node, we want to make it easy to add it via some form of upgrade mechanism. I believe it was @howo that coined the term “modular hivemind” to refer to this idea.

## Consistency checking to decentralize trust in blockchain ecosystems

Note: this is one of those topics that I mentioned at the outset of this post that might not be trivial to understand unless you’re a programmer (and maybe not even then).

Another important capability that would be very useful for 2nd layer apps is a way of automating the checking of data consistency between multiple API servers. A system of this sort would go a long way towards reducing the need to trust any particular node that supports a 2nd layer app (i.e. decentralizing trust).

One way to do this would be for decentralized 2nd layer apps to periodically (for example, once every 1000 blocks) generate a hash of their state (or some portion thereof)  and publish it as a blockchain transaction. 2nd layer apps that generate the same hash are making a statement that they interpret the blockchain data in the same way (i.e. they are operating under the same protocol rules).

In such a system, 2nd layer apps can decide to operate by different rules (a protocol fork), while continuing to coexist on the same blockchain network. But by publishing hashes of their state, users will know which nodes have decided to operate under a common set of rules, and they can therefore make an informed choice about which nodes they want to rely on for data. Of course, a user can always decide to simply run their own node, which is something we want to make it much cheaper and easier to do. But even in this case, it’s very valuable information to know who is supporting a particular protocol, as the amount of consensus among protocol users is a major determinant of the value of that protocol.

# Increase development pace of open-source user interfaces for Hive (e.g hive.blog , ecency.com, etc)

For the past few months, I’ve focused on adding more user interface programmers to our team to support increased development of open-sourced Hive-based front ends. Naturally BlockTrades already employed a number of front-end programmers, but they were all tied up on other projects, and couldn’t be moved without serious impacts on the scheduling of those projects.

There’s little point in going into specifics at this moment as to the exact changes we’ll be making on Hive front ends, as often these changes are quite small, can be done at any time, and are generally driven by user demand. But I felt it’s important to say we recognize the importance of how user interfaces impact enjoyment of Hive in all it’s facets (as a currency, as a platform of blockchain based apps, and as a social media backbone) and that we will be increasing our efforts in this area.

# A new decentralized reputation/rating system using web-of-trust concepts

This last topic is the one that I’m most interested in, and I’ll have much more to say about it later, but it’s a huge topic and deserves many posts of its own to divide it up into digestible bites. 

The basic idea for this system is you assign judgment skill ratings to people you know in various disciplines and you also publish your own ratings on products/people/ideas. Based on who you trust and how much you trust them in different areas of judgment, this system will compute rating scores using your web of trust network on potentially any subject where people form opinions.

I almost didn’t mention it in this post, but since this is something like a roadmap of planned Hive-related work for BlockTrades and this will function as a 2nd layer Hive app, I figured I should at least give it a brief mention now, as I plan to start this effort in the next 6 months. I say “start” because the reputation/rating system is planned to be a long-term project that will grow over many years and expand to address many different areas. Initially, of course, we’ll need to focus on creating a prototype that covers a relative small subset of things that can be rated and a few mechanisms for computing ratings and analyzing how ratings change as a user makes changes to his trust network.

# Final note

Also note that this is just a roadmap of things BlockTrades is currently planning to work on. For example, @howo is working on support for recurrent payments currently, to allow for Patreon-style payment models.&lt;/div&gt;
&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;

&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@blocktrades&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/roadmap-for-hive-related-work-by-blocktrades-in-the-next-6-months&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-blocktrades-roadmap-for-hive-related-work-by-blocktrades-in-the-next-6-months').html();
      const outputElem = $('#content-blocktrades-roadmap-for-hive-related-work-by-blocktrades-in-the-next-6-months');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;

&lt;style&gt;
  #content-blocktrades-roadmap-for-hive-related-work-by-blocktrades-in-the-next-6-months {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-blocktrades-roadmap-for-hive-related-work-by-blocktrades-in-the-next-6-months code {
    background: white;
  }
  #content-blocktrades-roadmap-for-hive-related-work-by-blocktrades-in-the-next-6-months a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-blocktrades-roadmap-for-hive-related-work-by-blocktrades-in-the-next-6-months a:hover {
    border-bottom: 0;
  }
  #content-blocktrades-roadmap-for-hive-related-work-by-blocktrades-in-the-next-6-months h1 {
    font-size: 2.2em;
  }
  #content-blocktrades-roadmap-for-hive-related-work-by-blocktrades-in-the-next-6-months h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-blocktrades-roadmap-for-hive-related-work-by-blocktrades-in-the-next-6-months header small {
    color: #999;
    font-size: 50%;
  }
  #content-blocktrades-roadmap-for-hive-related-work-by-blocktrades-in-the-next-6-months img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;

&lt;p&gt;
  See: &lt;a href=&quot;https://hive.blog/hive-139531/@blocktrades/roadmap-for-hive-related-work-by-blocktrades-in-the-next-6-months&quot;&gt;Roadmap for Hive-related work by BlockTrades in the next 6 months&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@blocktrades&quot;&gt;@blocktrades&lt;/a&gt;
&lt;/p&gt;</content><author><name>blocktrades</name></author><category term="news" /><category term="core" /><category term="development" /><summary type="html">The BlockTrades team is planning a lot of future work to the Hive ecosystem. This posts details some of the changes we’re planning so far. I want to apologize in advance, as this is still a somewhat raw dump of my thoughts about sometimes complicated issues. This means that some of the topics are written for everyone, but other topics contain fairly technical details that will likely be difficult to grasp at first reading (and maybe subsequent ones). As we get closer to implementation of some of these ideas, I’ll try to elaborate more on individual ideas from this post in later posts (if someone else hasn’t taken on that challenge in the meantime). I’m dividing these changes up into several categories, because they impact different systems and therefore have different scheduling needs. # Blockchain-consensus changes (hardfork changes) These are changes to Hive’s governance model, so they require a hardfork and approval by the top 20 witnesses. Hardfork changes require all nodes to update to continue operating on the Hive network, which is a bit of a pain to coordinate, so Hive devs try to avoid requiring too many hardforks (usually by scheduling several hardfork changes at once). The current plan is to schedule hardfork 25 for around 6 months from now (mainly to avoid requiring exchanges from having too upgrade too soon after the last hardfork). The protocol changes planned for hardfork 25 are expected to be rather easy changes and will likely be coded much sooner than 6 months from now. The changes planned for the hardfork are NOT required in order to execute on our other planned changes to the Hive ecosystem: this means we can make many important and useful changes to Hive before the next hardfork. # What about HMTs (user-defined tokens)? The only potential change we might conceivably make to the blockchain rules in hardfork 25 that wouldn’t necessarily be easy would be enabling HMTs (mainly because the HMT code hasn’t been tested well yet and would likely need improvements prior to release). At this point, we haven’t made any decision about whether or not to enable HMTs, because we think there’s a reasonable chance that we can do something more useful in the way of tokenization at the 2nd layer. In short, the topic needs more research, and will be discussed in depth in a later post, after we’ve fully explored the options. My personal preference at the moment is to implement user-defined tokens at the 2nd layer using a smart contract evaluation system, which will allow for much more flexibility than is possible with HMTs. But to make this feasible, we have to define a robust model for decentralized 2nd layer apps (to be discussed more in later sections of this post). It’s also worth noting that these don’t have to be exclusive options: it’s possible to implement HMTs at the first layer and smart contract-based tokens at the 2nd layer. But this could be more confusing for Hive users and may offer no real benefit. # Governance changes planned for hardfork 25 ## Vote expiration for witnesses, proxies, and proposals Currently governance votes don’t expire, which can lead to votes that never change, either due to inattention of the voter or in worse cases, because the owner loses their keys or passes away (yes, on Hive, dead people really can still be voting). This can lead to non-optimal voting, since the stake isn’t properly monitoring the people and proposals being voted for. To address this issue, we’ll set governance votes to automatically expire one year after the last governance action by an account. This will be implemented by storing a “last governance action time” for each Hive account (this information will be part of an account’s profile information). Whenever a user sets a voting proxy, or vote/unvotes a witness or a proposal, this last governance action time will be updated to the current time. If a year passes without a governance action by the account, the account’s votes for witnesses and proposals will be canceled, and any proxying of the account will be reset. User interfaces like Hive wallets and browsers will be updated to report a warning when an account’s votes are getting near to expiration. Such warnings should prevent any active user from forgetting to take a governance action that keeps their votes from expiring. Just to be clear about how this works in practice: your votes will only expire if you don’t take any governance action for an entire year. So this change should only impact people who are no longer “paying attention” to what’s going on (or who have lost control of their keys). ## Change 5min vote window to longer window and provide proportional rewards during the window Currently, voting earlier than 5 minutes after a post is published results in less curation rewards for the voter. This led to the rise of auto-vote bots that vote at or near the end of this 5 minute window, severely disadvantaging manual voters. With this change, there will no longer be a penalty for early voting of a post/comment. Furthermore, there will be no advantage to voting earlier than anyone else who votes within the new longer time period. There will still be an advantage for voters who vote within the time window, but the idea is that the new window time should be long enough for manual curators to find good content, putting them on equal footing with the vote bots. How long should the new window be? I’d argue for somewhere between 2 hours and 24 hours at most. I generally favor it being closer to 2 hours, to allow for some friendly competition between manual voters, and to encourage somewhat rapid curation that brings good content to the trending page quicker. This change isn’t expected to eliminate auto-vote bots, but it should remove the financial incentive to use an auto-vote bot instead of voting manually. This change will still lead to an incentive to select “popular” content, since voters during the first 2 hours will gain somewhat more rewards than later voters on a post. The above means that “Smart” auto-vote bots will likely begin trailing successful manual curators by voting near the end of the 2 hour period in an attempt to maximize their rewards. On the whole, this incentive seems beneficial, since it should lead to good manual curation being the guiding force for how the bots vote as well. # Non-consensus changes to hived blockchain software These are changes that can be made without a hardfork, and often don’t require everyone to upgrade their node. Changes of this type include: 1) speed and memory optimizations, 2) minor bug fixes, 3) addition and changes to API functionality. They are also usually not very controversial, because they don’t affect governance. Because non-consensus changes usually don’t require everyone to upgrade their node, these changes can be released whenever they are ready, instead of being scheduled as part of a big planned release. As a simple example, we’ve had 7 such non-consensus releases since HF 24 (we’re at hived v1.24.7 right now). Most of these changes only impacted API node operators, so normal witnesses and exchanges didn’t need to upgrade their nodes (most hived nodes are still running v1.24.2). There’s several areas we can explore making non-consensus improvements to the blockchain: 1) further reductions to memory usage 2) improvements to peer-to-peer networking layer 3) improvements to API services 4) a hived plugin to provide real-time data to 2nd layer apps Of the above areas, I believe 4) is the most critical change. Currently it takes over 4 days to sync all the existing blockchain data to a new hivemind instance. We should be able to significantly reduce this time by creating a custom plugin that can fill a hivemind database (we’ve made measurements that show that hivemind database filling time is the main bottleneck in hivemind full sync timing on a system with fast IO, because of cpu bottlenecking on the hived side). Another issue is that the current hivemind “live sync” process intentionally lags 2 blocks behind the head block, because hivemind isn’t able to handle micro-forking by hived. The creation of a plugin that directly writes to hivemind’s database will allow for faster data filling and also allow hived to manage the required changes to hivemind’s database in the case of microforks. This, in turn, means that hivemind will be able to operate with the most recent block data, eliminating the 6 second lag (2 blocks behind the head block at 3s block intervals = 6s) that it currently has. This is very important for an interactive experience by Hive users on the various Hive frontends. # Development of 2nd layer ecosystem This is one of the areas where I expect we’ll be devoting the most time in the next few months. The most important thing I want to do is to create an easy framework for the creation of new Hive apps. Right now, apps usually rely on API nodes to supply a lot of their blockchain information via API calls (with the data coming from a hived blockchain node and the hivemind social media microservice). Some apps also directly process custom_json operations to implement functionality that is generally unique to their application. This approach “works”, but it could definitely be improved. ## Implementation challenges for 2nd layer apps One issue is that apps either need to run their own heavy weight API node or rely on the API nodes provided by others. Ideally, it should be possible for an app to run a lightweight node that provides all the data needed by the app, avoiding reliance on uptime and data integrity of external API nodes. Another issue is the processing of custom_json streams (and other operations) in the face of forks, where operations in blocks that have already been processed have to be discarded in favor of new data. This is one of the most potentially problematic issues for any blockchain-based app. ## A lightweight framework for 2nd layer apps (via “modular hivemind” nodes) To address, the above issues, we plan to create a lightweight framework using much of the technology stack of hivemind, combined with the new hived plugin we’re developing that will simplify real-time reception and processing of blockchain data and support easy fork-handling via a generic undo mechanism. However, unlike in a traditional hivemind installation, the operator of a 2nd layer node of this type will get to decide what data he wants to store and what APIs he wants to support. For example, a 2nd layer node that supports a game might initially only track account balances and game history, but no social media data. But if the node operator later wants to add more data and API support to their 2nd layer node, we want to make it easy to add it via some form of upgrade mechanism. I believe it was @howo that coined the term “modular hivemind” to refer to this idea. ## Consistency checking to decentralize trust in blockchain ecosystems Note: this is one of those topics that I mentioned at the outset of this post that might not be trivial to understand unless you’re a programmer (and maybe not even then). Another important capability that would be very useful for 2nd layer apps is a way of automating the checking of data consistency between multiple API servers. A system of this sort would go a long way towards reducing the need to trust any particular node that supports a 2nd layer app (i.e. decentralizing trust). One way to do this would be for decentralized 2nd layer apps to periodically (for example, once every 1000 blocks) generate a hash of their state (or some portion thereof) and publish it as a blockchain transaction. 2nd layer apps that generate the same hash are making a statement that they interpret the blockchain data in the same way (i.e. they are operating under the same protocol rules). In such a system, 2nd layer apps can decide to operate by different rules (a protocol fork), while continuing to coexist on the same blockchain network. But by publishing hashes of their state, users will know which nodes have decided to operate under a common set of rules, and they can therefore make an informed choice about which nodes they want to rely on for data. Of course, a user can always decide to simply run their own node, which is something we want to make it much cheaper and easier to do. But even in this case, it’s very valuable information to know who is supporting a particular protocol, as the amount of consensus among protocol users is a major determinant of the value of that protocol. # Increase development pace of open-source user interfaces for Hive (e.g hive.blog , ecency.com, etc) For the past few months, I’ve focused on adding more user interface programmers to our team to support increased development of open-sourced Hive-based front ends. Naturally BlockTrades already employed a number of front-end programmers, but they were all tied up on other projects, and couldn’t be moved without serious impacts on the scheduling of those projects. There’s little point in going into specifics at this moment as to the exact changes we’ll be making on Hive front ends, as often these changes are quite small, can be done at any time, and are generally driven by user demand. But I felt it’s important to say we recognize the importance of how user interfaces impact enjoyment of Hive in all it’s facets (as a currency, as a platform of blockchain based apps, and as a social media backbone) and that we will be increasing our efforts in this area. # A new decentralized reputation/rating system using web-of-trust concepts This last topic is the one that I’m most interested in, and I’ll have much more to say about it later, but it’s a huge topic and deserves many posts of its own to divide it up into digestible bites. The basic idea for this system is you assign judgment skill ratings to people you know in various disciplines and you also publish your own ratings on products/people/ideas. Based on who you trust and how much you trust them in different areas of judgment, this system will compute rating scores using your web of trust network on potentially any subject where people form opinions. I almost didn’t mention it in this post, but since this is something like a roadmap of planned Hive-related work for BlockTrades and this will function as a 2nd layer Hive app, I figured I should at least give it a brief mention now, as I plan to start this effort in the next 6 months. I say “start” because the reputation/rating system is planned to be a long-term project that will grow over many years and expand to address many different areas. Initially, of course, we’ll need to focus on creating a prototype that covers a relative small subset of things that can be rated and a few mechanisms for computing ratings and analyzing how ratings change as a user makes changes to his trust network. # Final note Also note that this is just a roadmap of things BlockTrades is currently planning to work on. For example, @howo is working on support for recurrent payments currently, to allow for Patreon-style payment models. See: Roadmap for Hive-related work by BlockTrades in the next 6 months by @blocktrades</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://hivedocs.info/assets/images/favicon.png" /><media:content medium="image" url="https://hivedocs.info/assets/images/favicon.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">NPM module for Hive Keychain</title><link href="https://hivedocs.info/news/nodejs/hive-keychain/2020/12/02/npm-module-for-hive-keychain.html" rel="alternate" type="text/html" title="NPM module for Hive Keychain" /><published>2020-12-02T02:19:03-08:00</published><updated>2020-12-02T02:19:03-08:00</updated><id>https://hivedocs.info/news/nodejs/hive-keychain/2020/12/02/npm-module-for-hive-keychain</id><content type="html" xml:base="https://hivedocs.info/news/nodejs/hive-keychain/2020/12/02/npm-module-for-hive-keychain.html">&lt;div id=&quot;content-therealwolf-npm-module-for-hive-keychain&quot;&gt;Greetings #Hivers,

I've created a small Keychain helper for myself a while ago and recently converted it to an npm module to make it easier for other devs to integrate Keychain into their websites. Seriously, just install it and you're good to go.

&amp;gt; https://www.npmjs.com/package/@hiveio/keychain

&amp;gt; https://gitlab.syncad.com/hive/keychain-node

## Example Code

```
import {keychain, isKeychainInstalled, hasKeychainBeenUsed} from '@hiveio/keychain'

const {success, msg, cancel, notInstalled, notActive} = await keychain(window, 'requestTransfer', 'test', 'therealwolf', 5, 'test memo', 'HIVE')

// All good
if(success) {
 // do your thing
}
// User didn't cancel, so something must have happened
else if(!cancel) {
  if(notActive) {
    // alert('Please allow Keychain to access this website')
  } else if(notInstalled) {
    // alert('Please install Keychain')
  } else {
    // error happened - check msg
  }
}
```

## Explanation

- `keychain`: run a specific keychain function
- `isKeychainInstalled`: checks whether keychain is installed and can be found within the window object.
- `hasKeychainBeenUsed`: checks whether a key/value inside the localStorage exists, which means Keychain has been used before, but isn't active. That can happen if extensions have to be activated per site.

- `notInstalled`: Return boolean from `keychain` with same logic as `isKeychainInstalled`
- `notActive`: Return boolean from `keychain` with same logic as `hasKeychainBeenUsed`
- `cancel`: Return boolean from `keychain` which indicates whether the Keychain popup has been closed, thus cancelled. Should be ignored.
- `success`: Return boolean from `keychain` which indicates whether the transaction was successful. Will be false in case of `cancel`.
- `msg`: Return string from `keychain` which can be an error.

For the normal workflow, you don't need to use `isKeychainInstalled` or `hasKeychainBeenUsed` as it's automatically checked when running `keychain`. These functions mostly matter for UX purposes.

---

Happy coding!&lt;/div&gt;
&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;

&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@therealwolf&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/npm-module-for-hive-keychain&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-therealwolf-npm-module-for-hive-keychain').html();
      const outputElem = $('#content-therealwolf-npm-module-for-hive-keychain');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;

&lt;style&gt;
  #content-therealwolf-npm-module-for-hive-keychain {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-therealwolf-npm-module-for-hive-keychain code {
    background: white;
  }
  #content-therealwolf-npm-module-for-hive-keychain a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-therealwolf-npm-module-for-hive-keychain a:hover {
    border-bottom: 0;
  }
  #content-therealwolf-npm-module-for-hive-keychain h1 {
    font-size: 2.2em;
  }
  #content-therealwolf-npm-module-for-hive-keychain h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-therealwolf-npm-module-for-hive-keychain header small {
    color: #999;
    font-size: 50%;
  }
  #content-therealwolf-npm-module-for-hive-keychain img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;

&lt;p&gt;
  See: &lt;a href=&quot;https://peakd.com/hive-139531/@therealwolf/npm-module-for-hive-keychain&quot;&gt;NPM module for Hive Keychain&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@therealwolf&quot;&gt;@therealwolf&lt;/a&gt;
&lt;/p&gt;</content><author><name>therealwolf</name></author><category term="news" /><category term="nodejs" /><category term="hive-keychain" /><summary type="html">Greetings #Hivers, I've created a small Keychain helper for myself a while ago and recently converted it to an npm module to make it easier for other devs to integrate Keychain into their websites. Seriously, just install it and you're good to go. &amp;gt; https://www.npmjs.com/package/@hiveio/keychain &amp;gt; https://gitlab.syncad.com/hive/keychain-node ## Example Code ``` import {keychain, isKeychainInstalled, hasKeychainBeenUsed} from '@hiveio/keychain' const {success, msg, cancel, notInstalled, notActive} = await keychain(window, 'requestTransfer', 'test', 'therealwolf', 5, 'test memo', 'HIVE') // All good if(success) { // do your thing } // User didn't cancel, so something must have happened else if(!cancel) { if(notActive) { // alert('Please allow Keychain to access this website') } else if(notInstalled) { // alert('Please install Keychain') } else { // error happened - check msg } } ``` ## Explanation - `keychain`: run a specific keychain function - `isKeychainInstalled`: checks whether keychain is installed and can be found within the window object. - `hasKeychainBeenUsed`: checks whether a key/value inside the localStorage exists, which means Keychain has been used before, but isn't active. That can happen if extensions have to be activated per site. - `notInstalled`: Return boolean from `keychain` with same logic as `isKeychainInstalled` - `notActive`: Return boolean from `keychain` with same logic as `hasKeychainBeenUsed` - `cancel`: Return boolean from `keychain` which indicates whether the Keychain popup has been closed, thus cancelled. Should be ignored. - `success`: Return boolean from `keychain` which indicates whether the transaction was successful. Will be false in case of `cancel`. - `msg`: Return string from `keychain` which can be an error. For the normal workflow, you don't need to use `isKeychainInstalled` or `hasKeychainBeenUsed` as it's automatically checked when running `keychain`. These functions mostly matter for UX purposes. --- Happy coding! See: NPM module for Hive Keychain by @therealwolf</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://hivedocs.info/assets/images/favicon.png" /><media:content medium="image" url="https://hivedocs.info/assets/images/favicon.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hivesearcher website opensourced</title><link href="https://hivedocs.info/seo/api/2020/11/27/hivesearcher-website-opensourced.html" rel="alternate" type="text/html" title="Hivesearcher website opensourced" /><published>2020-11-27T04:26:03-08:00</published><updated>2020-11-27T04:26:03-08:00</updated><id>https://hivedocs.info/seo/api/2020/11/27/hivesearcher-website-opensourced</id><content type="html" xml:base="https://hivedocs.info/seo/api/2020/11/27/hivesearcher-website-opensourced.html">&lt;div id=&quot;content-good-karma-hivesearcher-website-opensourced&quot;&gt;We have opensourced Hivesearcher website earlier today and pushed some documentation improvements.

&lt;center&gt;![hivesearcher-decentralized-search-engine](https://images.ecency.com/p/C3TZR1g81UNbFzApDTmvFYMje8p1iesaAcNjSh7JWYRiPQRX52L6rNRZipeiaBkx9daTxCyJyVvcKo3QMC9tjfRvNzgHxYuYyj6AFmCrd98w27oav6Nh8m4)&lt;/center&gt;

Website is written in reactjs and python. Although structure of website is quite simple, we think opensourcing website just like hivesearcher hivemind plugin would allow more development contribution and transparency on how things work.

If you are developer, feel free to checkout source code and contribute. https://github.com/ecency/hivesearcher

Website also include some neat features which we didn't announce before. You can embed hivesearcher with iframe into your website. So any website potentially can integrate hivesearcher without API key as well. Getting API key is completely free, so if you are willing to create your own search user interface then API key approach is best. Embedding option is only for those who have limited programming skills or who has wordpress blogs where can easily embed iframe search functionality.

Updated documentation page with more examples and information. In future, we plan to have interactive style documentation so it is much easier to test before integrating. Also document iframe usage and showcase integrated dapps.

## Are you dapp developer?

[Integrate Hivesearcher](https://ecency.com/hive-139531/@good-karma/hivesearcher-free-integrate-it-into-your-hive-apps) into your app and offer best search, discovery experience to your users.

---

- Source website: https://github.com/ecency/hivesearcher
- Source plugin: https://github.com/ecency/hive2elastic
&lt;/div&gt;
&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;

&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@good-karma&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/hivesearcher-website-opensourced&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-good-karma-hivesearcher-website-opensourced').html();
      const outputElem = $('#content-good-karma-hivesearcher-website-opensourced');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;

&lt;style&gt;
  #content-good-karma-hivesearcher-website-opensourced {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-good-karma-hivesearcher-website-opensourced code {
    background: white;
  }
  #content-good-karma-hivesearcher-website-opensourced a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-good-karma-hivesearcher-website-opensourced a:hover {
    border-bottom: 0;
  }
  #content-good-karma-hivesearcher-website-opensourced h1 {
    font-size: 2.2em;
  }
  #content-good-karma-hivesearcher-website-opensourced h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-good-karma-hivesearcher-website-opensourced header small {
    color: #999;
    font-size: 50%;
  }
  #content-good-karma-hivesearcher-website-opensourced img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;

&lt;p&gt;
  See: &lt;a href=&quot;https://hive.blog/hive-139531/@good-karma/hivesearcher-website-opensourced&quot;&gt;Hivesearcher website opensourced&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@good-karma&quot;&gt;@good-karma&lt;/a&gt;
&lt;/p&gt;</content><author><name>good-karma</name></author><category term="seo" /><category term="api" /><summary type="html">We have opensourced Hivesearcher website earlier today and pushed some documentation improvements. ![hivesearcher-decentralized-search-engine](https://images.ecency.com/p/C3TZR1g81UNbFzApDTmvFYMje8p1iesaAcNjSh7JWYRiPQRX52L6rNRZipeiaBkx9daTxCyJyVvcKo3QMC9tjfRvNzgHxYuYyj6AFmCrd98w27oav6Nh8m4) Website is written in reactjs and python. Although structure of website is quite simple, we think opensourcing website just like hivesearcher hivemind plugin would allow more development contribution and transparency on how things work. If you are developer, feel free to checkout source code and contribute. https://github.com/ecency/hivesearcher Website also include some neat features which we didn't announce before. You can embed hivesearcher with iframe into your website. So any website potentially can integrate hivesearcher without API key as well. Getting API key is completely free, so if you are willing to create your own search user interface then API key approach is best. Embedding option is only for those who have limited programming skills or who has wordpress blogs where can easily embed iframe search functionality. Updated documentation page with more examples and information. In future, we plan to have interactive style documentation so it is much easier to test before integrating. Also document iframe usage and showcase integrated dapps. ## Are you dapp developer? [Integrate Hivesearcher](https://ecency.com/hive-139531/@good-karma/hivesearcher-free-integrate-it-into-your-hive-apps) into your app and offer best search, discovery experience to your users. --- - Source website: https://github.com/ecency/hivesearcher - Source plugin: https://github.com/ecency/hive2elastic See: Hivesearcher website opensourced by @good-karma</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://images.ecency.com/p/C3TZR1g81UNbFzApDTmvFYMje8p1iesaAcNjSh7JWYRiPQRX52L6rNRZipeiaBkx9daTxCyJyVvcKo3QMC9tjfRvNzgHxYuYyj6AFmCrd98w27oav6Nh8m4" /><media:content medium="image" url="https://images.ecency.com/p/C3TZR1g81UNbFzApDTmvFYMje8p1iesaAcNjSh7JWYRiPQRX52L6rNRZipeiaBkx9daTxCyJyVvcKo3QMC9tjfRvNzgHxYuYyj6AFmCrd98w27oav6Nh8m4" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">How To Setup Hive Witness Pricefeed Using Hivefeed-JS</title><link href="https://hivedocs.info/howto/witness/pricefeed/2020/11/26/how-to-setup-hive-witness-pricefeed-using-hivefeed-js.html" rel="alternate" type="text/html" title="How To Setup Hive Witness Pricefeed Using Hivefeed-JS" /><published>2020-11-26T23:01:33-08:00</published><updated>2020-11-26T23:01:33-08:00</updated><id>https://hivedocs.info/howto/witness/pricefeed/2020/11/26/how-to-setup-hive-witness-pricefeed-using-hivefeed-js</id><content type="html" xml:base="https://hivedocs.info/howto/witness/pricefeed/2020/11/26/how-to-setup-hive-witness-pricefeed-using-hivefeed-js.html">&lt;div id=&quot;content-rishi556-how-to-setup-hive-witness-pricefeed-using-hivefeed-js&quot;&gt;Setting up a pricefeed is quite a simple task to do yet so many witnesses don't do it. I use it as one of my basic qualifiers on who I'll vote for a witness(if yours isn't updated in 3.5 days, no chance of getting my witness vote). It's a very basic thing to do and its just a quick and easy way to see how much a witness is paying attention to their own witness.

The pricefeed is how Hive knows about the price of Hive. Some events require Hive knowing its price, including post payout and hbd -&amp;gt; hive conversions. While only the top 20 witnesses's price feed is used(from what I've been told, please correct me if this is wrong), I believe its important for everyone running a witness to run a pricefeed. We have some pretty old pricefeeds in our witness rank, including some in the top 100 who've never broadcast a pricefeed at all and 4 in the top 30 who haven't updated their pricefeed in over a month.

I personally use @someguy123's hivefeed-js as I've been updating it myself too. It's quite easy to use and anyone on privex's node in a box gets it on their box so knowledge on how to use it might be useful. The codebase can be found here: https://github.com/someguy123/hivefeed-js.

Let's get onto the guide. If you are using privex's node in a box, you can skip the download the codebase part (the git pull). I'll also be explaining how to start it with node and pm2, not docker. The docker instructions are clear enough on the readme. Someguy says that he uses the docker version so he can restart it easily every few hours in case this breaks, but I've never seen it break due to reasons other than a bad node(which has since been fixed). 

### Set up

Always start with an update to the server, especially if you are like me and the first time is usually the only time you update your server. We'll also need git since we'll need to get the codebase. We'll also need nodejs and npm.

```
sudo apt-get update -y
sudo apt-get upgrade -y
sudo apt-get install git -y
sudo apt-get install npm -y
```

We'll want to update our version onf nodejs to 14 using n.

```
sudo npm i -g n
sudo n 14
```

Restart your ssh session as thats the easiest way to use the latest version of nodejs. 

Clone the repo(if you already have it, skip this step)

```
git clone https://github.com/Someguy123/hivefeed-js.git
```

Navigate to the directory we cloned or already have, if it's named something else, just change over to it. 

```
cd hivefeed-js
```

Install the dependencies with npm.

```
npm i
```

Install pm2 globally.

```
sudo npm i -g pm2
```
### Modifying the config

Now we'll need to change the config file to our liking. First we'll need to copy the example config to just config.

```
cp config.example.json config.json
```

Then we'll want to open it up using a text editor. I like nano, it's the easiest to use by far.

```
nano config.json
```

I won't be explaining advanced config, just the simple stuff. The main fields that you want to pay attention to is `name` which should be your username, `wif` which should be your private active key(yes there is a way to sign price feed updates with just your witness signing key, so far the easiest way to do that is with beem, someguy was looking into incorporating that into hivefeed and if I have time, I'm trying to do the same as well), and `interval` which is how often you want to broadcast in minutes. I recommend somewhere between 1-6 hours. Broadcasting too much will have no use with slight price changes and you don't want to broadcast too little either as the opposite problem can occur with larger price changes(one of the things I want to add is broadcasting upon a price shift of x% from your last broadcast). 

Those are the only ones you really need to change. There are a few other ones that I think you should know. `node` will let you pick the running node, the default being https://hived.privex.io and `alternate_nodes` will let you specify some alternate nodes to switch to if the default one fails. The default alternate nodes are https://api.hive.blog and https://api.deathwing.me. Node should just be a string and alternate_nodes should be an array of strings. Don't worry too much about these if you don't understand(feel free to ask me questions if you would like to learn more though). 

Save your config. Time to start it up.

### Starting up

Staring up is pretty simple. 

```
pm2 start app.js --name priceFeed
```

Thanks to pm2, if it crashes, it will automatically restart(though if it has other errors not leading to a crash it will not restart). If you want to monitor it, you can do `pm2 monitor` to see the running program with live logs, or `pm2 logs` to see some older logs logs and as more are written to the logs, it will add more. If you need to stop it for any reason, you can do `pm2 stop priceFeed`.

You won't see the price feed immediately publish. The first publish will happen after the amount of minutes that you set in the config. And there you go, you have setup your pricefeed. 

I do maintain the repo and so if you have any suggestions for features that you'd like, just lmk and if I ever find time for it, I'll get around to it. If you like what I do, considering voting my witness, @hextech. Here's a handy link for that: https://vote.hive.uno/@hextech&lt;/div&gt;
&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;

&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@rishi556&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/how-to-setup-hive-witness-pricefeed-using-hivefeed-js&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-rishi556-how-to-setup-hive-witness-pricefeed-using-hivefeed-js').html();
      const outputElem = $('#content-rishi556-how-to-setup-hive-witness-pricefeed-using-hivefeed-js');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;

&lt;style&gt;
  #content-rishi556-how-to-setup-hive-witness-pricefeed-using-hivefeed-js {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-rishi556-how-to-setup-hive-witness-pricefeed-using-hivefeed-js code {
    background: white;
  }
  #content-rishi556-how-to-setup-hive-witness-pricefeed-using-hivefeed-js a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-rishi556-how-to-setup-hive-witness-pricefeed-using-hivefeed-js a:hover {
    border-bottom: 0;
  }
  #content-rishi556-how-to-setup-hive-witness-pricefeed-using-hivefeed-js h1 {
    font-size: 2.2em;
  }
  #content-rishi556-how-to-setup-hive-witness-pricefeed-using-hivefeed-js h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-rishi556-how-to-setup-hive-witness-pricefeed-using-hivefeed-js header small {
    color: #999;
    font-size: 50%;
  }
  #content-rishi556-how-to-setup-hive-witness-pricefeed-using-hivefeed-js img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;

&lt;p&gt;
  See: &lt;a href=&quot;https://peakd.com/witness/@rishi556/how-to-setup-hive-witness-pricefeed-using-hivefeed-js&quot;&gt;How To Setup Hive Witness Pricefeed Using Hivefeed-JS&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@rishi556&quot;&gt;@rishi556&lt;/a&gt;
&lt;/p&gt;</content><author><name>rishi556</name></author><category term="howto" /><category term="witness" /><category term="pricefeed" /><summary type="html">Setting up a pricefeed is quite a simple task to do yet so many witnesses don't do it. I use it as one of my basic qualifiers on who I'll vote for a witness(if yours isn't updated in 3.5 days, no chance of getting my witness vote). It's a very basic thing to do and its just a quick and easy way to see how much a witness is paying attention to their own witness. The pricefeed is how Hive knows about the price of Hive. Some events require Hive knowing its price, including post payout and hbd -&amp;gt; hive conversions. While only the top 20 witnesses's price feed is used(from what I've been told, please correct me if this is wrong), I believe its important for everyone running a witness to run a pricefeed. We have some pretty old pricefeeds in our witness rank, including some in the top 100 who've never broadcast a pricefeed at all and 4 in the top 30 who haven't updated their pricefeed in over a month. I personally use @someguy123's hivefeed-js as I've been updating it myself too. It's quite easy to use and anyone on privex's node in a box gets it on their box so knowledge on how to use it might be useful. The codebase can be found here: https://github.com/someguy123/hivefeed-js. Let's get onto the guide. If you are using privex's node in a box, you can skip the download the codebase part (the git pull). I'll also be explaining how to start it with node and pm2, not docker. The docker instructions are clear enough on the readme. Someguy says that he uses the docker version so he can restart it easily every few hours in case this breaks, but I've never seen it break due to reasons other than a bad node(which has since been fixed). ### Set up Always start with an update to the server, especially if you are like me and the first time is usually the only time you update your server. We'll also need git since we'll need to get the codebase. We'll also need nodejs and npm. ``` sudo apt-get update -y sudo apt-get upgrade -y sudo apt-get install git -y sudo apt-get install npm -y ``` We'll want to update our version onf nodejs to 14 using n. ``` sudo npm i -g n sudo n 14 ``` Restart your ssh session as thats the easiest way to use the latest version of nodejs. Clone the repo(if you already have it, skip this step) ``` git clone https://github.com/Someguy123/hivefeed-js.git ``` Navigate to the directory we cloned or already have, if it's named something else, just change over to it. ``` cd hivefeed-js ``` Install the dependencies with npm. ``` npm i ``` Install pm2 globally. ``` sudo npm i -g pm2 ``` ### Modifying the config Now we'll need to change the config file to our liking. First we'll need to copy the example config to just config. ``` cp config.example.json config.json ``` Then we'll want to open it up using a text editor. I like nano, it's the easiest to use by far. ``` nano config.json ``` I won't be explaining advanced config, just the simple stuff. The main fields that you want to pay attention to is `name` which should be your username, `wif` which should be your private active key(yes there is a way to sign price feed updates with just your witness signing key, so far the easiest way to do that is with beem, someguy was looking into incorporating that into hivefeed and if I have time, I'm trying to do the same as well), and `interval` which is how often you want to broadcast in minutes. I recommend somewhere between 1-6 hours. Broadcasting too much will have no use with slight price changes and you don't want to broadcast too little either as the opposite problem can occur with larger price changes(one of the things I want to add is broadcasting upon a price shift of x% from your last broadcast). Those are the only ones you really need to change. There are a few other ones that I think you should know. `node` will let you pick the running node, the default being https://hived.privex.io and `alternate_nodes` will let you specify some alternate nodes to switch to if the default one fails. The default alternate nodes are https://api.hive.blog and https://api.deathwing.me. Node should just be a string and alternate_nodes should be an array of strings. Don't worry too much about these if you don't understand(feel free to ask me questions if you would like to learn more though). Save your config. Time to start it up. ### Starting up Staring up is pretty simple. ``` pm2 start app.js --name priceFeed ``` Thanks to pm2, if it crashes, it will automatically restart(though if it has other errors not leading to a crash it will not restart). If you want to monitor it, you can do `pm2 monitor` to see the running program with live logs, or `pm2 logs` to see some older logs logs and as more are written to the logs, it will add more. If you need to stop it for any reason, you can do `pm2 stop priceFeed`. You won't see the price feed immediately publish. The first publish will happen after the amount of minutes that you set in the config. And there you go, you have setup your pricefeed. I do maintain the repo and so if you have any suggestions for features that you'd like, just lmk and if I ever find time for it, I'll get around to it. If you like what I do, considering voting my witness, @hextech. Here's a handy link for that: https://vote.hive.uno/@hextech See: How To Setup Hive Witness Pricefeed Using Hivefeed-JS by @rishi556</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://hivedocs.info/assets/images/favicon.png" /><media:content medium="image" url="https://hivedocs.info/assets/images/favicon.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">My new contributions to the Hive Condenser</title><link href="https://hivedocs.info/news/nodejs/condenser/2020/11/25/6gshbx-my-new-contributions-to-the-hive-condenser.html" rel="alternate" type="text/html" title="My new contributions to the Hive Condenser" /><published>2020-11-25T21:27:09-08:00</published><updated>2020-11-25T21:27:09-08:00</updated><id>https://hivedocs.info/news/nodejs/condenser/2020/11/25/6gshbx-my-new-contributions-to-the-hive-condenser</id><content type="html" xml:base="https://hivedocs.info/news/nodejs/condenser/2020/11/25/6gshbx-my-new-contributions-to-the-hive-condenser.html">&lt;div id=&quot;content-quochuy-6gshbx-my-new-contributions-to-the-hive-condenser&quot;&gt;## Display more than 100 witnesses on the witness page
Currently https://wallet.hive.blog/~witnesses only displays the top100 witnesses with a text box that allows you to vote for low ranking witnesses, provided that you know about them. As I was working on some bug on the witnesses page, I noticed that the API allowed me to fetch more than 100 witnesses so I went on and increased the number of witnesses from 100 to 200 which is enough to cover all of our current active witnesses.

Increasing the number of witnesses from 100 to 200 also means that we have a lot of disabled/retired witnesses polluting the list. So in order to keep it clean, I've added a rule that filter disabled/retired witnesses off the list if their rank is greater than 100.

As a result of this, provided that the code change is approved, the following lower ranked witnesses will appear on the official witness page:
Rank 101: @mintrawa
Rank 103: @reazuliqbal
Rank 105: @fernandosoder
Rank 106: @jamzed
Rank 107: @dmitrydao
Rank 111: @lapingvino
Rank 117: @lootkit.witness
Rank 118: @hagie
Rank 129: @veteranforcrypto
Rank 130: @dpoll.witness
Rank 134: @elindos
Rank 142: @apshamilton
Rank 151: @whiterosecoffee
Rank 193: @pcste

![Screen Shot 2020-11-26 at 4.10.30 pm.png](https://images.hive.blog/DQmPLe1Qg7msSpA9gCRbPMFrbD62Tdrf8MW7Sd6ucLcMktD/Screen%20Shot%202020-11-26%20at%204.10.30%20pm.png)

Merge request: https://gitlab.syncad.com/hive/wallet/-/merge_requests/81

## Display witness owners on the witnesses page
Some users have chosen to have an alternate user accounts for their witnesses to separate regular social activities from witness activities. Some witness accounts were created and managed by more than one user.  This code change now display the owner(s) of a witness account.

![Display Hive witness owners](https://gitlab.syncad.com/hive/wallet/uploads/6371d6c52aa8b44c2bffc4152aae9fa6/Screen_Shot_2020-11-19_at_11.05.33_am.png)

Merge request: https://gitlab.syncad.com/hive/wallet/-/merge_requests/79

## Delegating Hive Power to another user from your wallet
This change was implemented several months ago but I forgot to announce it although it was announced in one of @blocktrades (Witness) posts. You now can access your [wallet](https://wallet.hive.blog/) and delegate some HP from the drop down menu from your Hive Power.

![Wallet delegate Hive Power](https://images.hive.blog/DQmSaiKUGQRNi1sLAEq1nvjYHRL5xdeGvKPeDZCXnrFDso7/Screen%20Shot%202020-11-26%20at%204.11.48%20pm.png)

A list of your current delegatees is also available in your wallet:
![Your delegatees](https://gitlab.syncad.com/hive/wallet/uploads/59615d9cac888bd41c9d22e09f2f708d/Screen_Shot_2020-05-23_at_9.38.21_pm.jpg)

If memory serves, this code was created on the Steemit Condenser and I've just ported it for Hive.

Merge request: https://gitlab.syncad.com/hive/wallet/-/merge_requests/16


## Other small changes
- Hide the @hivebuzz level banner for user accounts that are recently created and for which a level banner has not been created yet. https://gitlab.syncad.com/hive/condenser/-/merge_requests/160
- Fix the issue where the `witness_description` and `witness_owner` fields were no longer showing in the settings page. https://gitlab.syncad.com/hive/condenser/-/merge_requests/158

---

**Vote for my witness**
[![Support @quochuy Witness.jpg](https://images.hive.blog/DQmecYTZemY8SwU6rrg7awhpNRBsehUp7ivk9RGyZsUUpVw/quochuy-hive-witness.jpg)](https://hivesigner.com/sign/account-witness-vote?witness=quochuy&amp;amp;approve=1)
On Hive, Witnesses are playing the important role of providing a performant and safe network for all of us. You have the power to choose 30 trusty witnesses to package transactions and sign the blocks that will go in the Hive blockchain. [Vote for me via HiveSigner](https://hivesigner.com/sign/account-witness-vote?witness=quochuy&amp;amp;approve=1) to support my work for the community.&lt;/div&gt;
&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;

&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@quochuy&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/6gshbx-my-new-contributions-to-the-hive-condenser&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-quochuy-6gshbx-my-new-contributions-to-the-hive-condenser').html();
      const outputElem = $('#content-quochuy-6gshbx-my-new-contributions-to-the-hive-condenser');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;

&lt;style&gt;
  #content-quochuy-6gshbx-my-new-contributions-to-the-hive-condenser {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-quochuy-6gshbx-my-new-contributions-to-the-hive-condenser code {
    background: white;
  }
  #content-quochuy-6gshbx-my-new-contributions-to-the-hive-condenser a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-quochuy-6gshbx-my-new-contributions-to-the-hive-condenser a:hover {
    border-bottom: 0;
  }
  #content-quochuy-6gshbx-my-new-contributions-to-the-hive-condenser h1 {
    font-size: 2.2em;
  }
  #content-quochuy-6gshbx-my-new-contributions-to-the-hive-condenser h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-quochuy-6gshbx-my-new-contributions-to-the-hive-condenser header small {
    color: #999;
    font-size: 50%;
  }
  #content-quochuy-6gshbx-my-new-contributions-to-the-hive-condenser img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;

&lt;p&gt;
  See: &lt;a href=&quot;https://hive.blog/hive-139531/@quochuy/6gshbx-my-new-contributions-to-the-hive-condenser&quot;&gt;My new contributions to the Hive Condenser&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@quochuy&quot;&gt;@quochuy&lt;/a&gt;
&lt;/p&gt;</content><author><name>quochuy</name></author><category term="news" /><category term="nodejs" /><category term="condenser" /><summary type="html">## Display more than 100 witnesses on the witness page Currently https://wallet.hive.blog/~witnesses only displays the top100 witnesses with a text box that allows you to vote for low ranking witnesses, provided that you know about them. As I was working on some bug on the witnesses page, I noticed that the API allowed me to fetch more than 100 witnesses so I went on and increased the number of witnesses from 100 to 200 which is enough to cover all of our current active witnesses. Increasing the number of witnesses from 100 to 200 also means that we have a lot of disabled/retired witnesses polluting the list. So in order to keep it clean, I've added a rule that filter disabled/retired witnesses off the list if their rank is greater than 100. As a result of this, provided that the code change is approved, the following lower ranked witnesses will appear on the official witness page: Rank 101: @mintrawa Rank 103: @reazuliqbal Rank 105: @fernandosoder Rank 106: @jamzed Rank 107: @dmitrydao Rank 111: @lapingvino Rank 117: @lootkit.witness Rank 118: @hagie Rank 129: @veteranforcrypto Rank 130: @dpoll.witness Rank 134: @elindos Rank 142: @apshamilton Rank 151: @whiterosecoffee Rank 193: @pcste ![Screen Shot 2020-11-26 at 4.10.30 pm.png](https://images.hive.blog/DQmPLe1Qg7msSpA9gCRbPMFrbD62Tdrf8MW7Sd6ucLcMktD/Screen%20Shot%202020-11-26%20at%204.10.30%20pm.png) Merge request: https://gitlab.syncad.com/hive/wallet/-/merge_requests/81 ## Display witness owners on the witnesses page Some users have chosen to have an alternate user accounts for their witnesses to separate regular social activities from witness activities. Some witness accounts were created and managed by more than one user. This code change now display the owner(s) of a witness account. ![Display Hive witness owners](https://gitlab.syncad.com/hive/wallet/uploads/6371d6c52aa8b44c2bffc4152aae9fa6/Screen_Shot_2020-11-19_at_11.05.33_am.png) Merge request: https://gitlab.syncad.com/hive/wallet/-/merge_requests/79 ## Delegating Hive Power to another user from your wallet This change was implemented several months ago but I forgot to announce it although it was announced in one of @blocktrades (Witness) posts. You now can access your [wallet](https://wallet.hive.blog/) and delegate some HP from the drop down menu from your Hive Power. ![Wallet delegate Hive Power](https://images.hive.blog/DQmSaiKUGQRNi1sLAEq1nvjYHRL5xdeGvKPeDZCXnrFDso7/Screen%20Shot%202020-11-26%20at%204.11.48%20pm.png) A list of your current delegatees is also available in your wallet: ![Your delegatees](https://gitlab.syncad.com/hive/wallet/uploads/59615d9cac888bd41c9d22e09f2f708d/Screen_Shot_2020-05-23_at_9.38.21_pm.jpg) If memory serves, this code was created on the Steemit Condenser and I've just ported it for Hive. Merge request: https://gitlab.syncad.com/hive/wallet/-/merge_requests/16 ## Other small changes - Hide the @hivebuzz level banner for user accounts that are recently created and for which a level banner has not been created yet. https://gitlab.syncad.com/hive/condenser/-/merge_requests/160 - Fix the issue where the `witness_description` and `witness_owner` fields were no longer showing in the settings page. https://gitlab.syncad.com/hive/condenser/-/merge_requests/158 --- **Vote for my witness** [![Support @quochuy Witness.jpg](https://images.hive.blog/DQmecYTZemY8SwU6rrg7awhpNRBsehUp7ivk9RGyZsUUpVw/quochuy-hive-witness.jpg)](https://hivesigner.com/sign/account-witness-vote?witness=quochuy&amp;amp;approve=1) On Hive, Witnesses are playing the important role of providing a performant and safe network for all of us. You have the power to choose 30 trusty witnesses to package transactions and sign the blocks that will go in the Hive blockchain. [Vote for me via HiveSigner](https://hivesigner.com/sign/account-witness-vote?witness=quochuy&amp;amp;approve=1) to support my work for the community. See: My new contributions to the Hive Condenser by @quochuy</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://images.hive.blog/DQmPLe1Qg7msSpA9gCRbPMFrbD62Tdrf8MW7Sd6ucLcMktD/Screen%20Shot%202020-11-26%20at%204.10.30%20pm.png" /><media:content medium="image" url="https://images.hive.blog/DQmPLe1Qg7msSpA9gCRbPMFrbD62Tdrf8MW7Sd6ucLcMktD/Screen%20Shot%202020-11-26%20at%204.10.30%20pm.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hivemind API Extension, Community Curated Content and More</title><link href="https://hivedocs.info/news/hivemind/api/2020/11/24/hivemind-api-extension-community-curated-content-and-more.html" rel="alternate" type="text/html" title="Hivemind API Extension, Community Curated Content and More" /><published>2020-11-24T01:21:36-08:00</published><updated>2020-11-24T01:21:36-08:00</updated><id>https://hivedocs.info/news/hivemind/api/2020/11/24/hivemind-api-extension-community-curated-content-and-more</id><content type="html" xml:base="https://hivedocs.info/news/hivemind/api/2020/11/24/hivemind-api-extension-community-curated-content-and-more.html">&lt;div id=&quot;content-peakd-hivemind-api-extension-community-curated-content-and-more&quot;&gt;A new release of [peakd.com](https://peakd.com) is now available. Keep reading to discover the new features and check the full list of improvements ;)

&lt;center&gt;&lt;h4&gt;The new release is now live at https://peakd.com&lt;/h4&gt;&lt;/center&gt;

![release_cover_20201124.jpg](https://files.peakd.com/file/peakd-hive/peakd/af4z4wui-release_cover_20201124.jpg)


#### 1. Hivemind API Extensions

Until the [last HF](https://peakd.com/hiveblockchain/@hiveio/final-hive-hf24-date-set-october-6-2020) we have used our own Hivemind instance to power some of the features available on [peakd.com](https://peakd.com). This was required because some features as Favorites, Lists, Badges needs to access specific data not available on the standard API nodes.

Updating our own Hivemind database to the latest version was definitely possible (with a bit more effort on us than what used to be before the HF), but we decided to do a change in how we provide the required data for those features. So instead of updating the node we create a plugin (or extension) that can be installed on Hivemind servers to provide those additional APIs.

[![peakd-hivemind-plugin.png](https://raw.githubusercontent.com/peak-projects/peakd-hivemind-plugin/main/resources/cover.png)](https://github.com/peak-projects/peakd-hivemind-plugin)

Similar to what we have done with [Hive Node Beacon](https://github.com/peak-projects/peakd-node-beacon) a few weeks ago this plugin is available as an open source project on GitHub: https://github.com/peak-projects/peakd-hivemind-plugin.

Also having the plugin available as an independent open source project make it possible for node operators to run it and provide the additional features in a more decentralized way. A big thank you to @arcange and @emrebeyler for their help in setting up the first 2 nodes.


#### 2. New Curated Contents page for Communities

Communities can now configure a curator account that will enable a new tab/page to showcase a curated content list.

![Curated Content list for https://peakd.com/c/hive-193212/trail](https://files.peakd.com/file/peakd-hive/peakd/Y6SZD78j-image.png)

To configure the curator account just set the account name in the community settings:

![image.png](https://files.peakd.com/file/peakd-hive/peakd/EgMAentD-image.png)


#### 3. Show Top Viewed Daily/Weekly awards on posts

We started tracking views a few weeks ago, and we are constantly trying to improve on this. With this release we are starting an experimental tracking of the top daily/weekly viewed posts on peakd.com.

You can see 2 new awards on posts ranked as 'top of the day' or 'top of the week'.

![image.png](https://files.peakd.com/file/peakd-hive/peakd/GZaEfvyM-image.png)


#### 4. Mixcloud embeds and Improved Spotify support

With this release it's possible to embed Mixcloud playlists with a simple link: `https://www.mixcloud.com/MagneticMagazine/ambient-meditations-vol-21-anane`

And also support for Spotify as been improved and can now be embedded with just the link: `https://open.spotify.com/playlist/5UV4uC6N0lZ7q9ui3yIbqn?si=SGsfW4mYRGa2nA91e-cU1A`

The result should be similar to this:
https://open.spotify.com/playlist/5UV4uC6N0lZ7q9ui3yIbqn?si=SGsfW4mYRGa2nA91e-cU1A


#### 5. Add Rising Star to the Games section in Wallet

Rising Star is now included in the [wallet](https://peakd.com/wallet) 'Games' section.

![image.png](https://files.peakd.com/file/peakd-hive/peakd/6Mt6tve4-image.png)

Check our the game using this link: https://risingstargame.com/

#### 6. Some minor improvements and bug fixes

As always some minor improvements, updates and fixes across the website. You can check the full release notes here: **https://peakd.com/about/changelog**.

```
# Improvements and Fixes
------------------------------

[update] Improve layout and performance for Top Views page
[update] Don't load comments by default for user not logged in
[update] Show a button to publish a new post when an user blog is empty
[update] Mark notification as read on all browser tabs after casting the transaction
[update] Rework usage of 'get_account_history' API call to better handle the new behavior
[fix] Fix 'upcoming' indicator in Proposals page
```

---

## Support the @peakd project

Now is probably a nice time to remind you of the ways you can support the development of @peakd.

![Selection_298.png](https://files.peakd.com/file/peakd-hive/peakd/w36DQpO7-Selection_298.png)

We have a proposal on the Decentralized Hive Fund. You can review the proposal [here](/proposals/52).
If you agree to the proposal and you think the points mentioned add value to the Hive Blockchain consider supporting it using the above links or directly with **[this link](https://hivesigner.com/sign/update-proposal-votes?proposal_ids=[52]&amp;amp;approve=true)**.

---

We also run a witness server to help produce the blocks for the Hive Blockchain. You can vote for our witness so we are in a position to process more of them.

Vote on the witness page: https://peakd.com/witnesses

- Using Keychain: You just have to click and approve the transaction
- Using HiveSigner: You'll need access to confirm the transaction with your Active Key at least

---

###### *The PeakD Team*
_About us: https://peakd.com/about_
_Join us on Discord: https://discord.gg/Fy3bca5_&lt;/div&gt;
&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;

&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@peakd&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/hivemind-api-extension-community-curated-content-and-more&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-peakd-hivemind-api-extension-community-curated-content-and-more').html();
      const outputElem = $('#content-peakd-hivemind-api-extension-community-curated-content-and-more');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;

&lt;style&gt;
  #content-peakd-hivemind-api-extension-community-curated-content-and-more {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-peakd-hivemind-api-extension-community-curated-content-and-more code {
    background: white;
  }
  #content-peakd-hivemind-api-extension-community-curated-content-and-more a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-peakd-hivemind-api-extension-community-curated-content-and-more a:hover {
    border-bottom: 0;
  }
  #content-peakd-hivemind-api-extension-community-curated-content-and-more h1 {
    font-size: 2.2em;
  }
  #content-peakd-hivemind-api-extension-community-curated-content-and-more h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-peakd-hivemind-api-extension-community-curated-content-and-more header small {
    color: #999;
    font-size: 50%;
  }
  #content-peakd-hivemind-api-extension-community-curated-content-and-more img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;

&lt;p&gt;
  See: &lt;a href=&quot;https://peakd.com/hive-163399/@peakd/hivemind-api-extension-community-curated-content-and-more&quot;&gt;Hivemind API Extension, Community Curated Content and More&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@peakd&quot;&gt;@peakd&lt;/a&gt;
&lt;/p&gt;</content><author><name>peakd</name></author><category term="news" /><category term="hivemind" /><category term="api" /><summary type="html">A new release of [peakd.com](https://peakd.com) is now available. Keep reading to discover the new features and check the full list of improvements ;) The new release is now live at https://peakd.com ![release_cover_20201124.jpg](https://files.peakd.com/file/peakd-hive/peakd/af4z4wui-release_cover_20201124.jpg) #### 1. Hivemind API Extensions Until the [last HF](https://peakd.com/hiveblockchain/@hiveio/final-hive-hf24-date-set-october-6-2020) we have used our own Hivemind instance to power some of the features available on [peakd.com](https://peakd.com). This was required because some features as Favorites, Lists, Badges needs to access specific data not available on the standard API nodes. Updating our own Hivemind database to the latest version was definitely possible (with a bit more effort on us than what used to be before the HF), but we decided to do a change in how we provide the required data for those features. So instead of updating the node we create a plugin (or extension) that can be installed on Hivemind servers to provide those additional APIs. [![peakd-hivemind-plugin.png](https://raw.githubusercontent.com/peak-projects/peakd-hivemind-plugin/main/resources/cover.png)](https://github.com/peak-projects/peakd-hivemind-plugin) Similar to what we have done with [Hive Node Beacon](https://github.com/peak-projects/peakd-node-beacon) a few weeks ago this plugin is available as an open source project on GitHub: https://github.com/peak-projects/peakd-hivemind-plugin. Also having the plugin available as an independent open source project make it possible for node operators to run it and provide the additional features in a more decentralized way. A big thank you to @arcange and @emrebeyler for their help in setting up the first 2 nodes. #### 2. New Curated Contents page for Communities Communities can now configure a curator account that will enable a new tab/page to showcase a curated content list. ![Curated Content list for https://peakd.com/c/hive-193212/trail](https://files.peakd.com/file/peakd-hive/peakd/Y6SZD78j-image.png) To configure the curator account just set the account name in the community settings: ![image.png](https://files.peakd.com/file/peakd-hive/peakd/EgMAentD-image.png) #### 3. Show Top Viewed Daily/Weekly awards on posts We started tracking views a few weeks ago, and we are constantly trying to improve on this. With this release we are starting an experimental tracking of the top daily/weekly viewed posts on peakd.com. You can see 2 new awards on posts ranked as 'top of the day' or 'top of the week'. ![image.png](https://files.peakd.com/file/peakd-hive/peakd/GZaEfvyM-image.png) #### 4. Mixcloud embeds and Improved Spotify support With this release it's possible to embed Mixcloud playlists with a simple link: `https://www.mixcloud.com/MagneticMagazine/ambient-meditations-vol-21-anane` And also support for Spotify as been improved and can now be embedded with just the link: `https://open.spotify.com/playlist/5UV4uC6N0lZ7q9ui3yIbqn?si=SGsfW4mYRGa2nA91e-cU1A` The result should be similar to this: https://open.spotify.com/playlist/5UV4uC6N0lZ7q9ui3yIbqn?si=SGsfW4mYRGa2nA91e-cU1A #### 5. Add Rising Star to the Games section in Wallet Rising Star is now included in the [wallet](https://peakd.com/wallet) 'Games' section. ![image.png](https://files.peakd.com/file/peakd-hive/peakd/6Mt6tve4-image.png) Check our the game using this link: https://risingstargame.com/ #### 6. Some minor improvements and bug fixes As always some minor improvements, updates and fixes across the website. You can check the full release notes here: **https://peakd.com/about/changelog**. ``` # Improvements and Fixes ------------------------------ [update] Improve layout and performance for Top Views page [update] Don't load comments by default for user not logged in [update] Show a button to publish a new post when an user blog is empty [update] Mark notification as read on all browser tabs after casting the transaction [update] Rework usage of 'get_account_history' API call to better handle the new behavior [fix] Fix 'upcoming' indicator in Proposals page ``` --- ## Support the @peakd project Now is probably a nice time to remind you of the ways you can support the development of @peakd. ![Selection_298.png](https://files.peakd.com/file/peakd-hive/peakd/w36DQpO7-Selection_298.png) We have a proposal on the Decentralized Hive Fund. You can review the proposal [here](/proposals/52). If you agree to the proposal and you think the points mentioned add value to the Hive Blockchain consider supporting it using the above links or directly with **[this link](https://hivesigner.com/sign/update-proposal-votes?proposal_ids=[52]&amp;amp;approve=true)**. --- We also run a witness server to help produce the blocks for the Hive Blockchain. You can vote for our witness so we are in a position to process more of them. Vote on the witness page: https://peakd.com/witnesses - Using Keychain: You just have to click and approve the transaction - Using HiveSigner: You'll need access to confirm the transaction with your Active Key at least --- ###### *The PeakD Team* _About us: https://peakd.com/about_ _Join us on Discord: https://discord.gg/Fy3bca5_ See: Hivemind API Extension, Community Curated Content and More by @peakd</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://files.peakd.com/file/peakd-hive/peakd/af4z4wui-release_cover_20201124.jpg" /><media:content medium="image" url="https://files.peakd.com/file/peakd-hive/peakd/af4z4wui-release_cover_20201124.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hivecrypt: JavaScript module for Hive memo encrypt/decrypt on wide range of environments</title><link href="https://hivedocs.info/news/nodejs/encryption/2020/11/22/hivecrypt-javascript-module-for-hive-memo-encrypt-decrypt-on-wide-range-of-environments.html" rel="alternate" type="text/html" title="Hivecrypt: JavaScript module for Hive memo encrypt/decrypt on wide range of environments" /><published>2020-11-22T04:22:27-08:00</published><updated>2020-11-22T04:22:27-08:00</updated><id>https://hivedocs.info/news/nodejs/encryption/2020/11/22/hivecrypt-javascript-module-for-hive-memo-encrypt-decrypt-on-wide-range-of-environments</id><content type="html" xml:base="https://hivedocs.info/news/nodejs/encryption/2020/11/22/hivecrypt-javascript-module-for-hive-memo-encrypt-decrypt-on-wide-range-of-environments.html">&lt;div id=&quot;content-techcoderx-hivecrypt-javascript-module-for-hive-memo-encrypt-decrypt-on-wide-range-of-environments&quot;&gt;&lt;center&gt;![Hivecrypt thumbnail.png](https://ipfs.io/ipfs/QmZ44f49mDr746uqisE11de6WXa3ojka4oecYTsvTo6BNb)&lt;/center&gt;

Are you getting the following error message when trying to encrypt or decrypt a Hive memo in ElectronJS or React Native using [hive-js](https://gitlab.syncad.com/hive/hive-js)? Perhaps looking for something that works for your framework that you're using when building your cutting-edge Hive DApp?

&lt;center&gt;![Screenshot 20201122 at 12.04.23 PM.png](https://files.peakd.com/file/peakd-hive/techcoderx/kpahmLHh-Screenshot202020-11-2220at2012.04.2320PM.png)&lt;/center&gt;

Introducing [Hivecrypt](https://github.com/techcoderx/hivecrypt), a module that you can import into a wide range of JavaScript environments, including desktop and mobile app frameworks like ElectronJS, that wouldn't otherwise work with existing libraries.

Adapted from this [pull request](https://peakd.com/hive-139531/@tngflx/contribution-to-dhive-added-memo-encryption-and-decrypt-feature) on [dhive](https://gitlab.syncad.com/hive/dhive) that was never merged into `master` (plus the major help from this [file](https://github.com/mahdiyari/hive-tx-js/blob/master/helpers/crypto.js)), Hivecrypt was built on [Crypto-JS](https://github.com/brix/crypto-js) that works on virtually any latest JavaScript environments, unlike the implementation on [hive-js](https://gitlab.syncad.com/hive/hive-js) and the pull request mentioned above, that uses the [crypto](https://nodejs.org/api/crypto.html) NodeJS module that only works on certain environments.

## How to use?

Hivecrypt can be installed from `npm` with the following command:
```
npm i hivecrypt
```
It can also be imported into the browser by including the following script tag in your HTML file, where Hivecrypt will be available through `window.hivecrypt`:
```
&lt;script src=&quot;https://unpkg.com/hivecrypt/bin/hivecrypt.min.js&quot;&gt;&lt;/script&gt;
```

Once installed, it may be used for encrypting and decrypting memos just like how it is done with [hive-js](https://gitlab.syncad.com/hive/hive-js), but works in more environments.

```
const hivecrypt = require('hivecrypt') // CommonJS

let encrypted = hivecrypt.encode('privatekey1','publickey2','#somesecretmessage')
let decrypted = hivecrypt.decode('privatekey2',encrypted)

console.log(encrypted,decrypted)
```
It might not be built with optimizing for the smallest package size in mind, but at least it is something that is usable for devs.

&lt;center&gt;[![Hive witness footer 2.png](https://ipfs.io/ipfs/QmVTNReuWzvLtY5sucfunQ2m9JpLWroYrXrcztpVsZq3sG)](https://hivesigner.com/sign/account-witness-vote?witness=techcoderx&amp;amp;approve=1)&lt;/center&gt;&lt;/div&gt;
&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;

&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@techcoderx&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/hivecrypt-javascript-module-for-hive-memo-encrypt-decrypt-on-wide-range-of-environments&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-techcoderx-hivecrypt-javascript-module-for-hive-memo-encrypt-decrypt-on-wide-range-of-environments').html();
      const outputElem = $('#content-techcoderx-hivecrypt-javascript-module-for-hive-memo-encrypt-decrypt-on-wide-range-of-environments');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;

&lt;style&gt;
  #content-techcoderx-hivecrypt-javascript-module-for-hive-memo-encrypt-decrypt-on-wide-range-of-environments {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-techcoderx-hivecrypt-javascript-module-for-hive-memo-encrypt-decrypt-on-wide-range-of-environments code {
    background: white;
  }
  #content-techcoderx-hivecrypt-javascript-module-for-hive-memo-encrypt-decrypt-on-wide-range-of-environments a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-techcoderx-hivecrypt-javascript-module-for-hive-memo-encrypt-decrypt-on-wide-range-of-environments a:hover {
    border-bottom: 0;
  }
  #content-techcoderx-hivecrypt-javascript-module-for-hive-memo-encrypt-decrypt-on-wide-range-of-environments h1 {
    font-size: 2.2em;
  }
  #content-techcoderx-hivecrypt-javascript-module-for-hive-memo-encrypt-decrypt-on-wide-range-of-environments h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-techcoderx-hivecrypt-javascript-module-for-hive-memo-encrypt-decrypt-on-wide-range-of-environments header small {
    color: #999;
    font-size: 50%;
  }
  #content-techcoderx-hivecrypt-javascript-module-for-hive-memo-encrypt-decrypt-on-wide-range-of-environments img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;

&lt;p&gt;
  See: &lt;a href=&quot;https://peakd.com/hive-139531/@techcoderx/hivecrypt-javascript-module-for-hive-memo-encrypt-decrypt-on-wide-range-of-environments&quot;&gt;Hivecrypt: JavaScript module for Hive memo encrypt/decrypt on wide range of environments&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@techcoderx&quot;&gt;@techcoderx&lt;/a&gt;
&lt;/p&gt;</content><author><name>techcoderx</name></author><category term="news" /><category term="nodejs" /><category term="encryption" /><summary type="html">![Hivecrypt thumbnail.png](https://ipfs.io/ipfs/QmZ44f49mDr746uqisE11de6WXa3ojka4oecYTsvTo6BNb) Are you getting the following error message when trying to encrypt or decrypt a Hive memo in ElectronJS or React Native using [hive-js](https://gitlab.syncad.com/hive/hive-js)? Perhaps looking for something that works for your framework that you're using when building your cutting-edge Hive DApp? ![Screenshot 20201122 at 12.04.23 PM.png](https://files.peakd.com/file/peakd-hive/techcoderx/kpahmLHh-Screenshot202020-11-2220at2012.04.2320PM.png) Introducing [Hivecrypt](https://github.com/techcoderx/hivecrypt), a module that you can import into a wide range of JavaScript environments, including desktop and mobile app frameworks like ElectronJS, that wouldn't otherwise work with existing libraries. Adapted from this [pull request](https://peakd.com/hive-139531/@tngflx/contribution-to-dhive-added-memo-encryption-and-decrypt-feature) on [dhive](https://gitlab.syncad.com/hive/dhive) that was never merged into `master` (plus the major help from this [file](https://github.com/mahdiyari/hive-tx-js/blob/master/helpers/crypto.js)), Hivecrypt was built on [Crypto-JS](https://github.com/brix/crypto-js) that works on virtually any latest JavaScript environments, unlike the implementation on [hive-js](https://gitlab.syncad.com/hive/hive-js) and the pull request mentioned above, that uses the [crypto](https://nodejs.org/api/crypto.html) NodeJS module that only works on certain environments. ## How to use? Hivecrypt can be installed from `npm` with the following command: ``` npm i hivecrypt ``` It can also be imported into the browser by including the following script tag in your HTML file, where Hivecrypt will be available through `window.hivecrypt`: ``` ``` Once installed, it may be used for encrypting and decrypting memos just like how it is done with [hive-js](https://gitlab.syncad.com/hive/hive-js), but works in more environments. ``` const hivecrypt = require('hivecrypt') // CommonJS let encrypted = hivecrypt.encode('privatekey1','publickey2','#somesecretmessage') let decrypted = hivecrypt.decode('privatekey2',encrypted) console.log(encrypted,decrypted) ``` It might not be built with optimizing for the smallest package size in mind, but at least it is something that is usable for devs. [![Hive witness footer 2.png](https://ipfs.io/ipfs/QmVTNReuWzvLtY5sucfunQ2m9JpLWroYrXrcztpVsZq3sG)](https://hivesigner.com/sign/account-witness-vote?witness=techcoderx&amp;amp;approve=1) See: Hivecrypt: JavaScript module for Hive memo encrypt/decrypt on wide range of environments by @techcoderx</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://ipfs.io/ipfs/QmZ44f49mDr746uqisE11de6WXa3ojka4oecYTsvTo6BNb" /><media:content medium="image" url="https://ipfs.io/ipfs/QmZ44f49mDr746uqisE11de6WXa3ojka4oecYTsvTo6BNb" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>