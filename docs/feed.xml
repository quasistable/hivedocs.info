<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://hivedocs.info/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hivedocs.info/" rel="alternate" type="text/html" /><updated>2021-03-29T12:25:18-07:00</updated><id>https://hivedocs.info/feed.xml</id><title type="html">Hive Chain Documentation</title><subtitle>Your resource for various levels of Hive Documentation.</subtitle><author><name>site curated by: @inertia</name></author><entry><title type="html">Making a Decentralized Game on Hive - Part 3</title><link href="https://hivedocs.info/howto/nodejs/2021/03/28/making-a-decentralized-game-on-hive-part-3.html" rel="alternate" type="text/html" title="Making a Decentralized Game on Hive - Part 3" /><published>2021-03-28T13:31:39-07:00</published><updated>2021-03-28T13:31:39-07:00</updated><id>https://hivedocs.info/howto/nodejs/2021/03/28/making-a-decentralized-game-on-hive-part-3</id><content type="html" xml:base="https://hivedocs.info/howto/nodejs/2021/03/28/making-a-decentralized-game-on-hive-part-3.html">&lt;div id=&quot;content-mahdiyari-making-a-decentralized-game-on-hive-part-3&quot;&gt;&lt;center&gt;![coding-1853305_1280.jpg](https://images.hive.blog/DQmeBMvQ9RAne3j2qH1RrtDaWEyQ2bZo81ik3wsNXYGbp3E/coding-1853305_1280.jpg)&lt;/center&gt;

This part took a little longer because it was actually time-consuming (also I took a little break). The process is getting harder so it might take a few days longer than expected for the coming parts but I will do my best.

In the previous parts, we made a simple front-end with login functionality and initialized our API and back-end application with streaming. ([Part1](https://hive.blog/hive-139531/@mahdiyari/making-a-decentralized-game-on-hive-tic-tac-toe-part-1) and [Part2](https://hive.blog/hive-139531/@mahdiyari/making-a-decentralized-game-on-hive-part-2))
## MySQL Setup
You can use apps like [AMPPS](https://www.ampps.com/) which comes with MySQL and other tools like PHPMyAdmin (one of the best MySQL management apps) or install MySQL directly. I have AMMPS on windows and use MySQL docker on Linux. 

MySQL docker installation:
```
docker pull mysql/mysql-server:latest
```
I create a folder `/root/mysql-docker1` and put the MySQL config file there `my.cnf` and another folder `data` for holding the database files.
Running on port `127.0.0.1:3306`:
```
docker run --name=mysql1 \
--mount type=bind,src=/root/mysql-docker1/my.cnf,dst=/etc/my.cnf \
--mount type=bind,src=/root/mysql-docker1/data,dst=/var/lib/mysql \
-p 127.0.0.1:3306:3306 -d mysql/mysql-server:latest
```
There are different ways to tune your MySQL server based on your hardware which I'm not going to talk about. The following config is for medium-range hardware (32GB ram).
`my.cnf`:
```
[mysqld]
skip_name_resolve
user=mysql
default_authentication_plugin = mysql_native_password

symbolic-links=0
character_set_server=utf8mb4
collation_server=utf8mb4_general_ci
innodb_max_dirty_pages_pct = 90
innodb_max_dirty_pages_pct_lwm = 10
innodb_flush_neighbors = 0
innodb_undo_log_truncate=off
max_connect_errors = 1000000

# InnoDB Settings
innodb_file_per_table
innodb_log_files_in_group       = 2
innodb_open_files               = 4000
default_storage_engine          = InnoDB
innodb_buffer_pool_instances    = 8     # Use 1 instance per 1GB of InnoDB pool size
innodb_buffer_pool_size         = 16G    # Use up to 70-80% of RAM
innodb_flush_method             = O_DIRECT_NO_FSYNC
innodb_log_buffer_size          = 64M
innodb_log_file_size            = 10G
innodb_stats_on_metadata        = 0

# tune
innodb_doublewrite= 1
innodb_thread_concurrency       = 0
innodb_flush_log_at_trx_commit  = 0
innodb_lru_scan_depth           = 2048
innodb_page_cleaners            = 4
join_buffer_size                = 256K
sort_buffer_size                = 256K
innodb_use_native_aio           = 1
innodb_stats_persistent         = 1

innodb_adaptive_flushing        = 1
innodb_read_io_threads          = 16
innodb_write_io_threads         = 16
innodb_io_capacity              = 1500
innodb_io_capacity_max          = 2500
innodb_purge_threads            = 4
innodb_adaptive_hash_index      = 0
max_prepared_stmt_count         = 1000000
innodb_monitor_enable           = '%'
performance_schema              = ON
key_buffer_size = 512M
# Connection Settings
max_connections                 = 2000   # UPD
back_log                        = 3000
interactive_timeout             = 180
wait_timeout                    = 10
table_open_cache                = 200000 # UPD
table_open_cache_instances      = 64
open_files_limit                = 100000 # UPD
```
Note: restart MySQL server after updating the`my.cnf` file.

MySQL password on AMMPS is `mysql` and on docker setup, I think you get the password from `docker logs mysql1`. Anyway, there are many documentations about MySQL already on the internet.

Create a database `tictactoe`. It's easier with tools like PHPMyAdmin if you are using AMPPS. Or try HeidiSQL.
Here is the SQL command for creating the database:
```
CREATE DATABASE `tictactoe`;
```
***
## Development
Let's create a config file for holding MySQL login information for our app. I will put this file as `config.example.js` in repository and you have to rename it manually.
`config.js`:
```
const config = {
  dbName: 'tictactoe',
  dbUser: 'root',
  dbPassword: 'password',
  dbHost: '127.0.0.1',
  dbPort: 3306
}

module.exports = config
```
***
I have a personal code for MySQL connection pooling. It simply makes a custom async function just like the original connect function of [mysqljs](https://github.com/mysqljs/mysql) library but for pooling connections.
`helpers/mysql.js`:
```
const mysql = require('mysql')
const config = require('../config')
const pool = mysql.createPool({
  connectionLimit: 5,
  host: config.dbHost,
  port: config.dbPort,
  user: config.dbUser,
  password: config.dbPassword,
  database: config.dbName,
  charset: 'utf8mb4'
})

// Rewriting MySQL query method as a promise
const con = {}
con.query = async (query, val) =&amp;gt; {
  if (val) {
    const qu = await new Promise((resolve, reject) =&amp;gt; {
      pool.query(query, val, (error, results) =&amp;gt; {
        if (error) reject(new Error(error))
        resolve(results)
      })
    })
    return qu
  } else {
    const qu = await new Promise((resolve, reject) =&amp;gt; {
      pool.query(query, (error, results) =&amp;gt; {
        if (error) reject(new Error(error))
        resolve(results)
      })
    })
    return qu
  }
}

module.exports = con
```
It creates a pool of 5 connections which is more than enough for our game.
And of course:
```
npm install mysql
```
***
#### Initializing database
We make a function to create necessary tables if they don't exist already.
`helpers/initDatabase.js`:
```
const mysql = require('./mysql')

/**
 * id, game_id, player1, player2, starting_player, status, winner
 */
const tableGames =
  'CREATE TABLE IF NOT EXISTS `tictactoe`.`games` ( `id` INT NOT NULL AUTO_INCREMENT , ' +
  '`game_id` TINYTEXT NOT NULL , ' +
  '`player1` TINYTEXT NOT NULL , `player2` TINYTEXT NULL DEFAULT NULL , ' +
  '`starting_player` TINYTEXT NOT NULL , `status` TINYTEXT NULL , ' +
  '`winner` TINYTEXT NULL DEFAULT NULL , PRIMARY KEY  (`id`)) ' +
  'ENGINE = InnoDB CHARSET=utf8mb4 COLLATE utf8mb4_general_ci;'

/**
 * id, game_id, player, col, row
 */
const tableMoves =
  'CREATE TABLE IF NOT EXISTS `tictactoe`.`moves` ( `id` INT NOT NULL AUTO_INCREMENT , ' +
  '`game_id` TINYTEXT NOT NULL , `player` TINYTEXT NOT NULL , ' +
  '`col` INT(1) NOT NULL , `row` INT(1) NOT NULL , ' +
  'PRIMARY KEY  (`id`)) ENGINE = InnoDB CHARSET=utf8mb4 COLLATE utf8mb4_general_ci;'

const tableRquests =
  'CREATE TABLE IF NOT EXISTS `tictactoe`.`requests` ( `id` INT NOT NULL AUTO_INCREMENT , ' +
  '`game_id` TINYTEXT NOT NULL , `player` TINYTEXT NOT NULL , `status` TINYTEXT NOT NULL , ' +
  'PRIMARY KEY  (`id`)) ENGINE = InnoDB CHARSET=utf8mb4 COLLATE utf8mb4_general_ci;'

const initDatabase = async () =&amp;gt; {
  await mysql.query(tableGames)
  await mysql.query(tableMoves)
  await mysql.query(tableRquests)
}

module.exports = initDatabase
```

#### Created tables
`games`
&lt;center&gt;![tablesqlgames.png](https://images.hive.blog/DQmVCMyNZax6xd6kCc2VZijGjMa9Qbt8Myeev7jF8KmcqXe/image.png)&lt;/center&gt;

`moves`
&lt;center&gt;![tablesqlmoves.png](https://images.hive.blog/DQmVwyDZg1N3KEteDgfA5NdMHeUkjpngHZEmizBXxhh3XPs/image.png)&lt;/center&gt;

`requests`
&lt;center&gt;![image.png](https://images.hive.blog/DQmQLxfwKEfWSQ614vWb6qfUNVMSyiFgnKEh5nSWcKYFQQv/image.png)&lt;/center&gt;
***
#### Updating main application
Now we can complete the game methods in `index.js`:
`createGame`
```
const createGame = async (data, user) =&amp;gt; {
  if (!data || !data.id || !data.starting_player) {
    return
  }
  // validating
  if (
    data.id.length !== 20 ||
    (data.starting_player !== 'first' &amp;amp;&amp;amp; data.starting_player !== 'second')
  ) {
    return
  }
  // Check already existing games
  const duplicate = await mysql.query(
    'SELECT `id` FROM `games` WHERE `game_id`= ?',
    [data.id]
  )
  if (duplicate &amp;amp;&amp;amp; Array.isArray(duplicate) &amp;amp;&amp;amp; duplicate.length &amp;gt; 0) {
    return
  }
  // Add game to database
  await mysql.query(
    'INSERT INTO `games`(`game_id`, `player1`, `starting_player`, `status`) VALUES (?, ?, ?, ?)',
    [data.id, user, data.starting_player, 'waiting']
  )
}
```
***
`requestJoin`
```
const requestJoin = async (data, user) =&amp;gt; {
  if (!data || !data.id || !data.id.length !== 20) {
    return
  }
  // Check game id in database
  const game = await mysql.query(
    'SELECT `player1` FROM `games` WHERE `game_id`= ? AND `status`= ?',
    [data.id, 'waiting']
  )
  if (!game || !Array.isArray(game) || game.length &amp;lt; 1) {
    return
  }
  // Players can not play with themselves
  if (game[0].player1 === user) {
    return
  }
  // Check already open requests
  const requests = await mysql.query(
    'SELECT `id` FROM `requests` WHERE `game_id`= ? AND (`player`= ? OR `status`= ?)',
    [data.id, user, 'accepted']
  )
  if (requests &amp;amp;&amp;amp; Array.isArray(requests) &amp;amp;&amp;amp; requests.length &amp;gt; 0) {
    return
  }
  // Request join game
  await mysql.query(
    'INSERT INTO `requests`(`game_id`, `player`, `status`) VALUES (?, ?, ?)',
    [data.id, user, 'waiting']
  )
}
```
***
`acceptRequest`
```
const acceptRequest = async (data, user) =&amp;gt; {
  if (!data || !data.id || !data.player || !data.id.length !== 20) {
    return
  }
  // Validate game in database
  const game = await mysql.query(
    'SELECT `player1` FROM `games` WHERE `game_id`= ? AND `status`= ?',
    [data.id, 'waiting']
  )
  if (!game || !Array.isArray(game) || game.length &amp;lt; 1) {
    return
  }
  const requests = await mysql.query(
    'SELECT `id` FROM `requests` WHERE `game_id`= ? AND `player`= ? AND `status`= ?',
    [data.id, data.player, 'waiting']
  )
  if (!requests || !Array.isArray(requests) || requests.length &amp;lt; 1) {
    return
  }
  // Accept the join request and update game status
  await mysql.query(
    'UPDATE `games` SET `player2`=?,`status`=? WHERE `game_id`=?',
    [data.player, 'running', data.id]
  )
  await mysql.query(
    'UPDATE `requests` SET `status`=? WHERE `game_id`=? AND `player`=?',
    ['accepted', data.id, data.player]
  )
}
```
***
Some updates to `processData`:
```
const processData = (jsonData, postingAuths) =&amp;gt; {
  try {
    if (!jsonData) {
      return
    }
    const data = JSON.parse(jsonData)
    if (!data || !data.action || !data.app) {
      return
    }
    if (
      !postingAuths ||
      !Array.isArray(postingAuths) ||
      postingAuths.length &amp;lt; 1
    ) {
      return
    }
    const user = postingAuths[0]
    if (data.action === 'create_game') {
      createGame(data, user)
    } else if (data.action === 'request_join') {
      requestJoin(data, user)
    } else if (data.action === 'accept_request') {
      acceptRequest(data, user)
    } else if (data.action === 'play') {
      play(data, user)
    }
  } catch (e) {
    // error might be on JSON.parse and wrong json format
    return null
  }
}
```
And streaming function:
```
try {
  stream.streamBlockOperations((ops) =&amp;gt; {
    if (ops) {
      const op = ops[0]
      if (op &amp;amp;&amp;amp; op[0] === 'custom_json' &amp;amp;&amp;amp; op[1].id === 'tictactoe') {
        processData(op[1].json, op[1].required_posting_auths)
      }
    }
  })
} catch (e) {
  throw new Error(e)
}
```
***
I think it's enough for this part. Let's finish before I sleep on the keyboard.

We set up the MySQL server and made a script to create 3 tables. Our back-end is now processing data into the database and 3 main functions are working as expected. Creating a game, Requesting to join a game, and accepting the requests.

We have to create the front-end for these functions in the next part. I think the hard part is going to be the `play` function which holds the game rules.

Upvote if you like and leave a comment. Make sure to follow me and share the post.

Thanks for reading.
***
[GitLab](https://gitlab.com/mahdiyari/decentralized-game-on-hive)
[Part1](https://hive.blog/hive-139531/@mahdiyari/making-a-decentralized-game-on-hive-tic-tac-toe-part-1)
[Part2](https://hive.blog/hive-139531/@mahdiyari/making-a-decentralized-game-on-hive-part-2)
***
**Vote for my witness:**
- https://wallet.hive.blog/~witnesses
- https://peakd.com/witnesses
- https://ecency.com/witnesses&lt;/div&gt;
&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;

&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@mahdiyari&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/making-a-decentralized-game-on-hive-part-3&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-mahdiyari-making-a-decentralized-game-on-hive-part-3').html();
      const outputElem = $('#content-mahdiyari-making-a-decentralized-game-on-hive-part-3');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;

&lt;style&gt;
  #content-mahdiyari-making-a-decentralized-game-on-hive-part-3 {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-part-3 code {
    background: white;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-part-3 a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-part-3 a:hover {
    border-bottom: 0;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-part-3 h1 {
    font-size: 2.2em;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-part-3 h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-part-3 header small {
    color: #999;
    font-size: 50%;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-part-3 img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;

&lt;p&gt;
  See: &lt;a href=&quot;https://hive.blog/hive-139531/@mahdiyari/making-a-decentralized-game-on-hive-part-3&quot;&gt;Making a Decentralized Game on Hive - Part 3&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@mahdiyari&quot;&gt;@mahdiyari&lt;/a&gt;
&lt;/p&gt;</content><author><name>mahdiyari</name></author><category term="howto" /><category term="nodejs" /><summary type="html">![coding-1853305_1280.jpg](https://images.hive.blog/DQmeBMvQ9RAne3j2qH1RrtDaWEyQ2bZo81ik3wsNXYGbp3E/coding-1853305_1280.jpg) This part took a little longer because it was actually time-consuming (also I took a little break). The process is getting harder so it might take a few days longer than expected for the coming parts but I will do my best. In the previous parts, we made a simple front-end with login functionality and initialized our API and back-end application with streaming. ([Part1](https://hive.blog/hive-139531/@mahdiyari/making-a-decentralized-game-on-hive-tic-tac-toe-part-1) and [Part2](https://hive.blog/hive-139531/@mahdiyari/making-a-decentralized-game-on-hive-part-2)) ## MySQL Setup You can use apps like [AMPPS](https://www.ampps.com/) which comes with MySQL and other tools like PHPMyAdmin (one of the best MySQL management apps) or install MySQL directly. I have AMMPS on windows and use MySQL docker on Linux. MySQL docker installation: ``` docker pull mysql/mysql-server:latest ``` I create a folder `/root/mysql-docker1` and put the MySQL config file there `my.cnf` and another folder `data` for holding the database files. Running on port `127.0.0.1:3306`: ``` docker run --name=mysql1 \ --mount type=bind,src=/root/mysql-docker1/my.cnf,dst=/etc/my.cnf \ --mount type=bind,src=/root/mysql-docker1/data,dst=/var/lib/mysql \ -p 127.0.0.1:3306:3306 -d mysql/mysql-server:latest ``` There are different ways to tune your MySQL server based on your hardware which I'm not going to talk about. The following config is for medium-range hardware (32GB ram). `my.cnf`: ``` [mysqld] skip_name_resolve user=mysql default_authentication_plugin = mysql_native_password symbolic-links=0 character_set_server=utf8mb4 collation_server=utf8mb4_general_ci innodb_max_dirty_pages_pct = 90 innodb_max_dirty_pages_pct_lwm = 10 innodb_flush_neighbors = 0 innodb_undo_log_truncate=off max_connect_errors = 1000000 # InnoDB Settings innodb_file_per_table innodb_log_files_in_group = 2 innodb_open_files = 4000 default_storage_engine = InnoDB innodb_buffer_pool_instances = 8 # Use 1 instance per 1GB of InnoDB pool size innodb_buffer_pool_size = 16G # Use up to 70-80% of RAM innodb_flush_method = O_DIRECT_NO_FSYNC innodb_log_buffer_size = 64M innodb_log_file_size = 10G innodb_stats_on_metadata = 0 # tune innodb_doublewrite= 1 innodb_thread_concurrency = 0 innodb_flush_log_at_trx_commit = 0 innodb_lru_scan_depth = 2048 innodb_page_cleaners = 4 join_buffer_size = 256K sort_buffer_size = 256K innodb_use_native_aio = 1 innodb_stats_persistent = 1 innodb_adaptive_flushing = 1 innodb_read_io_threads = 16 innodb_write_io_threads = 16 innodb_io_capacity = 1500 innodb_io_capacity_max = 2500 innodb_purge_threads = 4 innodb_adaptive_hash_index = 0 max_prepared_stmt_count = 1000000 innodb_monitor_enable = '%' performance_schema = ON key_buffer_size = 512M # Connection Settings max_connections = 2000 # UPD back_log = 3000 interactive_timeout = 180 wait_timeout = 10 table_open_cache = 200000 # UPD table_open_cache_instances = 64 open_files_limit = 100000 # UPD ``` Note: restart MySQL server after updating the`my.cnf` file. MySQL password on AMMPS is `mysql` and on docker setup, I think you get the password from `docker logs mysql1`. Anyway, there are many documentations about MySQL already on the internet. Create a database `tictactoe`. It's easier with tools like PHPMyAdmin if you are using AMPPS. Or try HeidiSQL. Here is the SQL command for creating the database: ``` CREATE DATABASE `tictactoe`; ``` *** ## Development Let's create a config file for holding MySQL login information for our app. I will put this file as `config.example.js` in repository and you have to rename it manually. `config.js`: ``` const config = { dbName: 'tictactoe', dbUser: 'root', dbPassword: 'password', dbHost: '127.0.0.1', dbPort: 3306 } module.exports = config ``` *** I have a personal code for MySQL connection pooling. It simply makes a custom async function just like the original connect function of [mysqljs](https://github.com/mysqljs/mysql) library but for pooling connections. `helpers/mysql.js`: ``` const mysql = require('mysql') const config = require('../config') const pool = mysql.createPool({ connectionLimit: 5, host: config.dbHost, port: config.dbPort, user: config.dbUser, password: config.dbPassword, database: config.dbName, charset: 'utf8mb4' }) // Rewriting MySQL query method as a promise const con = {} con.query = async (query, val) =&amp;gt; { if (val) { const qu = await new Promise((resolve, reject) =&amp;gt; { pool.query(query, val, (error, results) =&amp;gt; { if (error) reject(new Error(error)) resolve(results) }) }) return qu } else { const qu = await new Promise((resolve, reject) =&amp;gt; { pool.query(query, (error, results) =&amp;gt; { if (error) reject(new Error(error)) resolve(results) }) }) return qu } } module.exports = con ``` It creates a pool of 5 connections which is more than enough for our game. And of course: ``` npm install mysql ``` *** #### Initializing database We make a function to create necessary tables if they don't exist already. `helpers/initDatabase.js`: ``` const mysql = require('./mysql') /** * id, game_id, player1, player2, starting_player, status, winner */ const tableGames = 'CREATE TABLE IF NOT EXISTS `tictactoe`.`games` ( `id` INT NOT NULL AUTO_INCREMENT , ' + '`game_id` TINYTEXT NOT NULL , ' + '`player1` TINYTEXT NOT NULL , `player2` TINYTEXT NULL DEFAULT NULL , ' + '`starting_player` TINYTEXT NOT NULL , `status` TINYTEXT NULL , ' + '`winner` TINYTEXT NULL DEFAULT NULL , PRIMARY KEY (`id`)) ' + 'ENGINE = InnoDB CHARSET=utf8mb4 COLLATE utf8mb4_general_ci;' /** * id, game_id, player, col, row */ const tableMoves = 'CREATE TABLE IF NOT EXISTS `tictactoe`.`moves` ( `id` INT NOT NULL AUTO_INCREMENT , ' + '`game_id` TINYTEXT NOT NULL , `player` TINYTEXT NOT NULL , ' + '`col` INT(1) NOT NULL , `row` INT(1) NOT NULL , ' + 'PRIMARY KEY (`id`)) ENGINE = InnoDB CHARSET=utf8mb4 COLLATE utf8mb4_general_ci;' const tableRquests = 'CREATE TABLE IF NOT EXISTS `tictactoe`.`requests` ( `id` INT NOT NULL AUTO_INCREMENT , ' + '`game_id` TINYTEXT NOT NULL , `player` TINYTEXT NOT NULL , `status` TINYTEXT NOT NULL , ' + 'PRIMARY KEY (`id`)) ENGINE = InnoDB CHARSET=utf8mb4 COLLATE utf8mb4_general_ci;' const initDatabase = async () =&amp;gt; { await mysql.query(tableGames) await mysql.query(tableMoves) await mysql.query(tableRquests) } module.exports = initDatabase ``` #### Created tables `games` ![tablesqlgames.png](https://images.hive.blog/DQmVCMyNZax6xd6kCc2VZijGjMa9Qbt8Myeev7jF8KmcqXe/image.png) `moves` ![tablesqlmoves.png](https://images.hive.blog/DQmVwyDZg1N3KEteDgfA5NdMHeUkjpngHZEmizBXxhh3XPs/image.png) `requests` ![image.png](https://images.hive.blog/DQmQLxfwKEfWSQ614vWb6qfUNVMSyiFgnKEh5nSWcKYFQQv/image.png) *** #### Updating main application Now we can complete the game methods in `index.js`: `createGame` ``` const createGame = async (data, user) =&amp;gt; { if (!data || !data.id || !data.starting_player) { return } // validating if ( data.id.length !== 20 || (data.starting_player !== 'first' &amp;amp;&amp;amp; data.starting_player !== 'second') ) { return } // Check already existing games const duplicate = await mysql.query( 'SELECT `id` FROM `games` WHERE `game_id`= ?', [data.id] ) if (duplicate &amp;amp;&amp;amp; Array.isArray(duplicate) &amp;amp;&amp;amp; duplicate.length &amp;gt; 0) { return } // Add game to database await mysql.query( 'INSERT INTO `games`(`game_id`, `player1`, `starting_player`, `status`) VALUES (?, ?, ?, ?)', [data.id, user, data.starting_player, 'waiting'] ) } ``` *** `requestJoin` ``` const requestJoin = async (data, user) =&amp;gt; { if (!data || !data.id || !data.id.length !== 20) { return } // Check game id in database const game = await mysql.query( 'SELECT `player1` FROM `games` WHERE `game_id`= ? AND `status`= ?', [data.id, 'waiting'] ) if (!game || !Array.isArray(game) || game.length &amp;lt; 1) { return } // Players can not play with themselves if (game[0].player1 === user) { return } // Check already open requests const requests = await mysql.query( 'SELECT `id` FROM `requests` WHERE `game_id`= ? AND (`player`= ? OR `status`= ?)', [data.id, user, 'accepted'] ) if (requests &amp;amp;&amp;amp; Array.isArray(requests) &amp;amp;&amp;amp; requests.length &amp;gt; 0) { return } // Request join game await mysql.query( 'INSERT INTO `requests`(`game_id`, `player`, `status`) VALUES (?, ?, ?)', [data.id, user, 'waiting'] ) } ``` *** `acceptRequest` ``` const acceptRequest = async (data, user) =&amp;gt; { if (!data || !data.id || !data.player || !data.id.length !== 20) { return } // Validate game in database const game = await mysql.query( 'SELECT `player1` FROM `games` WHERE `game_id`= ? AND `status`= ?', [data.id, 'waiting'] ) if (!game || !Array.isArray(game) || game.length &amp;lt; 1) { return } const requests = await mysql.query( 'SELECT `id` FROM `requests` WHERE `game_id`= ? AND `player`= ? AND `status`= ?', [data.id, data.player, 'waiting'] ) if (!requests || !Array.isArray(requests) || requests.length &amp;lt; 1) { return } // Accept the join request and update game status await mysql.query( 'UPDATE `games` SET `player2`=?,`status`=? WHERE `game_id`=?', [data.player, 'running', data.id] ) await mysql.query( 'UPDATE `requests` SET `status`=? WHERE `game_id`=? AND `player`=?', ['accepted', data.id, data.player] ) } ``` *** Some updates to `processData`: ``` const processData = (jsonData, postingAuths) =&amp;gt; { try { if (!jsonData) { return } const data = JSON.parse(jsonData) if (!data || !data.action || !data.app) { return } if ( !postingAuths || !Array.isArray(postingAuths) || postingAuths.length &amp;lt; 1 ) { return } const user = postingAuths[0] if (data.action === 'create_game') { createGame(data, user) } else if (data.action === 'request_join') { requestJoin(data, user) } else if (data.action === 'accept_request') { acceptRequest(data, user) } else if (data.action === 'play') { play(data, user) } } catch (e) { // error might be on JSON.parse and wrong json format return null } } ``` And streaming function: ``` try { stream.streamBlockOperations((ops) =&amp;gt; { if (ops) { const op = ops[0] if (op &amp;amp;&amp;amp; op[0] === 'custom_json' &amp;amp;&amp;amp; op[1].id === 'tictactoe') { processData(op[1].json, op[1].required_posting_auths) } } }) } catch (e) { throw new Error(e) } ``` *** I think it's enough for this part. Let's finish before I sleep on the keyboard. We set up the MySQL server and made a script to create 3 tables. Our back-end is now processing data into the database and 3 main functions are working as expected. Creating a game, Requesting to join a game, and accepting the requests. We have to create the front-end for these functions in the next part. I think the hard part is going to be the `play` function which holds the game rules. Upvote if you like and leave a comment. Make sure to follow me and share the post. Thanks for reading. *** [GitLab](https://gitlab.com/mahdiyari/decentralized-game-on-hive) [Part1](https://hive.blog/hive-139531/@mahdiyari/making-a-decentralized-game-on-hive-tic-tac-toe-part-1) [Part2](https://hive.blog/hive-139531/@mahdiyari/making-a-decentralized-game-on-hive-part-2) *** **Vote for my witness:** - https://wallet.hive.blog/~witnesses - https://peakd.com/witnesses - https://ecency.com/witnesses See: Making a Decentralized Game on Hive - Part 3 by @mahdiyari</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://images.hive.blog/DQmeBMvQ9RAne3j2qH1RrtDaWEyQ2bZo81ik3wsNXYGbp3E/coding-1853305_1280.jpg" /><media:content medium="image" url="https://images.hive.blog/DQmeBMvQ9RAne3j2qH1RrtDaWEyQ2bZo81ik3wsNXYGbp3E/coding-1853305_1280.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Using Hive Blockchain Custom Json Operation with Python &amp;amp; Beem</title><link href="https://hivedocs.info/howto/beem/python/custom_json/2021/03/22/using-hive-blockchain-custom-json-operation-with-python-and-beem.html" rel="alternate" type="text/html" title="Using Hive Blockchain Custom Json Operation with Python &amp;amp; Beem" /><published>2021-03-22T20:43:24-07:00</published><updated>2021-03-22T20:43:24-07:00</updated><id>https://hivedocs.info/howto/beem/python/custom_json/2021/03/22/using-hive-blockchain-custom-json-operation-with-python-and-beem</id><content type="html" xml:base="https://hivedocs.info/howto/beem/python/custom_json/2021/03/22/using-hive-blockchain-custom-json-operation-with-python-and-beem.html">&lt;div id=&quot;content-geekgirl-using-hive-blockchain-custom-json-operation-with-python-and-beem&quot;&gt;
&lt;center&gt;![hivewp20.png](https://images.hive.blog/DQmcXEvn33Sph3AMpajUr46mCxbM4GZFKYupgof5aaHQnZQ/hivewp20.png)Image by @doze&lt;/center&gt;

One of Hive blockchain's powerful features is its custom_json operation. Normally, users don't even see and hear about this operations. However, this operation enables developers to store their game or web application data on the Hive blockchain. If you would like to know more about what is stored in Hive blocks and and curious about various Hive operations, feel free to read my [Exploring Hive Blocks](https://leofinance.io/@geekgirl/exploring-hive-blocks) post.

In this post I would like to share how to broadcast custom_json operations to Hive blockchain, how to retrieve them afterwards using Beem module in Python. Beem is a python module created by @holger80, and makes is easy to connect to Hive blockchain and interact with it using python programming language.

Custom_json is one of many operations of Hive. It allow developers to store game or applications data on Hive blockchain. Data is stored as text in Json format. Sine Json is a native JavaScript format and widely used in website and web applications, Hive makes it super easy to create Apps and Games that would like to use decentralized solutions.

&lt;center&gt;**Broadcasting a Transaction to Hive Blockchain**&lt;/center&gt;

Every Hive block has a size limit of 65536 bytes. Which means we can only store 65536 characters including all the properties in one block. I believe this is a parameters that witnesses can change if they wish to based on demand, infrastructure, scaling, etc. For now and foreseeable future this is the limitation every developer of apps and games should consider.

Another limitation is each custom_json operation is limited to 8192 bytes or characters. However, it is possible to broadcast multiple operations within a transaction. We face another limitation there. We can only broadcast 5 operations within a transaction by the broadcasting account. 

Before we get to the code, another thing to keep in mind is, once transaction is built and we broadcast it, the return value doesn't not give the block number where the transaction is stored. That is because when we broadcast with python we don't wait until the block is produced. A couple minutes after broadcasting the transaction the block is produced and available for us to retrieve the data stored. When we broadcast we get back values like `expiration`, `ref_block_num` and `ref_block_prefix`. Using these three values we can find our transaction and the block it is stored in. So that we don't search the entire blockchain form the beginning, I also decided to store the current block number before broadcasting. That way I can start searching for the transaction starting from that block number.

Following is the code to broadcast custom_json operations:

```
from beem.transactionbuilder import TransactionBuilder
from beembase.operations import Custom_json
from beem import Hive
from beem.blockchain import Blockchain 
from beem.block import Block
from helper import wif, name 
from beem.nodelist import NodeList
from pprint import pprint

nodelist = NodeList()
nodelist.update_nodes()
nodes = nodelist.get_hive_nodes()

hive = Hive(node=nodes, nobroadcast=False, keys={'posting': wif})
blockchain = Blockchain(hive)
current_block_num = blockchain.get_current_block_num()

tx = TransactionBuilder(blockchain_instance=hive)

for i in range(1,6):
  txt = str(i) * 8100
  data = {}
  data['data'] = txt
  cj = {
      &quot;required_auths&quot;: [],
      &quot;required_posting_auths&quot;: [name],
      &quot;id&quot;: &quot;librarian&quot;,
      &quot;json&quot;: data
    }
  tx.appendOps(Custom_json(cj))

tx.appendWif(wif)
signed_tx = tx.sign()
broadcast_tx = tx.broadcast()

print(current_block_num)
print(broadcast_tx)
```

Main thing to pay attention to is the TransactionBuilder. It allows us to build a transaction before broadcasting then broadcast it. I stored Hive account name and keys in a separate python file named helper.py, and imported variables name and wif to sign the transaction. To broadcast a this transaction posting key was enough.

We can add upto 5 operations in our transaction using .appendOps() method. Everything else should be self-explanatory. Feel free to ask in the comments if something doesn't make sense. I will be happy to explain each line.

Now the last two print statements show the block number before the transaction was broadcasted, and return values after the broadcast happened. 

Now we need to retrieve the data from Hive. We will use the printed or stored block number to start the search from and values returned when we broadcasted the transactions such as `expiration`,  `ref_block_num`, and `ref_block_prefix`. 

```
from beem import Hive
from beem.block import Block
from pprint import pprint
from beem.blockchain import Blockchain
from beem.nodelist import NodeList

nodelist = NodeList()
nodelist.update_nodes()
nodes = nodelist.get_hive_nodes()
hive = Hive(node=nodes)

start_block_num = 52374262
blockchain = Blockchain(hive)
end_block_num = blockchain.get_current_block_num()

exp = '2021-03-23T02:08:41'
rbn = 10998
rbp = 3231133325

def get_data(start, end, exp, rbn, rbp):
    ref = []
    for num in range(start, end):
        block = Block(block=num, blockchain_instance=hive)
        b = block.json()
        for i, tr in enumerate(b['transactions']):
            if tr['expiration'] == exp and tr['ref_block_num'] == rbn and tr['ref_block_prefix'] == rbp:
                print(i)
                print(b['id'])
                print(b['timestamp'])
                print(tr['operations'])
                print(b['transaction_ids'][i])
                ref.append(b['id'])
                ref.append(i)
                return ref

ref = get_data(start_block_num, end_block_num, exp, rbn, rbp)

print('-----')
print(ref)
bb = Block(block=ref[0])
bb = bb.json()
bb = bb['transactions'][ref[1]]
bb = bb['operations'][0]['value']['json']

print(bb)

```

What the code above does is, it searches for the stored transaction with custom_json operations starting with the nearest known block numbers. Once found it displays the data we are searching for. It also provides the block number the transaction is stored at. 

Now, we want to store this block number as reference for future use. Next time we need the same data, we can just get the block from the blockchain instead of iterating through multiple blocks and save us time.

If we have the block number, then we can easily get everything stored in that block as following:

```
block_num = 52374284

block = Block(block=block_num, blockchain_instance=hive)
b = block.json()

pprint(b)
```

One last thing I would like to share has to do with resource credits. I used an account with 1006 HP to test the codes above. The transaction above had 5 operations with 8100 characters each in size. It only took less than 1% of resource credits for this account to broadcast the transaction.

I hope you find this post useful. Let me know your thoughts. Also, let me know if there are better ways of broadcasting transactions and retrieving data from Hive blockchain using python.


Posted Using [LeoFinance &lt;sup&gt;Beta&lt;/sup&gt;](https://leofinance.io/@geekgirl/using-hive-blockchain-custom-json-operation-with-python-and-beem)&lt;/div&gt;
&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;

&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@geekgirl&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/using-hive-blockchain-custom-json-operation-with-python-and-beem&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-geekgirl-using-hive-blockchain-custom-json-operation-with-python-and-beem').html();
      const outputElem = $('#content-geekgirl-using-hive-blockchain-custom-json-operation-with-python-and-beem');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;

&lt;style&gt;
  #content-geekgirl-using-hive-blockchain-custom-json-operation-with-python-and-beem {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-geekgirl-using-hive-blockchain-custom-json-operation-with-python-and-beem code {
    background: white;
  }
  #content-geekgirl-using-hive-blockchain-custom-json-operation-with-python-and-beem a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-geekgirl-using-hive-blockchain-custom-json-operation-with-python-and-beem a:hover {
    border-bottom: 0;
  }
  #content-geekgirl-using-hive-blockchain-custom-json-operation-with-python-and-beem h1 {
    font-size: 2.2em;
  }
  #content-geekgirl-using-hive-blockchain-custom-json-operation-with-python-and-beem h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-geekgirl-using-hive-blockchain-custom-json-operation-with-python-and-beem header small {
    color: #999;
    font-size: 50%;
  }
  #content-geekgirl-using-hive-blockchain-custom-json-operation-with-python-and-beem img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;

&lt;p&gt;
  See: &lt;a href=&quot;https://leofinance.io/@geekgirl/using-hive-blockchain-custom-json-operation-with-python-and-beem&quot;&gt;Using Hive Blockchain Custom Json Operation with Python &amp;amp; Beem&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@geekgirl&quot;&gt;@geekgirl&lt;/a&gt;
&lt;/p&gt;</content><author><name>geekgirl</name></author><category term="howto" /><category term="beem" /><category term="python" /><category term="custom_json" /><summary type="html">![hivewp20.png](https://images.hive.blog/DQmcXEvn33Sph3AMpajUr46mCxbM4GZFKYupgof5aaHQnZQ/hivewp20.png)Image by @doze One of Hive blockchain's powerful features is its custom_json operation. Normally, users don't even see and hear about this operations. However, this operation enables developers to store their game or web application data on the Hive blockchain. If you would like to know more about what is stored in Hive blocks and and curious about various Hive operations, feel free to read my [Exploring Hive Blocks](https://leofinance.io/@geekgirl/exploring-hive-blocks) post. In this post I would like to share how to broadcast custom_json operations to Hive blockchain, how to retrieve them afterwards using Beem module in Python. Beem is a python module created by @holger80, and makes is easy to connect to Hive blockchain and interact with it using python programming language. Custom_json is one of many operations of Hive. It allow developers to store game or applications data on Hive blockchain. Data is stored as text in Json format. Sine Json is a native JavaScript format and widely used in website and web applications, Hive makes it super easy to create Apps and Games that would like to use decentralized solutions. **Broadcasting a Transaction to Hive Blockchain** Every Hive block has a size limit of 65536 bytes. Which means we can only store 65536 characters including all the properties in one block. I believe this is a parameters that witnesses can change if they wish to based on demand, infrastructure, scaling, etc. For now and foreseeable future this is the limitation every developer of apps and games should consider. Another limitation is each custom_json operation is limited to 8192 bytes or characters. However, it is possible to broadcast multiple operations within a transaction. We face another limitation there. We can only broadcast 5 operations within a transaction by the broadcasting account. Before we get to the code, another thing to keep in mind is, once transaction is built and we broadcast it, the return value doesn't not give the block number where the transaction is stored. That is because when we broadcast with python we don't wait until the block is produced. A couple minutes after broadcasting the transaction the block is produced and available for us to retrieve the data stored. When we broadcast we get back values like `expiration`, `ref_block_num` and `ref_block_prefix`. Using these three values we can find our transaction and the block it is stored in. So that we don't search the entire blockchain form the beginning, I also decided to store the current block number before broadcasting. That way I can start searching for the transaction starting from that block number. Following is the code to broadcast custom_json operations: ``` from beem.transactionbuilder import TransactionBuilder from beembase.operations import Custom_json from beem import Hive from beem.blockchain import Blockchain from beem.block import Block from helper import wif, name from beem.nodelist import NodeList from pprint import pprint nodelist = NodeList() nodelist.update_nodes() nodes = nodelist.get_hive_nodes() hive = Hive(node=nodes, nobroadcast=False, keys={'posting': wif}) blockchain = Blockchain(hive) current_block_num = blockchain.get_current_block_num() tx = TransactionBuilder(blockchain_instance=hive) for i in range(1,6): txt = str(i) * 8100 data = {} data['data'] = txt cj = { &quot;required_auths&quot;: [], &quot;required_posting_auths&quot;: [name], &quot;id&quot;: &quot;librarian&quot;, &quot;json&quot;: data } tx.appendOps(Custom_json(cj)) tx.appendWif(wif) signed_tx = tx.sign() broadcast_tx = tx.broadcast() print(current_block_num) print(broadcast_tx) ``` Main thing to pay attention to is the TransactionBuilder. It allows us to build a transaction before broadcasting then broadcast it. I stored Hive account name and keys in a separate python file named helper.py, and imported variables name and wif to sign the transaction. To broadcast a this transaction posting key was enough. We can add upto 5 operations in our transaction using .appendOps() method. Everything else should be self-explanatory. Feel free to ask in the comments if something doesn't make sense. I will be happy to explain each line. Now the last two print statements show the block number before the transaction was broadcasted, and return values after the broadcast happened. Now we need to retrieve the data from Hive. We will use the printed or stored block number to start the search from and values returned when we broadcasted the transactions such as `expiration`, `ref_block_num`, and `ref_block_prefix`. ``` from beem import Hive from beem.block import Block from pprint import pprint from beem.blockchain import Blockchain from beem.nodelist import NodeList nodelist = NodeList() nodelist.update_nodes() nodes = nodelist.get_hive_nodes() hive = Hive(node=nodes) start_block_num = 52374262 blockchain = Blockchain(hive) end_block_num = blockchain.get_current_block_num() exp = '2021-03-23T02:08:41' rbn = 10998 rbp = 3231133325 def get_data(start, end, exp, rbn, rbp): ref = [] for num in range(start, end): block = Block(block=num, blockchain_instance=hive) b = block.json() for i, tr in enumerate(b['transactions']): if tr['expiration'] == exp and tr['ref_block_num'] == rbn and tr['ref_block_prefix'] == rbp: print(i) print(b['id']) print(b['timestamp']) print(tr['operations']) print(b['transaction_ids'][i]) ref.append(b['id']) ref.append(i) return ref ref = get_data(start_block_num, end_block_num, exp, rbn, rbp) print('-----') print(ref) bb = Block(block=ref[0]) bb = bb.json() bb = bb['transactions'][ref[1]] bb = bb['operations'][0]['value']['json'] print(bb) ``` What the code above does is, it searches for the stored transaction with custom_json operations starting with the nearest known block numbers. Once found it displays the data we are searching for. It also provides the block number the transaction is stored at. Now, we want to store this block number as reference for future use. Next time we need the same data, we can just get the block from the blockchain instead of iterating through multiple blocks and save us time. If we have the block number, then we can easily get everything stored in that block as following: ``` block_num = 52374284 block = Block(block=block_num, blockchain_instance=hive) b = block.json() pprint(b) ``` One last thing I would like to share has to do with resource credits. I used an account with 1006 HP to test the codes above. The transaction above had 5 operations with 8100 characters each in size. It only took less than 1% of resource credits for this account to broadcast the transaction. I hope you find this post useful. Let me know your thoughts. Also, let me know if there are better ways of broadcasting transactions and retrieving data from Hive blockchain using python. Posted Using [LeoFinance Beta](https://leofinance.io/@geekgirl/using-hive-blockchain-custom-json-operation-with-python-and-beem) See: Using Hive Blockchain Custom Json Operation with Python &amp;amp; Beem by @geekgirl</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://images.hive.blog/DQmcXEvn33Sph3AMpajUr46mCxbM4GZFKYupgof5aaHQnZQ/hivewp20.png" /><media:content medium="image" url="https://images.hive.blog/DQmcXEvn33Sph3AMpajUr46mCxbM4GZFKYupgof5aaHQnZQ/hivewp20.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Phishing on Hive? No more. Solution for all Frontends.</title><link href="https://hivedocs.info/news/devops/security/2021/03/17/phishing-on-hive-no-more-solution-for-all-frontends.html" rel="alternate" type="text/html" title="Phishing on Hive? No more. Solution for all Frontends." /><published>2021-03-17T00:06:09-07:00</published><updated>2021-03-17T00:06:09-07:00</updated><id>https://hivedocs.info/news/devops/security/2021/03/17/phishing-on-hive-no-more-solution-for-all-frontends</id><content type="html" xml:base="https://hivedocs.info/news/devops/security/2021/03/17/phishing-on-hive-no-more-solution-for-all-frontends.html">&lt;div id=&quot;content-keys-defender-phishing-on-hive-no-more-solution-for-all-frontends&quot;&gt;&lt;center&gt;
&lt;div&gt;
&lt;h4&gt;One &amp;nbsp; &lt;i&gt;script&lt;/i&gt; &amp;nbsp; to rule them all..&lt;/h4&gt;

https://files.peakd.com/file/peakd-hive/keys-defender/23uEx3ge6ahMEAqbNu2KxP3EvamdsBroMaGSYrkDRPsGUHc7sjst6GKUUPo7MoFq9YGo6.png
&lt;/div&gt;
&lt;/center&gt;

-----

&lt;h5&gt;Problem:&lt;/h5&gt;
In the past few weeks Hive has been plagued by &lt;u&gt;phishing campaigns&lt;/u&gt; and some users lost access to their account or lost their funds. This is nothing new and has been going on for years on ~~Steem~~ and Hive.

&lt;div class=&quot;pull-right&quot;&gt; https://files.peakd.com/file/peakd-hive/keys-defender/23ynfLMyQ7Cub6dZ3Dkgy3ibKnFc8DCeGkhiMRJjhBRtEVFTGBzSfAF8SxegpyrQM4eg4.png&lt;/div&gt;

To make things worse, registrars are not quick enough to take down phishing domains..

&lt;br /&gt;&lt;div class=&quot;pull-right&quot;&gt;&lt;div class=&quot;pull-left&quot;&gt;
https://files.peakd.com/file/peakd-hive/keys-defender/243MPzTbbyDU6fHr6SnsBBTJ3VSMBJk9KgL2At8pnztriEQmsYMWGAMwgEApYdzvTfB5e.png
&lt;/div&gt;&lt;sub&gt;&lt;sub&gt;&lt;a href=&quot;&quot;&gt;src&lt;/a&gt;&lt;/sub&gt;&lt;/sub&gt;&lt;/div&gt;

&lt;br /&gt;It is time that the Hive community tries to mitigate this issue on their own.

&lt;br /&gt;&lt;h5&gt;Potential solution:&lt;/h5&gt;Use a &lt;u&gt;plug-and-play universal script&lt;/u&gt; (or a modified copy of it) that all Hive frontends can integrate to block phishing links in a timely matter. As soon as a phishing campaign starts on Hive and the attacker's domain is spotted and added to a blacklist API (eg. @spaminator's), the universal script would immediately block the attack in all Hive frontends and at the same time leave the User Experience unaffected.

&lt;u&gt;As a matter of fact, this is what I worked on in the past few days.&lt;/u&gt;

- Here is the universal script for all Hive frontends: https://github.com/keys-defender/hive/blob/master/scripts/universal-bridge-against-phishing.js
- Here is a &lt;u&gt;demo website&lt;/u&gt; with my script in action: https://keys-defender.github.io/hive

*NOTE* : the demo page will not be sanitized by my universal script until you: 1. Navigate to https://cors-anywhere.herokuapp.com/corsdemo and click on the &quot;Request temporary access&quot; button, 2. refresh the demo website.

&lt;br /&gt;&lt;b&gt;I have proved my universal script working on:&lt;/b&gt; &amp;nbsp; &amp;nbsp; &amp;nbsp;&lt;sub&gt;(see screenshots down below)&lt;/sub&gt;

HIVE.BLOG - https://hive.blog - @blocktrades @quochuy 
PEAKD - https://peakd.com - @asgarth, @jarvie
LEOFINANCE - https://leofinance.io - @khaleelkazi
ECENCY - https://ecency.com - @good-karma
3SPEAK - https://3speak.tv - @theycallmedan, @starkerz
D.BUZZ - https://d.buzz - @chrisrice
STEM social - https://stem.openhive.network - @lemouth
STEM geeks - https://stemgeeks.net - @enforcer48 ?

It would be great if each Hive frontend maintaner could review it and adapt it to their needs (if they need to -- I tested this script in all major Hive frontends already and it did not seem to have unwanted side effects). I highly recommend though that the integration is thoroughly regression tested before it's used in production.

&lt;i&gt;FYI also for:&lt;/i&gt;
AnonRamblings	@emrebeyler, DTube	@heimindanger, Engage	@arcange, Engrave	@engrave, @nicniezgrublem, Hive-db	@jesta, Hive-Engine	@aggroed, Hiveblockexplorer	@penguinpablo, Hiveblocks	@roadscape, HiveEngine	@holger80, Quello	@tobias-g, ...
\+ other project maintaners: @yabapmatt, @stoodkev, @aggroed, @louis88, @mahdiyari, @acidyo, @fbslo, @rishi556.
&lt;sub&gt;(apologies for the mass tag)&lt;/sub&gt;

I believe that blocking phishing campaigns in an unified way in all frontends is possible despite the different tech stacks in use. It does no matter which framework the website maintainer used to develop their website (eg. ReactJS, AngularJS, VueJS, JQuery, vanilla JS, etc). Using JS global overrides it is possible to prevent users from falling victim of phishing.

&lt;br /&gt;

&lt;h5&gt;What does my script do?&lt;/h5&gt;
It uses the native APIs offered by all browsers in order to immediately block phishing links and images in all Hive frontends as soon as they are discovered and published into the blacklist.

- Any known phishing &lt;b&gt;&lt;u&gt;link&lt;/u&gt;&lt;/b&gt; in the UI will be red and strikethrough-ed. Furthermore if you click on a known phishing link you'll see an alert telling you that it's phishing and it won't allow you to navigate to the phishing domain from the Hive frontend.

- Any &lt;b&gt;&lt;u&gt;image&lt;/u&gt;&lt;/b&gt; that is marked as a phishing attempt (eg. an image with some text saying &quot;claim your $ 1000 in tokens at www.justinscam.com&quot;) will not be displayed in any frontend that uses my script (or a variant of it) as soon as its URL is published into the public blacklist.

More details will follow towards the end of the post to list all the native features of the browser that are hardened by my script in order to prevent phishing (ie. iframes, scripts, window open, XHR requests, Fetch api).

&lt;br /&gt;

&lt;h5&gt;Usage:&lt;/h5&gt;
&lt;b&gt;How difficult is it to try out my universal script in your Hive-powered website?&lt;/b&gt;

Integrating this script is very **straightforward**. In order to integrate it, simply add a `&lt;script&gt;` tag to the head section of your *index.html* page. That's it!

Your *index.html* :

```&lt;!DOCTYPE html&gt;
  &lt;head&gt;
    // ADD THIS ONE LINE WITH MY SCRIPT vvv
    &lt;script src=&quot;https://keys-defender.github.io/hive/scripts/universal-bridge-against-phishing.js&quot;&gt; 
    ...
  &lt;/head&gt;
  &lt;body&gt;
    ...
  &lt;/body&gt;
&lt;/html&gt;
```

This should be enough for your tests. Some intial recommendations though:
- Keep an eye on &lt;u&gt;CORS&lt;/u&gt; issues. If a request is failing because of CORS, use https://cors-anywhere.herokuapp.com for your tests (it's already there commented out in my script).
- Update your &lt;u&gt;Content Security Policy&lt;/u&gt; if necessary to allow your website to load my script from Github and to allow the request to @spaminator's api to go through.
- It is highly recommended that you host your own version of this script for your &lt;u&gt;production&lt;/u&gt; website. It is clearly not a good idea to rely on my github as it's a single point of failure. For example, what if my github account gets compromised? If all Hive frontends point to my script they would all be affected!

&lt;br&gt;

-----

&lt;h5&gt;And now.. some proof of this thing working:&lt;/h5&gt;

&lt;b&gt;Overview of protected features on various Hive Frontends&lt;/b&gt;

&lt;div class=&quot;phishy&quot;&gt;- PHISHING LINKS&lt;/div&gt;

&lt;br&gt;[screenshot taken after applying my script to **Leofinance**]

&lt;i&gt;styling applied to known phishing links: red and strike-through&lt;/i&gt;
![image.png](https://files.peakd.com/file/peakd-hive/keys-defender/246b3Cen96nYaVXhEMyFx18VLkF8VXxXeN7ZJYab7A2C88ACatV7ZEKg7MzmmzqSeWpfv.png)

*alert displayed when a known phishing link is clicked:*
![image.png](https://files.peakd.com/file/peakd-hive/keys-defender/246b13s66MSa65fzhbCtVxHMk3GTKBg4ay7gQq6KqyumJ1ZH1jU4RmnHefVT2XhURof7a.png)

&lt;sub&gt;(my comment: https://hive.blog/hive-167922/@keys-defender/re-keys-defender-6byyqg)&lt;/sub&gt;

&lt;br&gt;&lt;b&gt;Other frontends:&lt;/b&gt;

[screenshot taken after applying my script to **3speak**]
![image.png](https://files.peakd.com/file/peakd-hive/keys-defender/23tHbTv6ofWAmyVButa4tHLcpzh4QPypAiRGEGDN4fMmBFeDAj5agD66xUmV5KJSjZEYC.png)

&lt;br&gt;[screenshot taken after applying my script to **d.buzz**]
![image.png](https://files.peakd.com/file/peakd-hive/keys-defender/23u6YyraYptC4ZXLBBE5xdsEepUD5kEZr532zZTKtGJ2TM1zU7Jes14TAZjGtDBDjumsa.png)
&lt;sub&gt;(my post: https://hive.blog/hive-193084/@keys-defender/zy71ydsnp4o1ufhs6j7ksz)&lt;/sub&gt;

&lt;br&gt;[screenshot taken after applying my script to **Stem social**]
![image.png](https://files.peakd.com/file/peakd-hive/keys-defender/23wXL9BoY2G2KKfNWe6yeTzXqpquMtyf2nbr9jBn3VummyooS7xVjAFv8ZnnYnxTGyTjA.png)

&lt;br&gt;[screenshot taken after applying my script to **Stem Geeks**]:
![image.png](https://files.peakd.com/file/peakd-hive/keys-defender/23tHbYLE2fe9m2QhkixXFbvYXvuMJeUu1XrBnBm2vvXkLTeCny5dxZyYDcdw3dhYaVUyS.png) .


&lt;BR&gt;&lt;div class=&quot;phishy&quot;&gt;- IMAGES&lt;/div&gt;
&lt;br&gt;Both &quot;img&quot; tags and direct uploads get correctly sanitized:

[screenshot taken after applying my script to **hive.blog**]
![image.png](https://files.peakd.com/file/peakd-hive/keys-defender/Eo8ZZNvKmzwu5YKRHswUd32AATpnEGBtTPC6tec2W8RCTM5b5ZuPmJmpDBY8S8VaAck.png)

&lt;br&gt;&lt;div class=&quot;phishy&quot;&gt;- SCRIPTS&lt;/div&gt;
&lt;br&gt;Eg. malicious ads - see &lt;a href=&quot;https://hive.blog/steemit/@gaottantacinque/steemit-got-hacked&quot;&gt;this phishing campaign&lt;/a&gt;

[screenshot taken after applying my script to **hive.blog**]
https://files.peakd.com/file/peakd-hive/keys-defender/23sUEimLkGd2bAm2yHiGdP4gmerpj4WKdG5fuP3TQsExSwp4pZisB8KMgR9DrjNaEoNGk.png

&lt;BR&gt;&lt;div class=&quot;phishy&quot;&gt;- FETCH API&lt;/div&gt;

[screenshot taken after applying my script to **Peakd**]
![image.png](https://files.peakd.com/file/peakd-hive/keys-defender/Eo45poYAdQqmYZjVmCBFLJQZjRQbb1Ee76a8qVcG1WG3rkEnbLjSQbMS4ptV2duyeig.png)

&lt;br&gt;&lt;div class=&quot;phishy&quot;&gt;- WINDOW OPEN:&lt;/div&gt;

[screenshot taken after applying my script to **Ecency**]
![image.png](https://files.peakd.com/file/peakd-hive/keys-defender/246axgrsA2empck8RAxDomd7nmeQCV5aREaEw2RtPSnbUSNVa5HkqitF7TwnPMG56xTaU.png)

-----

&lt;br&gt;

&lt;h5&gt;MORE STUFF..&lt;/h5&gt;

&lt;b&gt;Not supported by my universal script:&lt;/b&gt;
- &lt;u&gt;*window.location*&lt;/u&gt; (*window.location.replace(url)* and assignments to *window.location.href*)
The *window.location* object is immutable therefore if you use that approach to open external lilnks, please consider switching to *window.open* so that my script will protect your user base from known phishing domains.

&lt;br&gt;

**Potential improvements:**

- Instead of just using a list of known phishing domains, the blacklist could be restructured to something similar to what I'm currently using for @keys-defender's blacklist (merged with the @spaminator's one).
Instead of just using a list of links, I use an array of objects and each object has the following properties:
-- *&quot;regex&quot;*: used to match a known phishing domain
-- *&quot;fullLink&quot;*: full link to the homepage of the phishing site
-- *&quot;threatType&quot;*: PHISHING or COMPROMISED_DOMAIN. I used the latter in the past when I found a critical vulnerability in a Hive website and only until it got patched. This attribute is also used in @keys-defender auto-[replies to phishing comments](https://hive.blog/hive-193552/@keys-defender/antiphish-keys-defender-bot-1615674771037) to categorize threats.
-- *&quot;infoBlog&quot;*: link to article that warns against the phishing campaing in progress. This is already in @keys-defender auto-replies and if none is provided it defaults to an intro post.
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; If we had multiple blacklists and they all shared this interface (eg. using a &lt;u&gt;swagger&lt;/u&gt; file) it would be easy to merge them and use them to block phishing campaigns in their early stages. The warnings displayed to the users would be more accurate as well.
- Add a warning to all Hive frontends for all &lt;u&gt;comments containing links left by known compromised accounts&lt;/u&gt;. This should be easy to add re-using the global overrides already added in my script and @spaminator's [api dedicated for this purpose](https://spaminator.me/api/bl/hacked.json).
- Display a proper message on the UI instead of just an alert (probably not important, a fancy UX in my opinion is not necessary for this edge case). Hive frontends maintainers can &lt;u&gt;adjust the messaging&lt;/u&gt; as they see fit though. My alerts are more of a Proof of Concept after all.

&lt;br&gt;

**Concerns:**

- &lt;u&gt;Centralization&lt;/u&gt;. Despite being a good start, we should not rely only on [@spaminator's API](@@@). Some potential solutions to this is to allow users to choose which blacklist to use, or fetch multiple blacklists at the same time. Or even have each Hive website maintainer host their own blacklist.

- No &lt;u&gt;load testing&lt;/u&gt; was performed on @spaminator API. If all Hive frontends start using their API it may become an issue. @spaminator team to chim in on this.
The requests from my script are already throttled significantly on the client side and a local cache is used as well.
- Proper server-side &lt;u&gt;caching&lt;/u&gt; on @spaminator API. Eg. *Cache-Control* response header set to 5 mins? Cloudfront (AWS) caching / Varnish / Redis? 
- Scaling. How scalable is @spaminator API? Would they incur in prohibitive &lt;u&gt;cost&lt;/u&gt; if too many requests were to be sent daily? Do they have a defense mechanism in place for &lt;u&gt;DDOS&lt;/u&gt; attacks? This is not a deal breaker since all users will have a cached version of the blacklist, but an attacker could try and take advantage of this for a new phishing campaign.

&lt;br&gt;

**Notes for devs that try my script:**
- To turn OFF verbose &lt;u&gt;logging&lt;/u&gt; and remove the cors-anywhere proxy, set `IS_DEBUG` to false.
- @spaminator's list of blacklisted domains lives at https://spaminator.me/api/p/domains.json. This list of known phishing domains targeting Hive is stored in the &lt;u&gt;localstorage&lt;/u&gt; as well. If the API is down (eg. DDOS-ed) the Frontends will still block known phishing domains.

![image.png](https://files.peakd.com/file/peakd-hive/keys-defender/23t7FQnUT6RM6QZhZk8zrA5A3QNzAsaTq8TvqRBAxMYdYjrW6vaNou1N3DmM6XqBtkA9i.png)

- The list of &lt;u&gt;global overrides&lt;/u&gt; added in my script is: *document.createElement, element.setAttribute and getAttribute, history.pushState, XMLHttpRequestClass, window.fetch, window.open*.
- The DOM &lt;u&gt;elements sanitized&lt;/u&gt; by my script are: *iframe, script, img, a*. Other potential candidates that would be easy to cover: *input, audio, embed, source, track, video, link*.
- When the document is fully rendered all the risky elements (anchors, images, etc) are &lt;u&gt;checked again&lt;/u&gt; if they weren't already. Eg. comments fetched after the page is fully loaded.
- In order to &lt;u&gt;reduce the load&lt;/u&gt; on @spaminator's servers, if the user is idle on a page the API is queried again only every 15 minutes. If the user navigates to a different subpath of a Single Page Application (eg. https://hive.blog) (would not cause a page refresh) the api is queried only if at least 5 mins passed from the last query.
The same applies for non-SPA (eg. Leofinance, Peakd). A new API request to fetch the updated list of domains is sent only if more than 5 minutes passed from the last request.
&lt;sub&gt; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; Example of phishing domains fetch on history change&lt;/sub&gt;
![image.png](https://files.peakd.com/file/peakd-hive/keys-defender/23s9VYpXhV672UiRiZoZJ3hFwFyJe1tymtJfcP392Y4PFdpZDR8j8p3t18KQniG8XCUBW.png)

- Metrics - I added some timers and I noticed no significant &lt;u&gt;performance impact&lt;/u&gt; validating all risky elements against the list of known phishing domains.
- The script is already &lt;u&gt;resilient&lt;/u&gt; to API 500 responses (eg. DDOS-ed). We could also periodically rotate to different APIs or fetch multiple ones at the same time.

- Here is a link to my script transpiled with &lt;u&gt;BabelJS&lt;/u&gt; for older browsers and minified to save some milliseconds in the load time: https://keys-defender.github.io/scripts/universal-bridge-against-phishing.min.js



- &lt;u&gt;Test it&lt;/u&gt;!

To reiterate, before using this script in production it is highly recommended that you perform regression testing to make sure that existing features are not affected by the global overrides in my script. From my own tests they seem to all work correctly but this should not be put in production as is without review and further testing on each Hive frontend.

-----

&lt;br&gt;
- When all frontends will have in place an effective defense mechanism against phishing, it won't be necessary anymore for @keys-defender to keep warning Hive users against shortened links (eg. &lt;a href=&quot;https://hive.blog/hive-156509/@keys-defender/antiunsafelinks-keys-defender-bot-1615861217985&quot;&gt;https://hive.blog/hive-156509/@keys-defender/antiunsafelinks-keys-defender-bot-1615861217985&lt;/a&gt;) and phishing campaigns (eg. https://peakd.com/@leemikyung/qpwsgn).

-----

&lt;br&gt;

**Are you bored with your day and willing to read more?**

If you're not tired of hearing me rumble about this stuff in your head, here is some more stuff to read..
&lt;u&gt;Why&lt;/u&gt; did I decide to work on this solution?
There were some discussion ongoing on Discord and Slack about how to timely react to phishing campaigns that recently plagued Hive. @guiltyparties and @pfunk claimed that our best shot would be to block dangerous links directly in the Hive frontends. 


![image.png](https://files.peakd.com/file/peakd-hive/keys-defender/23u6YmnLys8BronfhK6AJfxpTnBSQv5KHLV83McP9FXTm8UgTzZa3bPEHt66FAbgz8sdn.png)

This though required every single maintainer of the Hive condensers to implement their own logic from scratch in order to block attackers.

![image.png](https://files.peakd.com/file/peakd-hive/keys-defender/23twABkvgbu378nPXEe6b84SjU3xg92rLant5dM5E5qpbKSVZFeJLU7QaQueeJxYR5wJt.png)

The idea I already have had in mind for a while though was to use a single script, as an universal solution for most Hive frontend out there.

I had already worked on something similar for a client of my employer. It was not for phishing, but the same logic applied. The platform I was working on used a custom scheme (eg. *somescheme://* instead of *https://*) and all relative protocol links added by third party scripts (eg. *&quot;//www.googletagmanager.com&quot;*) were defaulting to the custom scheme instead of using HTTPS.
In that occasion I had to use some global overrides to add the https prefix to anything that was meant to go out to third parties. That ended up being handy for this solution on Hive.

&lt;u&gt;When&lt;/u&gt; did I work on this Proof of Concept for Hive frontends, you ask?
Late at night in the past few days while caring for my few-days-old newborn. I'm off work and getting bored so I decided to put my sleep deprivation at work and started writing some code for this purpose. I hope it will be useful and get used to effectively improve our Hive frontends and discourage scammers.
&lt;br&gt;

-----

&lt;br&gt;

Take care,
@keys-defender (@gaottantacinque)

&lt;sub&gt;&lt;i&gt;Please don't forget to upvote and reblog. Donations are welcome as well, those damn diapers aren't free! &amp;nbsp; =P&lt;/i&gt;&lt;/sub&gt;
&lt;/div&gt;
&lt;script crossorigin='anonymous' integrity='sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=' src='https://code.jquery.com/jquery-3.5.1.slim.min.js'&gt;&lt;/script&gt;
&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@keys-defender&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/phishing-on-hive-no-more-solution-for-all-frontends&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-keys-defender-phishing-on-hive-no-more-solution-for-all-frontends').html();
      const outputElem = $('#content-keys-defender-phishing-on-hive-no-more-solution-for-all-frontends');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;
&lt;style&gt;
  #content-keys-defender-phishing-on-hive-no-more-solution-for-all-frontends {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-keys-defender-phishing-on-hive-no-more-solution-for-all-frontends code {
    background: white;
  }
  #content-keys-defender-phishing-on-hive-no-more-solution-for-all-frontends a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-keys-defender-phishing-on-hive-no-more-solution-for-all-frontends a:hover {
    border-bottom: 0;
  }
  #content-keys-defender-phishing-on-hive-no-more-solution-for-all-frontends h1 {
    font-size: 2.2em;
  }
  #content-keys-defender-phishing-on-hive-no-more-solution-for-all-frontends h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-keys-defender-phishing-on-hive-no-more-solution-for-all-frontends header small {
    color: #999;
    font-size: 50%;
  }
  #content-keys-defender-phishing-on-hive-no-more-solution-for-all-frontends img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;
&lt;p&gt;
  See: &lt;a href=&quot;https://peakd.com/hive-139531/@keys-defender/phishing-on-hive-no-more-solution-for-all-frontends&quot;&gt;Phishing on Hive? No more. Solution for all Frontends.&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@keys-defender&quot;&gt;@keys-defender&lt;/a&gt;
&lt;/p&gt;

&lt;/div&gt;</content><author><name>keys-defender</name></author><category term="news" /><category term="devops" /><category term="security" /><summary type="html">One &amp;nbsp; script &amp;nbsp; to rule them all.. https://files.peakd.com/file/peakd-hive/keys-defender/23uEx3ge6ahMEAqbNu2KxP3EvamdsBroMaGSYrkDRPsGUHc7sjst6GKUUPo7MoFq9YGo6.png ----- Problem: In the past few weeks Hive has been plagued by phishing campaigns and some users lost access to their account or lost their funds. This is nothing new and has been going on for years on ~~Steem~~ and Hive. https://files.peakd.com/file/peakd-hive/keys-defender/23ynfLMyQ7Cub6dZ3Dkgy3ibKnFc8DCeGkhiMRJjhBRtEVFTGBzSfAF8SxegpyrQM4eg4.png To make things worse, registrars are not quick enough to take down phishing domains.. https://files.peakd.com/file/peakd-hive/keys-defender/243MPzTbbyDU6fHr6SnsBBTJ3VSMBJk9KgL2At8pnztriEQmsYMWGAMwgEApYdzvTfB5e.png src It is time that the Hive community tries to mitigate this issue on their own. Potential solution:Use a plug-and-play universal script (or a modified copy of it) that all Hive frontends can integrate to block phishing links in a timely matter. As soon as a phishing campaign starts on Hive and the attacker's domain is spotted and added to a blacklist API (eg. @spaminator's), the universal script would immediately block the attack in all Hive frontends and at the same time leave the User Experience unaffected. As a matter of fact, this is what I worked on in the past few days. - Here is the universal script for all Hive frontends: https://github.com/keys-defender/hive/blob/master/scripts/universal-bridge-against-phishing.js - Here is a demo website with my script in action: https://keys-defender.github.io/hive *NOTE* : the demo page will not be sanitized by my universal script until you: 1. Navigate to https://cors-anywhere.herokuapp.com/corsdemo and click on the &quot;Request temporary access&quot; button, 2. refresh the demo website. I have proved my universal script working on: &amp;nbsp; &amp;nbsp; &amp;nbsp;(see screenshots down below) HIVE.BLOG - https://hive.blog - @blocktrades @quochuy PEAKD - https://peakd.com - @asgarth, @jarvie LEOFINANCE - https://leofinance.io - @khaleelkazi ECENCY - https://ecency.com - @good-karma 3SPEAK - https://3speak.tv - @theycallmedan, @starkerz D.BUZZ - https://d.buzz - @chrisrice STEM social - https://stem.openhive.network - @lemouth STEM geeks - https://stemgeeks.net - @enforcer48 ? It would be great if each Hive frontend maintaner could review it and adapt it to their needs (if they need to -- I tested this script in all major Hive frontends already and it did not seem to have unwanted side effects). I highly recommend though that the integration is thoroughly regression tested before it's used in production. FYI also for: AnonRamblings @emrebeyler, DTube @heimindanger, Engage @arcange, Engrave @engrave, @nicniezgrublem, Hive-db @jesta, Hive-Engine @aggroed, Hiveblockexplorer @penguinpablo, Hiveblocks @roadscape, HiveEngine @holger80, Quello @tobias-g, ... \+ other project maintaners: @yabapmatt, @stoodkev, @aggroed, @louis88, @mahdiyari, @acidyo, @fbslo, @rishi556. (apologies for the mass tag) I believe that blocking phishing campaigns in an unified way in all frontends is possible despite the different tech stacks in use. It does no matter which framework the website maintainer used to develop their website (eg. ReactJS, AngularJS, VueJS, JQuery, vanilla JS, etc). Using JS global overrides it is possible to prevent users from falling victim of phishing. What does my script do? It uses the native APIs offered by all browsers in order to immediately block phishing links and images in all Hive frontends as soon as they are discovered and published into the blacklist. - Any known phishing link in the UI will be red and strikethrough-ed. Furthermore if you click on a known phishing link you'll see an alert telling you that it's phishing and it won't allow you to navigate to the phishing domain from the Hive frontend. - Any image that is marked as a phishing attempt (eg. an image with some text saying &quot;claim your $ 1000 in tokens at www.justinscam.com&quot;) will not be displayed in any frontend that uses my script (or a variant of it) as soon as its URL is published into the public blacklist. More details will follow towards the end of the post to list all the native features of the browser that are hardened by my script in order to prevent phishing (ie. iframes, scripts, window open, XHR requests, Fetch api). Usage: How difficult is it to try out my universal script in your Hive-powered website? Integrating this script is very **straightforward**. In order to integrate it, simply add a ` See: Phishing on Hive? No more. Solution for all Frontends. by @keys-defender</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://files.peakd.com/file/peakd-hive/keys-defender/23uEx3ge6ahMEAqbNu2KxP3EvamdsBroMaGSYrkDRPsGUHc7sjst6GKUUPo7MoFq9YGo6.png" /><media:content medium="image" url="https://files.peakd.com/file/peakd-hive/keys-defender/23uEx3ge6ahMEAqbNu2KxP3EvamdsBroMaGSYrkDRPsGUHc7sjst6GKUUPo7MoFq9YGo6.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Devportal Python Tutorial Review Complete</title><link href="https://hivedocs.info/howto/beem/python/2021/03/16/devportal-python-tutorial-review-complete.html" rel="alternate" type="text/html" title="Devportal Python Tutorial Review Complete" /><published>2021-03-16T22:05:21-07:00</published><updated>2021-03-16T22:05:21-07:00</updated><id>https://hivedocs.info/howto/beem/python/2021/03/16/devportal-python-tutorial-review-complete</id><content type="html" xml:base="https://hivedocs.info/howto/beem/python/2021/03/16/devportal-python-tutorial-review-complete.html">&lt;div id=&quot;content-inertia-devportal-python-tutorial-review-complete&quot;&gt;&lt;div class=&quot;pull-right&quot;&gt;
  &lt;img src=&quot;https://developers.hive.io/images/sticker.png&quot; /&gt;
&lt;/div&gt;

Prior to this merge, the bulk of my work was on [the javascript tutorials](https://peakd.com/hive/@inertia/hive-developer-portal-update-language-tutorials-et-al).  After my proposal got funded, I was able to [dig deep into the API Definitions and begin the python tutorials](https://peakd.com/hive-139531/@inertia/hive-devportal-update-sdk-references-python-tutorials).

For this merge, I've continued to spend the last few weeks on the python tutorials.  There are 30+ tutorials ranging from how to vote to account recovery.

Most of them were written with the previous chain in mind.  As such, they all used the previous chain's &quot;official&quot; python library.  Now, they all use [beem](http://beem.readthedocs.io/) instead, because beem rocks.

Anyway, here are all the newly audited python tutorials:

http://developers-staging.hive.io/tutorials/#tutorials-python

Related merge:

https://gitlab.syncad.com/hive/devportal/-/merge_requests/66

This update also tracks the new Bridge API changes (Hivemind/Communities), [thanks to the information provided by openapi](https://peakd.com/openapi/@inertia/questions-about-hivemind-api-documentation).

---

One of the python tutorials I'm particularly proud of is the one about delegations:

https://developers.hive.io/tutorials-python/delegate_power.html

Before my changes, it was technically correct, which I admit is [the best kind of correct](https://www.youtube.com/watch?v=hou0lU8WMgo).  But in addition, I wanted to clarify in the tutorial, and in code examples, that it's best to present HIVE Power to the end-user, not VESTS.

While it's fine to write scripts that deal in VESTS, most people never encounter them.  Not only that, but the amount of HIVE Power vs. VESTS always changes.  Like, right now, at the time of writing, 527.344 HIVE Power is worth 1,000,000 VESTS.  That's not a very intuitive conversion, especially since it changes continuously.

&lt;center&gt;&lt;img src=&quot;https://files.peakd.com/file/peakd-hive/inertia/23uQvSia5q4QnBBeK9pYZ7bFsUawG5UWsdcFpygaxX4RQ9T9QEyB1PAE8Nm5HzLgj6a8c.jpg&quot; /&gt;&lt;/center&gt;

So I added steps to present VESTS as HIVE Power and capture HIVE Power inputs and turn them back to VESTS, since the blockchain wants to deal in VESTS.

That's just an example of the kinds of principles and best practices I want to enforce in the devportal, as much as possible.

&lt;center&gt;
  &lt;a href=&quot;https://xkcd.com/353/&quot;&gt;
    &lt;img src=&quot;https://imgs.xkcd.com/comics/python.png&quot; /&gt;
  &lt;/a&gt;
  &lt;sup&gt;I wrote 20 short programs in Python yesterday.  It was wonderful.  Perl, I'm leaving you.&lt;/sup&gt;
&lt;/center&gt;

Next, I'll do the same review audit for the ruby tutorials, but somehow I don't think that will take as long.

---

If you'd like to vote for my current proposal:

[https://hivesigner.com/sign/update-proposal-votes?proposal_ids=[151]&amp;amp;approve=true](https://hivesigner.com/sign/update-proposal-votes?proposal_ids=[151]&amp;amp;approve=true)

Also see: https://peakd.com/proposals/inertia&lt;/div&gt;
&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;

&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@inertia&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/devportal-python-tutorial-review-complete&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-inertia-devportal-python-tutorial-review-complete').html();
      const outputElem = $('#content-inertia-devportal-python-tutorial-review-complete');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;

&lt;style&gt;
  #content-inertia-devportal-python-tutorial-review-complete {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-inertia-devportal-python-tutorial-review-complete code {
    background: white;
  }
  #content-inertia-devportal-python-tutorial-review-complete a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-inertia-devportal-python-tutorial-review-complete a:hover {
    border-bottom: 0;
  }
  #content-inertia-devportal-python-tutorial-review-complete h1 {
    font-size: 2.2em;
  }
  #content-inertia-devportal-python-tutorial-review-complete h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-inertia-devportal-python-tutorial-review-complete header small {
    color: #999;
    font-size: 50%;
  }
  #content-inertia-devportal-python-tutorial-review-complete img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;

&lt;p&gt;
  See: &lt;a href=&quot;https://peakd.com/hive-139531/@inertia/devportal-python-tutorial-review-complete&quot;&gt;Devportal Python Tutorial Review Complete&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@inertia&quot;&gt;@inertia&lt;/a&gt;
&lt;/p&gt;</content><author><name>inertia</name></author><category term="howto" /><category term="beem" /><category term="python" /><summary type="html">Prior to this merge, the bulk of my work was on [the javascript tutorials](https://peakd.com/hive/@inertia/hive-developer-portal-update-language-tutorials-et-al). After my proposal got funded, I was able to [dig deep into the API Definitions and begin the python tutorials](https://peakd.com/hive-139531/@inertia/hive-devportal-update-sdk-references-python-tutorials). For this merge, I've continued to spend the last few weeks on the python tutorials. There are 30+ tutorials ranging from how to vote to account recovery. Most of them were written with the previous chain in mind. As such, they all used the previous chain's &quot;official&quot; python library. Now, they all use [beem](http://beem.readthedocs.io/) instead, because beem rocks. Anyway, here are all the newly audited python tutorials: http://developers-staging.hive.io/tutorials/#tutorials-python Related merge: https://gitlab.syncad.com/hive/devportal/-/merge_requests/66 This update also tracks the new Bridge API changes (Hivemind/Communities), [thanks to the information provided by openapi](https://peakd.com/openapi/@inertia/questions-about-hivemind-api-documentation). --- One of the python tutorials I'm particularly proud of is the one about delegations: https://developers.hive.io/tutorials-python/delegate_power.html Before my changes, it was technically correct, which I admit is [the best kind of correct](https://www.youtube.com/watch?v=hou0lU8WMgo). But in addition, I wanted to clarify in the tutorial, and in code examples, that it's best to present HIVE Power to the end-user, not VESTS. While it's fine to write scripts that deal in VESTS, most people never encounter them. Not only that, but the amount of HIVE Power vs. VESTS always changes. Like, right now, at the time of writing, 527.344 HIVE Power is worth 1,000,000 VESTS. That's not a very intuitive conversion, especially since it changes continuously. So I added steps to present VESTS as HIVE Power and capture HIVE Power inputs and turn them back to VESTS, since the blockchain wants to deal in VESTS. That's just an example of the kinds of principles and best practices I want to enforce in the devportal, as much as possible. I wrote 20 short programs in Python yesterday. It was wonderful. Perl, I'm leaving you. Next, I'll do the same review audit for the ruby tutorials, but somehow I don't think that will take as long. --- If you'd like to vote for my current proposal: [https://hivesigner.com/sign/update-proposal-votes?proposal_ids=[151]&amp;amp;approve=true](https://hivesigner.com/sign/update-proposal-votes?proposal_ids=[151]&amp;amp;approve=true) Also see: https://peakd.com/proposals/inertia See: Devportal Python Tutorial Review Complete by @inertia</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://developers.hive.io/images/sticker.png" /><media:content medium="image" url="https://developers.hive.io/images/sticker.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hive Account Recovery - Major update and new User Interface</title><link href="https://hivedocs.info/tools/2021/03/16/hive-account-recovery-major-update-and-new-user-interface.html" rel="alternate" type="text/html" title="Hive Account Recovery - Major update and new User Interface" /><published>2021-03-16T15:26:24-07:00</published><updated>2021-03-16T15:26:24-07:00</updated><id>https://hivedocs.info/tools/2021/03/16/hive-account-recovery-major-update-and-new-user-interface</id><content type="html" xml:base="https://hivedocs.info/tools/2021/03/16/hive-account-recovery-major-update-and-new-user-interface.html">&lt;div id=&quot;content-arcange-hive-account-recovery-major-update-and-new-user-interface&quot;&gt;&lt;center&gt;![](https://i.imgur.com/bVz67Yj.png)&lt;/center&gt;

Last week, I deployed an [update to the Hive Recovery service](/hive-139531/@arcange/hive-account-recovery-update). Hive Recovery is a service that runs continuously and on its own to help you secure and recover your account if it were to be compromised.

The latest wave of phishing currently raging and the growing number of accounts that have been hacked recently make the recovery process more than topical.

I recently had to provide assistance to users who wanted to change their recovery account. It allowed me to realize how the recovery procedure can seem complex for some. On the other hand, it's always a good thing to review your basics, the things that you (think you) have mastered and that seem obvious to you but not to others.

This previous update allowed me to dive back into the code and the associated process of recovering accounts and I realized that I was not fully satisfied with the proposed solution and that it could still be greatly improved, mainly at the user interface level. It also needed better edge cases and error handling and better feedback to users.

Therefore, I decided to go back to the drawing board and redesign it to transform what may seem complex for users to achieve into something simple and intuitive.

### Introducing Hive Recovery v2.0

The new [**Hive Recovery web page**](https://tools.hivechain.app/recovery) has been radically simplified and now clearly reflects the 3 steps associated with the Hive account recovery process:

![](https://i.imgur.com/im6VOdS.png)

1. You set @hive.recovery as your trusted account recovery partner.
2. Should your account be compromised, you request @hive.recovery to initiate the recovery process
3. Once @hive.recovery has done so, you confirm and finalize the process.

I will not provide you here with all the details regarding the use of this brand new recovery UI. It is available in the updated [Hive Recovery User Guide](/hive/@hive.recovery/userguide). Better to avoid turning this post into a wall of text and pictures. Anyway, here are a few screenshots of the new user interface.

### A quick overview of the recovery process

**Navigate to https://tools.hivechain.app/recovery**

The first thing to do is to enter your username (without the @) and hit enter or click on the account check button. If the account name is valid, the change recovery account button will light up and allow you to click on it.

![](https://i.imgur.com/ZTyY1Z0.png)

&amp;gt; **Note:** If you have already set @hive.recovery as your recovery account, the button will turn green. You can go to the next step or perform this step again if you want to change your recovery settings.

#### 1. Changing your recovery account

After clicking on the &quot;Change Recovery Account&quot; button, the following form will be displayed:

![](https://i.imgur.com/HUi2s0H.png)

Refer to the [Hive Recovery User Guide](/hive/@hive.recovery/userguide) for more information on how to fill the form and perform this step.

Once you have completed the first step, you will have to wait for 30 days before @hive.recovery actually becomes your recovery account. 

![](https://i.imgur.com/dZubbxc.png)

#### 2. Requesting for your recovery account

Should your account be compromised, head back to the [Hive Recovery website](https://tools.hivechain.app/recovery) and request @hive.recovery to initiate the recovery process. After validating your username, the first button should have turned to green (meaning @hive.recovery is now your recovery account) and the Request Recovery button should the page should be enabled

![](https://i.imgur.com/94vb8CG.png)
![](https://i.imgur.com/dYxb0iP.png)

Once again, refer to the [Hive Recovery User Guide](/hive/@hive.recovery/userguide) for more information on how to fill the form and what will happen when you perform this step.

@hive.recovery will initiate the recovery process. If all of the information you provided is correct, it should automatically take place within a few minutes.

![](https://i.imgur.com/OyRRJTY.png)

You now then have 24 hours to confirm the recovery of your account.

#### 3. Confirming the recovery of your account.

This is the very last step. You are now in control to finalize the recovery process

![](https://i.imgur.com/jIAKOCW.png)

After entering the required information and clicking on the confirmation button, the page will send a recovery confirmation to the blockchain, update your account keys and confirm that everything has gone well.

![](https://i.imgur.com/PQGSGu6.png)

Hooray, you are done and you have recovered your account!

### Please read the guide!

Check out the [Hive Recovery User Guide](/hive/@hive.recovery/userguide) for a complete and detailed description of the entire account recovery process.

The [Hive Recovery User Guide](/hive/@hive.recovery/userguide) also covers any questions you might have about security, privacy and how trusted it can be.

### Check your Recovery Account before it's too late

As mentioned at the beginning of this post, I have been led on several occasions to assist users who have their accounts hacked and who wanted to recover them.

Unfortunately, some of them still had @steem as their recovery account or had chosen an account that is no longer active or that does not respond to their request. What a pity that we can no longer help them

Therefore, check your recovery account and change it if the current one is inappropriate.

It's been a lot of work to create and improve this service and make the recovery process as easy as possible for all non-tech-savvy users. It would be a shame not to take advantage of it.

Take care of your account!

## &lt;center&gt;https://tools.hivechain.app/recovery&lt;/center&gt;
---
&lt;center&gt;

### Check out my apps and services
&lt;a href=&quot;/hive/@hive.engage/stay-connected-with-your-hive-audience-and-catch-attention&quot;&gt;&lt;img src=&quot;https://i.imgur.com/GiNJqlm.png&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;/@hivebuzz&quot;&gt;&lt;img src=&quot;https://i.imgur.com/B4UTun2.png&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;/@hivesql&quot;&gt;&lt;img src=&quot;https://i.imgur.com/EPN8RW6.png&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;/hive/@arcange/introducing-hive-account-recovery&quot;&gt;&lt;img src=&quot;https://i.imgur.com/6TWeW7V.png&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;/@hive.autoclaim&quot;&gt;&lt;img src=&quot;https://i.imgur.com/ih2pEOw.png&quot; /&gt;&lt;/a&gt;&lt;/center&gt;
&lt;center&gt;

### [Vote for me as a witness ![](https://i.imgur.com/2bi4SnT.png)](https://hivesigner.com/sign/account-witness-vote?witness=arcange&amp;amp;approve=1)&amp;lt;/div&amp;gt;
&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@arcange&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/hive-account-recovery-major-update-and-new-user-interface&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-arcange-hive-account-recovery-major-update-and-new-user-interface').html();
      const outputElem = $('#content-arcange-hive-account-recovery-major-update-and-new-user-interface');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;
&lt;style&gt;
  #content-arcange-hive-account-recovery-major-update-and-new-user-interface {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-arcange-hive-account-recovery-major-update-and-new-user-interface code {
    background: white;
  }
  #content-arcange-hive-account-recovery-major-update-and-new-user-interface a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-arcange-hive-account-recovery-major-update-and-new-user-interface a:hover {
    border-bottom: 0;
  }
  #content-arcange-hive-account-recovery-major-update-and-new-user-interface h1 {
    font-size: 2.2em;
  }
  #content-arcange-hive-account-recovery-major-update-and-new-user-interface h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-arcange-hive-account-recovery-major-update-and-new-user-interface header small {
    color: #999;
    font-size: 50%;
  }
  #content-arcange-hive-account-recovery-major-update-and-new-user-interface img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;
&lt;p&gt;
  See: &lt;a href=&quot;https://peakd.com/hive-139531/@arcange/hive-account-recovery-major-update-and-new-user-interface&quot;&gt;Hive Account Recovery - Major update and new User Interface&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@arcange&quot;&gt;@arcange&lt;/a&gt;
&lt;/p&gt;

&lt;/center&gt;&lt;/div&gt;</content><author><name>arcange</name></author><category term="tools" /><summary type="html">![](https://i.imgur.com/bVz67Yj.png) Last week, I deployed an [update to the Hive Recovery service](/hive-139531/@arcange/hive-account-recovery-update). Hive Recovery is a service that runs continuously and on its own to help you secure and recover your account if it were to be compromised. The latest wave of phishing currently raging and the growing number of accounts that have been hacked recently make the recovery process more than topical. I recently had to provide assistance to users who wanted to change their recovery account. It allowed me to realize how the recovery procedure can seem complex for some. On the other hand, it's always a good thing to review your basics, the things that you (think you) have mastered and that seem obvious to you but not to others. This previous update allowed me to dive back into the code and the associated process of recovering accounts and I realized that I was not fully satisfied with the proposed solution and that it could still be greatly improved, mainly at the user interface level. It also needed better edge cases and error handling and better feedback to users. Therefore, I decided to go back to the drawing board and redesign it to transform what may seem complex for users to achieve into something simple and intuitive. ### Introducing Hive Recovery v2.0 The new [**Hive Recovery web page**](https://tools.hivechain.app/recovery) has been radically simplified and now clearly reflects the 3 steps associated with the Hive account recovery process: ![](https://i.imgur.com/im6VOdS.png) 1. You set @hive.recovery as your trusted account recovery partner. 2. Should your account be compromised, you request @hive.recovery to initiate the recovery process 3. Once @hive.recovery has done so, you confirm and finalize the process. I will not provide you here with all the details regarding the use of this brand new recovery UI. It is available in the updated [Hive Recovery User Guide](/hive/@hive.recovery/userguide). Better to avoid turning this post into a wall of text and pictures. Anyway, here are a few screenshots of the new user interface. ### A quick overview of the recovery process **Navigate to https://tools.hivechain.app/recovery** The first thing to do is to enter your username (without the @) and hit enter or click on the account check button. If the account name is valid, the change recovery account button will light up and allow you to click on it. ![](https://i.imgur.com/ZTyY1Z0.png) &amp;gt; **Note:** If you have already set @hive.recovery as your recovery account, the button will turn green. You can go to the next step or perform this step again if you want to change your recovery settings. #### 1. Changing your recovery account After clicking on the &quot;Change Recovery Account&quot; button, the following form will be displayed: ![](https://i.imgur.com/HUi2s0H.png) Refer to the [Hive Recovery User Guide](/hive/@hive.recovery/userguide) for more information on how to fill the form and perform this step. Once you have completed the first step, you will have to wait for 30 days before @hive.recovery actually becomes your recovery account. ![](https://i.imgur.com/dZubbxc.png) #### 2. Requesting for your recovery account Should your account be compromised, head back to the [Hive Recovery website](https://tools.hivechain.app/recovery) and request @hive.recovery to initiate the recovery process. After validating your username, the first button should have turned to green (meaning @hive.recovery is now your recovery account) and the Request Recovery button should the page should be enabled ![](https://i.imgur.com/94vb8CG.png) ![](https://i.imgur.com/dYxb0iP.png) Once again, refer to the [Hive Recovery User Guide](/hive/@hive.recovery/userguide) for more information on how to fill the form and what will happen when you perform this step. @hive.recovery will initiate the recovery process. If all of the information you provided is correct, it should automatically take place within a few minutes. ![](https://i.imgur.com/OyRRJTY.png) You now then have 24 hours to confirm the recovery of your account. #### 3. Confirming the recovery of your account. This is the very last step. You are now in control to finalize the recovery process ![](https://i.imgur.com/jIAKOCW.png) After entering the required information and clicking on the confirmation button, the page will send a recovery confirmation to the blockchain, update your account keys and confirm that everything has gone well. ![](https://i.imgur.com/PQGSGu6.png) Hooray, you are done and you have recovered your account! ### Please read the guide! Check out the [Hive Recovery User Guide](/hive/@hive.recovery/userguide) for a complete and detailed description of the entire account recovery process. The [Hive Recovery User Guide](/hive/@hive.recovery/userguide) also covers any questions you might have about security, privacy and how trusted it can be. ### Check your Recovery Account before it's too late As mentioned at the beginning of this post, I have been led on several occasions to assist users who have their accounts hacked and who wanted to recover them. Unfortunately, some of them still had @steem as their recovery account or had chosen an account that is no longer active or that does not respond to their request. What a pity that we can no longer help them Therefore, check your recovery account and change it if the current one is inappropriate. It's been a lot of work to create and improve this service and make the recovery process as easy as possible for all non-tech-savvy users. It would be a shame not to take advantage of it. Take care of your account! ## https://tools.hivechain.app/recovery --- ### Check out my apps and services ### [Vote for me as a witness ![](https://i.imgur.com/2bi4SnT.png)](https://hivesigner.com/sign/account-witness-vote?witness=arcange&amp;amp;approve=1)&amp;lt;/div&amp;gt; See: Hive Account Recovery - Major update and new User Interface by @arcange</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://i.imgur.com/bVz67Yj.png" /><media:content medium="image" url="https://i.imgur.com/bVz67Yj.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Making a Decentralized Game on Hive - Part 2</title><link href="https://hivedocs.info/howto/nodejs/2021/03/16/making-a-decentralized-game-on-hive-part-2.html" rel="alternate" type="text/html" title="Making a Decentralized Game on Hive - Part 2" /><published>2021-03-16T08:22:15-07:00</published><updated>2021-03-16T08:22:15-07:00</updated><id>https://hivedocs.info/howto/nodejs/2021/03/16/making-a-decentralized-game-on-hive-part-2</id><content type="html" xml:base="https://hivedocs.info/howto/nodejs/2021/03/16/making-a-decentralized-game-on-hive-part-2.html">&lt;div id=&quot;content-mahdiyari-making-a-decentralized-game-on-hive-part-2&quot;&gt;&lt;center&gt;![code-944499_1280.jpg](https://images.hive.blog/DQmZn8iD8SQbqnN8RNGJku4SCKQH6pKAPBh6QqtBrby1mAN/code-944499_1280.jpg)&lt;/center&gt;
Previously in [part 1](https://hive.blog/hive-139531/@mahdiyari/making-a-decentralized-game-on-hive-tic-tac-toe-part-1), we made a simple front-end and a login option with posting key.

In this part, we work on the back-end of the game. We use [Nodejs](https://nodejs.org/en/) for running our back-end codes. I assume you know how to create or run a Nodejs app. It's not complicated and I will cover most of it here.

## API server
`api/server.js` is the starting point of the API server. Let's initialize it with expressjs and some libraries for API usage.
```
const express = require('express')
const bodyParser = require('body-parser')
const hpp = require('hpp')
const helmet = require('helmet')
const app = express()

// more info: www.npmjs.com/package/hpp
app.use(hpp())
app.use(helmet())

// support json encoded bodies and encoded bodies
app.use(bodyParser.json())
app.use(bodyParser.urlencoded({ extended: true }))

app.use(function (req, res, next) {
  res.header(
    'Access-Control-Allow-Origin',
    'http://localhost https://tic-tac-toe.mahdiyari.info/'
  )
  res.header('Access-Control-Allow-Credentials', true)
  res.header(
    'Access-Control-Allow-Headers',
    'Origin, X-Requested-With, Content-Type, Accept, access_key'
  )
  next()
})

const port = process.env.PORT || 2021
const host = process.env.HOST || '127.0.0.1'
app.listen(port, host, () =&amp;gt; {
  console.log(`Application started on ${host}:${port}`)
})
```
Don't forget to install npm packages.
```
npm install express
npm install body-parser
npm install hpp
npm install helmet
```
`hpp` and `helmet` are for increased security and `body-parser` for parsing request bodies for json encoded bodies and encoded bodies.

I also added `http://localhost` and `https://tic-tac-toe.mahdiyari.info/` to the `Access-Control-Allow-Origin` header. You can add another URL to receive API calls from or just put `*`. It basically limits the usage of the API server to the listed URLs.

Our API server will listen to `127.0.0.1:2021` by default. It does nothing at the moment. Let's continue with the main application.
***
## Main application
We will run 2 Nodejs apps. One is the API server and the other is the main application where streaming blocks and processing data is happening. The reason for splitting applications is to run the API server in cluster mode. With cluster mode, we can run one API server for each CPU core. It will help with load balancing and keep API running as fast as possible while serving many requests. The cluster mode is useful only on API servers and especially Expressjs apps.

We will need a helper to stream the blocks.
`helpers/streamBlock.js`:
```
const hiveTx = require('hive-tx')

const INTERVAL_TIME = 1000

const streamBlockNumber = async (cb) =&amp;gt; {
  try {
    let lastBlock = 0
    setInterval(async () =&amp;gt; {
      const gdgp = await hiveTx.call(
        'condenser_api.get_dynamic_global_properties'
      )
      if (
        gdgp &amp;amp;&amp;amp;
        gdgp.result &amp;amp;&amp;amp;
        gdgp.result.head_block_number &amp;amp;&amp;amp;
        !isNaN(gdgp.result.head_block_number)
      ) {
        if (gdgp.result.head_block_number &amp;gt; lastBlock) {
          lastBlock = gdgp.result.head_block_number
          cb(lastBlock)
        }
      }
    }, INTERVAL_TIME)
  } catch (e) {
    throw new Error(e)
  }
}

const streamBlockOperations = async (cb) =&amp;gt; {
  try {
    streamBlockNumber(async (blockNumber) =&amp;gt; {
      const result = await hiveTx.call('condenser_api.get_block', [
        blockNumber
      ])
      if (result.result) {
        const operations = result.result.transactions.map((transaction) =&amp;gt; {
          return transaction.operations
        })
        if (operations.length &amp;gt; 0) {
          for (const operation of operations) {
            cb(operation)
          }
        }
      }
    })
  } catch (e) {
    throw new Error(e)
  }
}

module.exports = {
  streamBlockNumber,
  streamBlockOperations
}
```
install [hive-tx](https://www.npmjs.com/package/hive-tx): `npm install hive-tx`

We created 2 functions here. The first one `streamBlockNumber` makes a call to get `dynamic_global_properties` every `INTERVAL_TIME` which I set to 1000ms (1 second) then checks for newly produced block number. If the block number is increased, then it calls the callback function with the new block number. It's a helpful function for getting newly generated block numbers.

We use the first function inside the second function `streamBlockOperations` to get newly generated blocks and get operations inside that block by using the `condenser_api.get_block` method.

`streamBlockOperations` will call the callback function with newly added operations to the blockchain (except virtual operations).

`index.js`:
```
const stream = require('./helpers/streamBlock')

try {
  stream.streamBlockOperations((ops) =&amp;gt; {
    if (ops) {
      const op = ops[0]
      if (op &amp;amp;&amp;amp; op[0] === 'custom_json' &amp;amp;&amp;amp; op[1].id === 'tictactoe') {
        processData(op[1].json)
      }
    }
  })
} catch (e) {
  throw new Error(e)
}
```
This will stream newly added operations to the blockchain and send the JSON from `custom_json` operations with the id of `tictactoe` to the `processData` function.
***
We should define game mechanics and their corresponding custom_json.

**Create a game**
```
{
  app: 'tictactoe/0.0.1'
  action: 'create_game',
  id: 'Random generated id',
  starting_player: 'first or second'
}
```
Create a game and wait for the other player to join.
***
**Request join a game**
```
{
  app: 'tictactoe/0.0.1',
  action: 'request_join',
  id: 'Game id'
}
```
Request to join an open game which is created by someone else.
***
**Accept join request**
```
{
  app: 'tictactoe/0.0.1',
  action: 'accept_request',
  id: 'Game id',
  player: 'username'
}
```
Accept the pending join request from another player to your created game. 
***
**Play**
```
{
  app: 'tictactoe/0.0.1',
  action: 'play',
  id: 'Game id',
  col: '1 to 3',
  row: '1 to 3'
}
```
Play or place an X/O on the board. `col` is the column and `row` is for the row of the placed X/O on the board.

&lt;center&gt;![tic-tac-toe-col-row.jpg](https://images.hive.blog/DQmYtN2du2ngnu51fernMHqvmp5VKSyZ5JkF6wRgS9MkubP/tic-tac-toe-col-row.jpg)&lt;/center&gt;
***
Code implamantaion of the above in `index.js`:
```
const processData = (jsonData) =&amp;gt; {
  try {
    if (!jsonData) {
      return
    }
    const data = JSON.parse(jsonData)
    if (!data || !data.action || !data.app) {
      return
    }
    if (data.action === 'create_game') {
      createGame(data)
    } else if (data.action === 'request_join') {
      requestJoin(data)
    } else if (data.action === 'accept_request') {
      acceptRequest(data)
    } else if (data.action === 'play') {
      play(data)
    }
  } catch (e) {
    // error might be on JSON.parse and wrong json format
    return null
  }
}
```
***
Let's create a function for each game mechanic.
**createGame**:
```
const createGame = (data) =&amp;gt; {
  if (!data || !data.id || !data.starting_player) {
    return
  }
  // validating
  if (
    data.id.length !== 20 ||
    (data.starting_player !== 'first' &amp;amp;&amp;amp; data.starting_player !== 'second')
  ) {
    return
  }
  // Add game to database
  console.log('Create a game with id ' + data.id)
}
```
***
**requestJoin**:
```
const requestJoin = (data) =&amp;gt; {
  if (!data || !data.id || !data.id.length !== 20) {
    return
  }
  // Check game id in database
  // Join game
  console.log('A player joined game id ' + data.id)
}
```
***
**acceptRequest**:
```
const acceptRequest = (data) =&amp;gt; {
  if (!data || !data.id || !data.player || !data.id.length !== 20) {
    return
  }
  // Validate game in database
  // Accept the join request
  console.log('Accepted join request game id ' + data.id)
}
```
***
**play**:
```
const play = (data) =&amp;gt; {
  if (
    !data ||
    !data.id ||
    !data.col ||
    !data.row ||
    !data.id.length !== 20 ||
    data.col &amp;lt; 1 ||
    data.col &amp;gt; 3 ||
    data.row &amp;lt; 1 ||
    data.row &amp;gt; 3
  ) {
    return
  }
  // Validate game in database
  // Validate the player round
  // Play game
  console.log('Played game id ' + data.id)
}
```
***
The above functions are not doing anything at the moment. We will complete those functions after setting up the database in the next part.

We can test our code by broadcasting custom_json operations. Let's see if the streaming method and processing data works.
We can run the app by `node index.js`
https://hiveblocks.com/tx/44799e6a27c64e935f9072ecb576602330cb80b8
&lt;center&gt;![image.png](https://images.hive.blog/DQmSfMrgDbSPjUPWaPeekrWfDFTS6zfdkk4NMySjNQmh3xh/image.png)&lt;/center&gt;
And here is the console.log() confirmation in our app:
&lt;center&gt;![image.png](https://images.hive.blog/DQmb4kymGnacj2H9D4f2jfU8xYWJdjcd1EKDZeLN6q96q8h/image.png)&lt;/center&gt;
***
Follow me so you don't miss the next part. The final code of this part is on GitLab.

[GitLab Repository](https://gitlab.com/mahdiyari/decentralized-game-on-hive)
[Website](https://tic-tac-toe.mahdiyari.info/)

[Part 1](https://hive.blog/hive-139531/@mahdiyari/making-a-decentralized-game-on-hive-tic-tac-toe-part-1)&lt;/div&gt;
&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;

&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@mahdiyari&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/making-a-decentralized-game-on-hive-part-2&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-mahdiyari-making-a-decentralized-game-on-hive-part-2').html();
      const outputElem = $('#content-mahdiyari-making-a-decentralized-game-on-hive-part-2');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;

&lt;style&gt;
  #content-mahdiyari-making-a-decentralized-game-on-hive-part-2 {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-part-2 code {
    background: white;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-part-2 a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-part-2 a:hover {
    border-bottom: 0;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-part-2 h1 {
    font-size: 2.2em;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-part-2 h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-part-2 header small {
    color: #999;
    font-size: 50%;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-part-2 img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;

&lt;p&gt;
  See: &lt;a href=&quot;https://hive.blog/hive-139531/@mahdiyari/making-a-decentralized-game-on-hive-part-2&quot;&gt;Making a Decentralized Game on Hive - Part 2&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@mahdiyari&quot;&gt;@mahdiyari&lt;/a&gt;
&lt;/p&gt;</content><author><name>mahdiyari</name></author><category term="howto" /><category term="nodejs" /><summary type="html">![code-944499_1280.jpg](https://images.hive.blog/DQmZn8iD8SQbqnN8RNGJku4SCKQH6pKAPBh6QqtBrby1mAN/code-944499_1280.jpg) Previously in [part 1](https://hive.blog/hive-139531/@mahdiyari/making-a-decentralized-game-on-hive-tic-tac-toe-part-1), we made a simple front-end and a login option with posting key. In this part, we work on the back-end of the game. We use [Nodejs](https://nodejs.org/en/) for running our back-end codes. I assume you know how to create or run a Nodejs app. It's not complicated and I will cover most of it here. ## API server `api/server.js` is the starting point of the API server. Let's initialize it with expressjs and some libraries for API usage. ``` const express = require('express') const bodyParser = require('body-parser') const hpp = require('hpp') const helmet = require('helmet') const app = express() // more info: www.npmjs.com/package/hpp app.use(hpp()) app.use(helmet()) // support json encoded bodies and encoded bodies app.use(bodyParser.json()) app.use(bodyParser.urlencoded({ extended: true })) app.use(function (req, res, next) { res.header( 'Access-Control-Allow-Origin', 'http://localhost https://tic-tac-toe.mahdiyari.info/' ) res.header('Access-Control-Allow-Credentials', true) res.header( 'Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, access_key' ) next() }) const port = process.env.PORT || 2021 const host = process.env.HOST || '127.0.0.1' app.listen(port, host, () =&amp;gt; { console.log(`Application started on ${host}:${port}`) }) ``` Don't forget to install npm packages. ``` npm install express npm install body-parser npm install hpp npm install helmet ``` `hpp` and `helmet` are for increased security and `body-parser` for parsing request bodies for json encoded bodies and encoded bodies. I also added `http://localhost` and `https://tic-tac-toe.mahdiyari.info/` to the `Access-Control-Allow-Origin` header. You can add another URL to receive API calls from or just put `*`. It basically limits the usage of the API server to the listed URLs. Our API server will listen to `127.0.0.1:2021` by default. It does nothing at the moment. Let's continue with the main application. *** ## Main application We will run 2 Nodejs apps. One is the API server and the other is the main application where streaming blocks and processing data is happening. The reason for splitting applications is to run the API server in cluster mode. With cluster mode, we can run one API server for each CPU core. It will help with load balancing and keep API running as fast as possible while serving many requests. The cluster mode is useful only on API servers and especially Expressjs apps. We will need a helper to stream the blocks. `helpers/streamBlock.js`: ``` const hiveTx = require('hive-tx') const INTERVAL_TIME = 1000 const streamBlockNumber = async (cb) =&amp;gt; { try { let lastBlock = 0 setInterval(async () =&amp;gt; { const gdgp = await hiveTx.call( 'condenser_api.get_dynamic_global_properties' ) if ( gdgp &amp;amp;&amp;amp; gdgp.result &amp;amp;&amp;amp; gdgp.result.head_block_number &amp;amp;&amp;amp; !isNaN(gdgp.result.head_block_number) ) { if (gdgp.result.head_block_number &amp;gt; lastBlock) { lastBlock = gdgp.result.head_block_number cb(lastBlock) } } }, INTERVAL_TIME) } catch (e) { throw new Error(e) } } const streamBlockOperations = async (cb) =&amp;gt; { try { streamBlockNumber(async (blockNumber) =&amp;gt; { const result = await hiveTx.call('condenser_api.get_block', [ blockNumber ]) if (result.result) { const operations = result.result.transactions.map((transaction) =&amp;gt; { return transaction.operations }) if (operations.length &amp;gt; 0) { for (const operation of operations) { cb(operation) } } } }) } catch (e) { throw new Error(e) } } module.exports = { streamBlockNumber, streamBlockOperations } ``` install [hive-tx](https://www.npmjs.com/package/hive-tx): `npm install hive-tx` We created 2 functions here. The first one `streamBlockNumber` makes a call to get `dynamic_global_properties` every `INTERVAL_TIME` which I set to 1000ms (1 second) then checks for newly produced block number. If the block number is increased, then it calls the callback function with the new block number. It's a helpful function for getting newly generated block numbers. We use the first function inside the second function `streamBlockOperations` to get newly generated blocks and get operations inside that block by using the `condenser_api.get_block` method. `streamBlockOperations` will call the callback function with newly added operations to the blockchain (except virtual operations). `index.js`: ``` const stream = require('./helpers/streamBlock') try { stream.streamBlockOperations((ops) =&amp;gt; { if (ops) { const op = ops[0] if (op &amp;amp;&amp;amp; op[0] === 'custom_json' &amp;amp;&amp;amp; op[1].id === 'tictactoe') { processData(op[1].json) } } }) } catch (e) { throw new Error(e) } ``` This will stream newly added operations to the blockchain and send the JSON from `custom_json` operations with the id of `tictactoe` to the `processData` function. *** We should define game mechanics and their corresponding custom_json. **Create a game** ``` { app: 'tictactoe/0.0.1' action: 'create_game', id: 'Random generated id', starting_player: 'first or second' } ``` Create a game and wait for the other player to join. *** **Request join a game** ``` { app: 'tictactoe/0.0.1', action: 'request_join', id: 'Game id' } ``` Request to join an open game which is created by someone else. *** **Accept join request** ``` { app: 'tictactoe/0.0.1', action: 'accept_request', id: 'Game id', player: 'username' } ``` Accept the pending join request from another player to your created game. *** **Play** ``` { app: 'tictactoe/0.0.1', action: 'play', id: 'Game id', col: '1 to 3', row: '1 to 3' } ``` Play or place an X/O on the board. `col` is the column and `row` is for the row of the placed X/O on the board. ![tic-tac-toe-col-row.jpg](https://images.hive.blog/DQmYtN2du2ngnu51fernMHqvmp5VKSyZ5JkF6wRgS9MkubP/tic-tac-toe-col-row.jpg) *** Code implamantaion of the above in `index.js`: ``` const processData = (jsonData) =&amp;gt; { try { if (!jsonData) { return } const data = JSON.parse(jsonData) if (!data || !data.action || !data.app) { return } if (data.action === 'create_game') { createGame(data) } else if (data.action === 'request_join') { requestJoin(data) } else if (data.action === 'accept_request') { acceptRequest(data) } else if (data.action === 'play') { play(data) } } catch (e) { // error might be on JSON.parse and wrong json format return null } } ``` *** Let's create a function for each game mechanic. **createGame**: ``` const createGame = (data) =&amp;gt; { if (!data || !data.id || !data.starting_player) { return } // validating if ( data.id.length !== 20 || (data.starting_player !== 'first' &amp;amp;&amp;amp; data.starting_player !== 'second') ) { return } // Add game to database console.log('Create a game with id ' + data.id) } ``` *** **requestJoin**: ``` const requestJoin = (data) =&amp;gt; { if (!data || !data.id || !data.id.length !== 20) { return } // Check game id in database // Join game console.log('A player joined game id ' + data.id) } ``` *** **acceptRequest**: ``` const acceptRequest = (data) =&amp;gt; { if (!data || !data.id || !data.player || !data.id.length !== 20) { return } // Validate game in database // Accept the join request console.log('Accepted join request game id ' + data.id) } ``` *** **play**: ``` const play = (data) =&amp;gt; { if ( !data || !data.id || !data.col || !data.row || !data.id.length !== 20 || data.col &amp;lt; 1 || data.col &amp;gt; 3 || data.row &amp;lt; 1 || data.row &amp;gt; 3 ) { return } // Validate game in database // Validate the player round // Play game console.log('Played game id ' + data.id) } ``` *** The above functions are not doing anything at the moment. We will complete those functions after setting up the database in the next part. We can test our code by broadcasting custom_json operations. Let's see if the streaming method and processing data works. We can run the app by `node index.js` https://hiveblocks.com/tx/44799e6a27c64e935f9072ecb576602330cb80b8 ![image.png](https://images.hive.blog/DQmSfMrgDbSPjUPWaPeekrWfDFTS6zfdkk4NMySjNQmh3xh/image.png) And here is the console.log() confirmation in our app: ![image.png](https://images.hive.blog/DQmb4kymGnacj2H9D4f2jfU8xYWJdjcd1EKDZeLN6q96q8h/image.png) *** Follow me so you don't miss the next part. The final code of this part is on GitLab. [GitLab Repository](https://gitlab.com/mahdiyari/decentralized-game-on-hive) [Website](https://tic-tac-toe.mahdiyari.info/) [Part 1](https://hive.blog/hive-139531/@mahdiyari/making-a-decentralized-game-on-hive-tic-tac-toe-part-1) See: Making a Decentralized Game on Hive - Part 2 by @mahdiyari</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://images.hive.blog/DQmZn8iD8SQbqnN8RNGJku4SCKQH6pKAPBh6QqtBrby1mAN/code-944499_1280.jpg" /><media:content medium="image" url="https://images.hive.blog/DQmZn8iD8SQbqnN8RNGJku4SCKQH6pKAPBh6QqtBrby1mAN/code-944499_1280.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hive core developer meeting #19</title><link href="https://hivedocs.info/news/core/development/2021/03/15/hive-core-developer-meeting-19.html" rel="alternate" type="text/html" title="Hive core developer meeting #19" /><published>2021-03-15T17:09:54-07:00</published><updated>2021-03-15T17:09:54-07:00</updated><id>https://hivedocs.info/news/core/development/2021/03/15/hive-core-developer-meeting-19</id><content type="html" xml:base="https://hivedocs.info/news/core/development/2021/03/15/hive-core-developer-meeting-19.html">&lt;div id=&quot;content-howo-hive-core-developer-meeting-19&quot;&gt;https://www.youtube.com/watch?v=UIRR5gFfVYk

meeting tl;dr:

## Dev sync
As usual listen to this one is better 

## hived proposal payout maintenance time drifting fix in hf25 or not [hive!168](https://gitlab.syncad.com/hive/hive/-/merge_requests/168)

Lots of discussion on this one that branched into two problems, one is the proposal time drift issue, the other is about the unit tests behaving strangely due to the skipping logic.

The output of that point is that I will try to fix it for hf25 and see how the unit tests go, but if I see that it takes too much time, I'll skip it and we'll fix it for hf26. It's a minor issue.

## Incoming recurrent transfer api: hived or hivemind ? Broader discussion on should hivemind support recurrent transfers 

Incoming recurrent transfers will be done via hivemind, and yes hivemind will support them, we will do it after hf25 has shipped though.

## Update the beem used for unit tests in hived to one that is more up to date:

Relatively short discussion, and since @holger80 implemented the hybrid transactions in the mainline github, we'll move towards using the version on github instead of gitlab.

## Hived split block log in chunks and be able to sync those independently

There was lots of discussions on this in the dev channels. It's not the focus right now as hf25 is upon us, there was some discussions on using external tools instead of implementing it directly within hived. To be rediscussed.

## Hivemind Communities type 2/3 and account level mutes [hivemind#125](https://gitlab.syncad.com/hive/hivemind/-/issues/125) / [hivemind#145](https://gitlab.syncad.com/hive/hivemind/-/issues/145)

Bt's team is building tests, we'll then then who takes this on, potentially bt's team as I'll be tied to hived 

## Hivemind communities beneficiaries support [hivemind#149](https://gitlab.syncad.com/hive/hivemind/-/issues/149) +parameter naming: reward_share vs beneficiaries

We also discussed changing the data type of the communities data from text to jsonb (https://gitlab.syncad.com/hive/hivemind/-/issues/153)

Basically we'll use beneficiaries and the current implementations ideas are a bit early, we(I) are waiting for the changes to take place in communities type 2/3 + account level mutes to take place before taking this on.

## Hivemind Communities metadata (topics/tags) [hivemind#148](https://gitlab.syncad.com/hive/hivemind/-/issues/148) 

Yes why not, we'll add a new field to store a few &quot;communities tags&quot; and a new api to search for communities via said tags. The idea is to be able to tag a community like &quot;crypto nft games&quot; or &quot;sport tennis&quot; etc to make content discovery easier

## Adding more stats for communities 

A bit early to tell what we'll add but I'll definitely look into adding more stats and ways to sort communities with it.

# Conclusion

In the end lots of hivemind talks but those are mostly preliminary, our focus is hf25 we are tentatively(this is not an official date or anything, it's more like an &quot;ideally we would like it to be done by but might slip if needs be&quot;) looking at april 15 for locking the core code and build a testnet for hf25. This is when all the features for hf25 are set in stone and we stop adding new features to the core code. So all developments HAVE to be done by then. 

This is why I'll be mostly focusing on hive core for the next month to get all of my ongoing code merged and included in hf25.

See you around for the next dev meeting on march 29th :) 
@howo&lt;/div&gt;
&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;

&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@howo&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/hive-core-developer-meeting-19&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-howo-hive-core-developer-meeting-19').html();
      const outputElem = $('#content-howo-hive-core-developer-meeting-19');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;

&lt;style&gt;
  #content-howo-hive-core-developer-meeting-19 {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-howo-hive-core-developer-meeting-19 code {
    background: white;
  }
  #content-howo-hive-core-developer-meeting-19 a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-howo-hive-core-developer-meeting-19 a:hover {
    border-bottom: 0;
  }
  #content-howo-hive-core-developer-meeting-19 h1 {
    font-size: 2.2em;
  }
  #content-howo-hive-core-developer-meeting-19 h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-howo-hive-core-developer-meeting-19 header small {
    color: #999;
    font-size: 50%;
  }
  #content-howo-hive-core-developer-meeting-19 img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;

&lt;p&gt;
  See: &lt;a href=&quot;https://peakd.com/hive/@howo/hive-core-developer-meeting-19&quot;&gt;Hive core developer meeting #19&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@howo&quot;&gt;@howo&lt;/a&gt;
&lt;/p&gt;</content><author><name>howo</name></author><category term="news" /><category term="core" /><category term="development" /><summary type="html">https://www.youtube.com/watch?v=UIRR5gFfVYk meeting tl;dr: ## Dev sync As usual listen to this one is better ## hived proposal payout maintenance time drifting fix in hf25 or not [hive!168](https://gitlab.syncad.com/hive/hive/-/merge_requests/168) Lots of discussion on this one that branched into two problems, one is the proposal time drift issue, the other is about the unit tests behaving strangely due to the skipping logic. The output of that point is that I will try to fix it for hf25 and see how the unit tests go, but if I see that it takes too much time, I'll skip it and we'll fix it for hf26. It's a minor issue. ## Incoming recurrent transfer api: hived or hivemind ? Broader discussion on should hivemind support recurrent transfers Incoming recurrent transfers will be done via hivemind, and yes hivemind will support them, we will do it after hf25 has shipped though. ## Update the beem used for unit tests in hived to one that is more up to date: Relatively short discussion, and since @holger80 implemented the hybrid transactions in the mainline github, we'll move towards using the version on github instead of gitlab. ## Hived split block log in chunks and be able to sync those independently There was lots of discussions on this in the dev channels. It's not the focus right now as hf25 is upon us, there was some discussions on using external tools instead of implementing it directly within hived. To be rediscussed. ## Hivemind Communities type 2/3 and account level mutes [hivemind#125](https://gitlab.syncad.com/hive/hivemind/-/issues/125) / [hivemind#145](https://gitlab.syncad.com/hive/hivemind/-/issues/145) Bt's team is building tests, we'll then then who takes this on, potentially bt's team as I'll be tied to hived ## Hivemind communities beneficiaries support [hivemind#149](https://gitlab.syncad.com/hive/hivemind/-/issues/149) +parameter naming: reward_share vs beneficiaries We also discussed changing the data type of the communities data from text to jsonb (https://gitlab.syncad.com/hive/hivemind/-/issues/153) Basically we'll use beneficiaries and the current implementations ideas are a bit early, we(I) are waiting for the changes to take place in communities type 2/3 + account level mutes to take place before taking this on. ## Hivemind Communities metadata (topics/tags) [hivemind#148](https://gitlab.syncad.com/hive/hivemind/-/issues/148) Yes why not, we'll add a new field to store a few &quot;communities tags&quot; and a new api to search for communities via said tags. The idea is to be able to tag a community like &quot;crypto nft games&quot; or &quot;sport tennis&quot; etc to make content discovery easier ## Adding more stats for communities A bit early to tell what we'll add but I'll definitely look into adding more stats and ways to sort communities with it. # Conclusion In the end lots of hivemind talks but those are mostly preliminary, our focus is hf25 we are tentatively(this is not an official date or anything, it's more like an &quot;ideally we would like it to be done by but might slip if needs be&quot;) looking at april 15 for locking the core code and build a testnet for hf25. This is when all the features for hf25 are set in stone and we stop adding new features to the core code. So all developments HAVE to be done by then. This is why I'll be mostly focusing on hive core for the next month to get all of my ongoing code merged and included in hf25. See you around for the next dev meeting on march 29th :) @howo See: Hive core developer meeting #19 by @howo</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://img.youtube.com/vi/UIRR5gFfVYk/0.jpg" /><media:content medium="image" url="https://img.youtube.com/vi/UIRR5gFfVYk/0.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Making a Decentralized Game on Hive - Tic Tac Toe - Part 1</title><link href="https://hivedocs.info/howto/nodejs/2021/03/13/making-a-decentralized-game-on-hive-tic-tac-toe-part-1.html" rel="alternate" type="text/html" title="Making a Decentralized Game on Hive - Tic Tac Toe - Part 1" /><published>2021-03-13T12:04:06-08:00</published><updated>2021-03-13T12:04:06-08:00</updated><id>https://hivedocs.info/howto/nodejs/2021/03/13/making-a-decentralized-game-on-hive-tic-tac-toe-part-1</id><content type="html" xml:base="https://hivedocs.info/howto/nodejs/2021/03/13/making-a-decentralized-game-on-hive-tic-tac-toe-part-1.html">&lt;div id=&quot;content-mahdiyari-making-a-decentralized-game-on-hive-tic-tac-toe-part-1&quot;&gt;&lt;center&gt;![tic-tac-toe.png](https://images.hive.blog/DQmYne66xZ9RBsrUwF9N76S5XnjJGyzEgBPbbsZRnNAHUzx/tic-tac-toe.png)&lt;/center&gt;
We will develop a decentralized game by the end of this series. The goal is to make learning development on Hive blockchain easier by using a simple game as the training project.

## Target audience
Of course, it's not for everybody. I will try to keep it simple as possible for people with less experience with development. But some degree of understanding code is necessary to learn something. I will explain anything related to the Hive blockchain that we use.

You can find the links for the final result of this part at the end of this post.

## Why &quot;tic-tac-toe&quot;?
It's a simple multiplayer game and it covers most of the topics needed for a bigger decentralized game or application. Most people are already familiar with this game and it's easier to code and its rules are simple.

## Development
We will use Javascript for the game because it's simple enough so most people understand easily. The front-end will be pure HTML. Also, I think MySQL is a good fit as the database. The game needs a database to keep track of games and players. MySQL docker can be set up in a few minutes.

The decentralized game will work without depending on one central software. The game will talk only to the blockchain and there is no central database. It doesn't need a private entity to hold players' data. Anyone can run an interface for the game.

(We have a database but it's not a central private database and it can be synced through blockchain. Anyone should be able to run an instance of the game and the game will get the same exact database by reading data from the blockchain. It's like hivemind, the database that holds and serves most of the data on Hive.)

## Tools I'm using
- Visual Studio Code
- Nodejs
- MySQL docker setup
- Chrome browser

I didn't plan anything beforehand so I don't know how many posts it will take. I will list the things that come to my mind right now.

## Planning
- Front-end
  - Make a login method on the client-side
  - Display available games list
  - Create/Request to join a game
  - Design the game visuals and controls
- Back-end
  - Stream the blockchain and listen for custom_json operations
  - Define custom_json operations
  - Game mechanics
  - API to communicate with front-end
  - Replay/resync method to update the database on newly deployed game clients

The above list may or may not change. Anyway, let's start with the front-end and add a login method.
***
## Part 1: Front-end - Login method
I think the HTML part doesn't need any explanation. Page title, description, bootstrap navbar, and a login link. Added `css/style.css` and `js/app.js` too. When the user clicks on the &quot;login&quot; link, a modal with the login form will appear. It will then fire `login()` function on submit.

`index.html`:
```
&amp;lt;!DOCTYPE html&amp;gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot; /&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
  &lt;meta name=&quot;description&quot; content=&quot;A decentralized game on hive blockchain&quot; /&gt;
  &lt;title&gt;Tic-Tac-Toe on Hive blockchain&lt;/title&gt;
  &lt;link href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; integrity=&quot;sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl&quot; crossorigin=&quot;anonymous&quot; /&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/js/bootstrap.bundle.min.js&quot; integrity=&quot;sha384-b5kHyXgcpbZJO/tY9Ul7kGkf1S0CWuKcCD38l8YkeH8z8QjE0GmW1gYU5S9FOnJ0&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/hive-tx/dist/hive-tx.min.js&quot;&gt;&lt;/script&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style.css&quot; /&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;nav class=&quot;navbar navbar-expand navbar-dark bg-dark&quot;&gt;
    &lt;div class=&quot;container-fluid&quot;&gt;
      &lt;a class=&quot;navbar-brand&quot; href=&quot;#&quot;&gt;Tic-Tac-Toe&lt;/a&gt;
      &lt;ul class=&quot;navbar-nav&quot;&gt;
        &lt;li class=&quot;nav-item&quot;&gt;
          &lt;a class=&quot;nav-link&quot; href=&quot;#&quot; data-bs-toggle=&quot;modal&quot; data-bs-target=&quot;#login-modal&quot; id=&quot;login-button&quot;&gt;
            Login
          &lt;/a&gt;
        &lt;li class=&quot;nav-item dropdown&quot; id=&quot;logout-menu&quot; style=&quot;display: none;&quot;&gt;
          &lt;a class=&quot;nav-link dropdown-toggle&quot; href=&quot;#&quot; id=&quot;username-button&quot; role=&quot;button&quot; data-bs-toggle=&quot;dropdown&quot; aria-expanded=&quot;false&quot;&gt;&lt;/a&gt;
          &lt;ul class=&quot;dropdown-menu dropdown-menu-end&quot; aria-labelledby=&quot;username-button&quot;&gt;
            &lt;li&gt;&lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot; onclick=&quot;logout()&quot;&gt;Logout&lt;/a&gt;&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/nav&gt;
  &lt;div class=&quot;modal fade&quot; id=&quot;login-modal&quot; tabindex=&quot;-1&quot; aria-labelledby=&quot;login-modal-title&quot; aria-hidden=&quot;true&quot;&gt;
    &lt;div class=&quot;modal-dialog&quot;&gt;
      &lt;div class=&quot;modal-content&quot;&gt;
        &lt;div class=&quot;modal-header&quot;&gt;
          &lt;h5 class=&quot;modal-title&quot; id=&quot;login-modal-title&quot;&gt;Login&lt;/h5&gt;
          &lt;button type=&quot;button&quot; class=&quot;btn-close&quot; data-bs-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;/button&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-body&quot;&gt;
          &lt;form onsubmit=&quot;login(); return false&quot;&gt;
            &lt;div class=&quot;mb-3&quot;&gt;
              &lt;label for=&quot;username&quot; class=&quot;form-label&quot;&gt;Username:&lt;/label&gt;
              &lt;div class=&quot;input-group mb-3&quot;&gt;
                &lt;span class=&quot;input-group-text&quot;&gt;@&lt;/span&gt;
                &lt;input type=&quot;text&quot; class=&quot;form-control&quot; placeholder=&quot;username&quot; aria-label=&quot;username&quot; id=&quot;username&quot; required=&quot;&quot; /&gt;
              &lt;/div&gt;
              &lt;div class=&quot;form-text&quot;&gt;Your Hive username. Lowercase.&lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;mb-3&quot;&gt;
              &lt;label for=&quot;posting-key&quot; class=&quot;form-label&quot;&gt;Posting key:&lt;/label&gt;
              &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;posting-key&quot; placeholder=&quot;Private posting key&quot; required=&quot;&quot; /&gt;
              &lt;div class=&quot;form-text&quot;&gt;Your key will never leave your browser.&lt;/div&gt;
            &lt;/div&gt;
            &lt;p id=&quot;login-error&quot;&gt;&lt;/p&gt;
            &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot; id=&quot;login-form-btn&quot;&gt;Login&lt;/button&gt;
            &lt;button type=&quot;button&quot; class=&quot;btn btn-secondary&quot; data-bs-dismiss=&quot;modal&quot;&gt;Close&lt;/button&gt;
          &lt;/form&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script src=&quot;js/app.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
``` 
***
### Styles
`css/style.css`:
```
.navbar-nav {
  margin-right: 30px;
}
.navbar-brand {
  margin-left: 30px;
}
#login-error {
  color: #e31337;
  display: none;
}
```
***
## Javascript
`js/app.js`
An object for user data.
```
const userData = {
  authorized: false,
  username: '',
  key: ''
}
```
Let's define the login function. It will verify the posting key and username then keep the data in localStorage. We use the [hive-tx](https://github.com/mahdiyari/hive-tx-js) library for converting keys.

```
const login = async () =&amp;gt; {
  const loginModal = bootstrap.Modal.getInstance(
    document.getElementById('login-modal')
  )
  const loginButtonForm = document.getElementById('login-form-btn')
  loginButtonForm.setAttribute('disabled', 'true')
  const loginError = document.getElementById('login-error')
  loginError.style.display = 'none'
  const username = document.getElementById('username').value
  const key = document.getElementById('posting-key').value
  const validate = await validatePostingKey(username, key)
  if (validate.result === 0) {
    loginError.innerHTML = validate.error
    loginError.style.display = 'block'
    loginButtonForm.removeAttribute('disabled')
    return
  }
  userData.authorized = true
  userData.username = username
  userData.key = key
  window.localStorage.setItem('userData', JSON.stringify(userData))
  loginButtonForm.removeAttribute('disabled')
  updateState()
  loginModal.hide()
}
```
As you can see there are 2 more functions used inside the login function. The first one is `validatePostingKey()`. It's a post for itself.
Let me explain it. First, we make a call to the Hive RPC API node by using hive-tx library and get the account information including the public posting key. Then we convert the user's private posting key to the public key and compare the two values. If the two values are equal then the user-provided private key is correct and we can authorize the user. There are also other ways to achieve the same result like signing a message with the private key and validating that signature with the public key.

```
const validatePostingKey = async (username, privateKey) =&amp;gt; {
  const accounts = await hiveTx.call('condenser_api.get_accounts', [[username]])
  if (
    !accounts ||
    !accounts.result ||
    !Array.isArray(accounts.result) ||
    accounts.result.length &amp;lt; 1
  ) {
    return { result: 0, error: 'Network error or wrong username' }
  }
  try {
    const account = accounts.result[0]
    const publicWif = account.posting.key_auths[0][0] || ''
    const generatedPublicKey = hiveTx.PrivateKey.from(privateKey)
      .createPublic()
      .toString()

    if (generatedPublicKey !== publicWif) {
      return { result: 0, error: 'Wrong key' }
    }
    return { result: 1 }
  } catch (e) {
    return { result: 0, error: 'Wrong key or network error' }
  }
}
```
updateState() is used to update the HTML interface after user login and logout.
```
const updateState = () =&amp;gt; {
  const loginButton = document.getElementById('login-button')
  const logoutMenu = document.getElementById('logout-menu')
  const usernameButton = document.getElementById('username-button')
  if (userData.authorized &amp;amp;&amp;amp; userData.username &amp;amp;&amp;amp; userData.key) {
    loginButton.style.display = 'none'
    logoutMenu.style.display = 'block'
    usernameButton.innerHTML = '@' + userData.username
  } else {
    loginButton.style.display = 'block'
    logoutMenu.style.display = 'none'
  }
}
```
And it's time for the logout function.
```
const logout = () =&amp;gt; {
  userData.authorized = false
  userData.username = ''
  userData.key = ''
  window.localStorage.removeItem('userData')
  updateState()
}
```
We need to check localStorage on the page reload and log in the user if the key is in the localStorage.
```
const checkState = () =&amp;gt; {
  const localData = window.localStorage.getItem('userData')
  let data
  if (!localData) {
    return
  }
  try {
    data = JSON.parse(localData)
  } catch (e) {
    data = userData
  }
  if (data.authorized &amp;amp;&amp;amp; data.username &amp;amp;&amp;amp; data.key) {
    userData.authorized = true
    userData.username = data.username
    userData.key = data.key
    updateState()
  }
}
checkState()
```
Now we have a working login and logout system. It keeps user data in localStorage which stays on the browser only.
What we have done so far is just the front-end. Our game needs a back-end server to provide the game data. We will stream blocks on the back-end and process game data then serve it through API. Our front-end will broadcast transactions which will update the back-end. In other words, the back-end is only serving the data it receives through the blockchain. We could stream the blocks on the client-side (browser) but it's not efficient and it is just unnecessary bandwidth waste.
***
You can see the running app on https://tic-tac-toe.mahdiyari.info/
The final code is on GitLab https://gitlab.com/mahdiyari/decentralized-game-on-hive

In the next part, we will set up our back-end server and database. Now that I think about it, MySQL might be an overkill for this project. Anyway, let's stick to it for now.

I want to get feedback from the community before continuing further. Help me with your comments and let me know what you think about this project. How can I improve it? Should I explain everything from the basics? I greatly appreciate your feedback.

Thanks for reading.&lt;/div&gt;
&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;

&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@mahdiyari&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/making-a-decentralized-game-on-hive-tic-tac-toe-part-1&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-mahdiyari-making-a-decentralized-game-on-hive-tic-tac-toe-part-1').html();
      const outputElem = $('#content-mahdiyari-making-a-decentralized-game-on-hive-tic-tac-toe-part-1');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;

&lt;style&gt;
  #content-mahdiyari-making-a-decentralized-game-on-hive-tic-tac-toe-part-1 {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-tic-tac-toe-part-1 code {
    background: white;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-tic-tac-toe-part-1 a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-tic-tac-toe-part-1 a:hover {
    border-bottom: 0;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-tic-tac-toe-part-1 h1 {
    font-size: 2.2em;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-tic-tac-toe-part-1 h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-tic-tac-toe-part-1 header small {
    color: #999;
    font-size: 50%;
  }
  #content-mahdiyari-making-a-decentralized-game-on-hive-tic-tac-toe-part-1 img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;

&lt;p&gt;
  See: &lt;a href=&quot;https://hive.blog/hive-139531/@mahdiyari/making-a-decentralized-game-on-hive-tic-tac-toe-part-1&quot;&gt;Making a Decentralized Game on Hive - Tic Tac Toe - Part 1&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@mahdiyari&quot;&gt;@mahdiyari&lt;/a&gt;
&lt;/p&gt;</content><author><name>mahdiyari</name></author><category term="howto" /><category term="nodejs" /><summary type="html">![tic-tac-toe.png](https://images.hive.blog/DQmYne66xZ9RBsrUwF9N76S5XnjJGyzEgBPbbsZRnNAHUzx/tic-tac-toe.png) We will develop a decentralized game by the end of this series. The goal is to make learning development on Hive blockchain easier by using a simple game as the training project. ## Target audience Of course, it's not for everybody. I will try to keep it simple as possible for people with less experience with development. But some degree of understanding code is necessary to learn something. I will explain anything related to the Hive blockchain that we use. You can find the links for the final result of this part at the end of this post. ## Why &quot;tic-tac-toe&quot;? It's a simple multiplayer game and it covers most of the topics needed for a bigger decentralized game or application. Most people are already familiar with this game and it's easier to code and its rules are simple. ## Development We will use Javascript for the game because it's simple enough so most people understand easily. The front-end will be pure HTML. Also, I think MySQL is a good fit as the database. The game needs a database to keep track of games and players. MySQL docker can be set up in a few minutes. The decentralized game will work without depending on one central software. The game will talk only to the blockchain and there is no central database. It doesn't need a private entity to hold players' data. Anyone can run an interface for the game. (We have a database but it's not a central private database and it can be synced through blockchain. Anyone should be able to run an instance of the game and the game will get the same exact database by reading data from the blockchain. It's like hivemind, the database that holds and serves most of the data on Hive.) ## Tools I'm using - Visual Studio Code - Nodejs - MySQL docker setup - Chrome browser I didn't plan anything beforehand so I don't know how many posts it will take. I will list the things that come to my mind right now. ## Planning - Front-end - Make a login method on the client-side - Display available games list - Create/Request to join a game - Design the game visuals and controls - Back-end - Stream the blockchain and listen for custom_json operations - Define custom_json operations - Game mechanics - API to communicate with front-end - Replay/resync method to update the database on newly deployed game clients The above list may or may not change. Anyway, let's start with the front-end and add a login method. *** ## Part 1: Front-end - Login method I think the HTML part doesn't need any explanation. Page title, description, bootstrap navbar, and a login link. Added `css/style.css` and `js/app.js` too. When the user clicks on the &quot;login&quot; link, a modal with the login form will appear. It will then fire `login()` function on submit. `index.html`: ``` &amp;lt;!DOCTYPE html&amp;gt; Tic-Tac-Toe on Hive blockchain Tic-Tac-Toe Login Logout Login Username: @ Your Hive username. Lowercase. Posting key: Your key will never leave your browser. Login Close ``` *** ### Styles `css/style.css`: ``` .navbar-nav { margin-right: 30px; } .navbar-brand { margin-left: 30px; } #login-error { color: #e31337; display: none; } ``` *** ## Javascript `js/app.js` An object for user data. ``` const userData = { authorized: false, username: '', key: '' } ``` Let's define the login function. It will verify the posting key and username then keep the data in localStorage. We use the [hive-tx](https://github.com/mahdiyari/hive-tx-js) library for converting keys. ``` const login = async () =&amp;gt; { const loginModal = bootstrap.Modal.getInstance( document.getElementById('login-modal') ) const loginButtonForm = document.getElementById('login-form-btn') loginButtonForm.setAttribute('disabled', 'true') const loginError = document.getElementById('login-error') loginError.style.display = 'none' const username = document.getElementById('username').value const key = document.getElementById('posting-key').value const validate = await validatePostingKey(username, key) if (validate.result === 0) { loginError.innerHTML = validate.error loginError.style.display = 'block' loginButtonForm.removeAttribute('disabled') return } userData.authorized = true userData.username = username userData.key = key window.localStorage.setItem('userData', JSON.stringify(userData)) loginButtonForm.removeAttribute('disabled') updateState() loginModal.hide() } ``` As you can see there are 2 more functions used inside the login function. The first one is `validatePostingKey()`. It's a post for itself. Let me explain it. First, we make a call to the Hive RPC API node by using hive-tx library and get the account information including the public posting key. Then we convert the user's private posting key to the public key and compare the two values. If the two values are equal then the user-provided private key is correct and we can authorize the user. There are also other ways to achieve the same result like signing a message with the private key and validating that signature with the public key. ``` const validatePostingKey = async (username, privateKey) =&amp;gt; { const accounts = await hiveTx.call('condenser_api.get_accounts', [[username]]) if ( !accounts || !accounts.result || !Array.isArray(accounts.result) || accounts.result.length &amp;lt; 1 ) { return { result: 0, error: 'Network error or wrong username' } } try { const account = accounts.result[0] const publicWif = account.posting.key_auths[0][0] || '' const generatedPublicKey = hiveTx.PrivateKey.from(privateKey) .createPublic() .toString() if (generatedPublicKey !== publicWif) { return { result: 0, error: 'Wrong key' } } return { result: 1 } } catch (e) { return { result: 0, error: 'Wrong key or network error' } } } ``` updateState() is used to update the HTML interface after user login and logout. ``` const updateState = () =&amp;gt; { const loginButton = document.getElementById('login-button') const logoutMenu = document.getElementById('logout-menu') const usernameButton = document.getElementById('username-button') if (userData.authorized &amp;amp;&amp;amp; userData.username &amp;amp;&amp;amp; userData.key) { loginButton.style.display = 'none' logoutMenu.style.display = 'block' usernameButton.innerHTML = '@' + userData.username } else { loginButton.style.display = 'block' logoutMenu.style.display = 'none' } } ``` And it's time for the logout function. ``` const logout = () =&amp;gt; { userData.authorized = false userData.username = '' userData.key = '' window.localStorage.removeItem('userData') updateState() } ``` We need to check localStorage on the page reload and log in the user if the key is in the localStorage. ``` const checkState = () =&amp;gt; { const localData = window.localStorage.getItem('userData') let data if (!localData) { return } try { data = JSON.parse(localData) } catch (e) { data = userData } if (data.authorized &amp;amp;&amp;amp; data.username &amp;amp;&amp;amp; data.key) { userData.authorized = true userData.username = data.username userData.key = data.key updateState() } } checkState() ``` Now we have a working login and logout system. It keeps user data in localStorage which stays on the browser only. What we have done so far is just the front-end. Our game needs a back-end server to provide the game data. We will stream blocks on the back-end and process game data then serve it through API. Our front-end will broadcast transactions which will update the back-end. In other words, the back-end is only serving the data it receives through the blockchain. We could stream the blocks on the client-side (browser) but it's not efficient and it is just unnecessary bandwidth waste. *** You can see the running app on https://tic-tac-toe.mahdiyari.info/ The final code is on GitLab https://gitlab.com/mahdiyari/decentralized-game-on-hive In the next part, we will set up our back-end server and database. Now that I think about it, MySQL might be an overkill for this project. Anyway, let's stick to it for now. I want to get feedback from the community before continuing further. Help me with your comments and let me know what you think about this project. How can I improve it? Should I explain everything from the basics? I greatly appreciate your feedback. Thanks for reading. See: Making a Decentralized Game on Hive - Tic Tac Toe - Part 1 by @mahdiyari</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://images.hive.blog/DQmYne66xZ9RBsrUwF9N76S5XnjJGyzEgBPbbsZRnNAHUzx/tic-tac-toe.png" /><media:content medium="image" url="https://images.hive.blog/DQmYne66xZ9RBsrUwF9N76S5XnjJGyzEgBPbbsZRnNAHUzx/tic-tac-toe.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">7th update of 2021 on BlockTrades work on Hive software</title><link href="https://hivedocs.info/news/core/development/2021/03/11/7th-update-of-2021-on-blocktrades-work-on-hive-software.html" rel="alternate" type="text/html" title="7th update of 2021 on BlockTrades work on Hive software" /><published>2021-03-11T12:25:42-08:00</published><updated>2021-03-11T12:25:42-08:00</updated><id>https://hivedocs.info/news/core/development/2021/03/11/7th-update-of-2021-on-blocktrades-work-on-hive-software</id><content type="html" xml:base="https://hivedocs.info/news/core/development/2021/03/11/7th-update-of-2021-on-blocktrades-work-on-hive-software.html">&lt;div id=&quot;content-blocktrades-7th-update-of-2021-on-blocktrades-work-on-hive-software&quot;&gt;Below is a brief list of Hive-related programming issues worked on by BlockTrades team during last week or so:

# Hived work (blockchain node software)

## SQL account history plugin for hived

We made some fixes to the SQL account history plugin to enable proper operation with hivemind sync process:
https://gitlab.syncad.com/hive/hive/-/merge_requests/173
https://gitlab.syncad.com/hive/hive/-/commits/bw_live_postgres_dump/
https://gitlab.syncad.com/hive/hive/-/merge_requests/177

 We still have one fix to avoid a potential foreign key violation during live sync (probably will be finished tomorrow).

## HF25 changes (these are described in detail in our [Hive roadmap post](https://hive.blog/hive-139531/@blocktrades/roadmap-for-hive-related-work-by-blocktrades-in-the-next-6-months))

We made some fixes and improvements to the code that handles expiration of governance votes (votes for witnesses and Hive Fund proposals): 
https://gitlab.syncad.com/hive/hive/-/merge_requests/174

We started work on voting window changes for HF25. We expect to finish implementation tomorrow, then we can begin testing.

## Miscellaneous hived changes

We made a fix related to removal of expired Hive Fund proposals: https://gitlab.syncad.com/hive/hive/-/merge_requests/176

We finished review of @howo merge requests. Two have been merged to develop and one is still under review:
https://gitlab.syncad.com/hive/hive/-/merge_requests/162
https://gitlab.syncad.com/hive/hive/-/merge_requests/169

We also fixed an intermittent issue with hived shutdown:
https://gitlab.syncad.com/hive/hive/-/merge_requests/157

We added some virtual ops to report various changes in state (mainly accounting-related) that werent previously reported: 
https://gitlab.syncad.com/hive/hive/-/merge_requests/167

Some changes to cleanup compile process: https://gitlab.syncad.com/hive/hive/-/merge_requests/172
Fix for proper testnet operation: https://gitlab.syncad.com/hive/hive/-/merge_requests/175

# Hivemind (2nd layer applications + social media middleware)

Fixed a problem in master branch that caused issues when upgrading an existing hivemind database: 
https://gitlab.syncad.com/hive/hivemind/-/merge_requests/483

Fixed an issue with git version reporting: https://gitlab.syncad.com/hive/hivemind/-/merge_requests/479

Added a comand-line option to log the time required for hive server to process API requests:
https://gitlab.syncad.com/hive/hivemind/-/merge_requests/481

Some new tests for bridge API calls:
https://gitlab.syncad.com/hive/hivemind/-/merge_requests/477

# Postgres extension for fork handling for Modular hivemind

One of the key challenges for modular hivemind (the upcoming 2nd layer application framework) is automated support of fork handling. Automated fork-handling will simplify design of 2nd layer apps so that they don't need to worry about fork-handling logic. 

Currently were experimenting with the use of a C-based postgres extension to help accomplish this task (were referring to this as the SQL change-audit extension). 

Last week we tested the prototypes ability to recover the original state of an updated record in the database. Below are links to where this work is going on in the repo:
https://gitlab.syncad.com/hive/psql_tools/-/blob/mi_hive_fork_plugin/README.md
https://gitlab.syncad.com/hive/psql_tools/-/commits/mi_hive_fork_plugin&lt;/div&gt;
&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;

&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@blocktrades&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/7th-update-of-2021-on-blocktrades-work-on-hive-software&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-blocktrades-7th-update-of-2021-on-blocktrades-work-on-hive-software').html();
      const outputElem = $('#content-blocktrades-7th-update-of-2021-on-blocktrades-work-on-hive-software');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;

&lt;style&gt;
  #content-blocktrades-7th-update-of-2021-on-blocktrades-work-on-hive-software {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-blocktrades-7th-update-of-2021-on-blocktrades-work-on-hive-software code {
    background: white;
  }
  #content-blocktrades-7th-update-of-2021-on-blocktrades-work-on-hive-software a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-blocktrades-7th-update-of-2021-on-blocktrades-work-on-hive-software a:hover {
    border-bottom: 0;
  }
  #content-blocktrades-7th-update-of-2021-on-blocktrades-work-on-hive-software h1 {
    font-size: 2.2em;
  }
  #content-blocktrades-7th-update-of-2021-on-blocktrades-work-on-hive-software h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-blocktrades-7th-update-of-2021-on-blocktrades-work-on-hive-software header small {
    color: #999;
    font-size: 50%;
  }
  #content-blocktrades-7th-update-of-2021-on-blocktrades-work-on-hive-software img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;

&lt;p&gt;
  See: &lt;a href=&quot;https://hive.blog/hive-139531/@blocktrades/7th-update-of-2021-on-blocktrades-work-on-hive-software&quot;&gt;7th update of 2021 on BlockTrades work on Hive software&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@blocktrades&quot;&gt;@blocktrades&lt;/a&gt;
&lt;/p&gt;</content><author><name>blocktrades</name></author><category term="news" /><category term="core" /><category term="development" /><summary type="html">Below is a brief list of Hive-related programming issues worked on by BlockTrades team during last week or so: # Hived work (blockchain node software) ## SQL account history plugin for hived We made some fixes to the SQL account history plugin to enable proper operation with hivemind sync process: https://gitlab.syncad.com/hive/hive/-/merge_requests/173 https://gitlab.syncad.com/hive/hive/-/commits/bw_live_postgres_dump/ https://gitlab.syncad.com/hive/hive/-/merge_requests/177 We still have one fix to avoid a potential foreign key violation during live sync (probably will be finished tomorrow). ## HF25 changes (these are described in detail in our [Hive roadmap post](https://hive.blog/hive-139531/@blocktrades/roadmap-for-hive-related-work-by-blocktrades-in-the-next-6-months)) We made some fixes and improvements to the code that handles expiration of governance votes (votes for witnesses and Hive Fund proposals): https://gitlab.syncad.com/hive/hive/-/merge_requests/174 We started work on voting window changes for HF25. We expect to finish implementation tomorrow, then we can begin testing. ## Miscellaneous hived changes We made a fix related to removal of expired Hive Fund proposals: https://gitlab.syncad.com/hive/hive/-/merge_requests/176 We finished review of @howo merge requests. Two have been merged to develop and one is still under review: https://gitlab.syncad.com/hive/hive/-/merge_requests/162 https://gitlab.syncad.com/hive/hive/-/merge_requests/169 We also fixed an intermittent issue with hived shutdown: https://gitlab.syncad.com/hive/hive/-/merge_requests/157 We added some virtual ops to report various changes in state (mainly accounting-related) that werent previously reported: https://gitlab.syncad.com/hive/hive/-/merge_requests/167 Some changes to cleanup compile process: https://gitlab.syncad.com/hive/hive/-/merge_requests/172 Fix for proper testnet operation: https://gitlab.syncad.com/hive/hive/-/merge_requests/175 # Hivemind (2nd layer applications + social media middleware) Fixed a problem in master branch that caused issues when upgrading an existing hivemind database: https://gitlab.syncad.com/hive/hivemind/-/merge_requests/483 Fixed an issue with git version reporting: https://gitlab.syncad.com/hive/hivemind/-/merge_requests/479 Added a comand-line option to log the time required for hive server to process API requests: https://gitlab.syncad.com/hive/hivemind/-/merge_requests/481 Some new tests for bridge API calls: https://gitlab.syncad.com/hive/hivemind/-/merge_requests/477 # Postgres extension for fork handling for Modular hivemind One of the key challenges for modular hivemind (the upcoming 2nd layer application framework) is automated support of fork handling. Automated fork-handling will simplify design of 2nd layer apps so that they don't need to worry about fork-handling logic. Currently were experimenting with the use of a C-based postgres extension to help accomplish this task (were referring to this as the SQL change-audit extension). Last week we tested the prototypes ability to recover the original state of an updated record in the database. Below are links to where this work is going on in the repo: https://gitlab.syncad.com/hive/psql_tools/-/blob/mi_hive_fork_plugin/README.md https://gitlab.syncad.com/hive/psql_tools/-/commits/mi_hive_fork_plugin See: 7th update of 2021 on BlockTrades work on Hive software by @blocktrades</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://hivedocs.info/assets/images/favicon.png" /><media:content medium="image" url="https://hivedocs.info/assets/images/favicon.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hive Account Recovery Update</title><link href="https://hivedocs.info/tools/2021/03/09/hive-account-recovery-update.html" rel="alternate" type="text/html" title="Hive Account Recovery Update" /><published>2021-03-09T10:19:12-08:00</published><updated>2021-03-09T10:19:12-08:00</updated><id>https://hivedocs.info/tools/2021/03/09/hive-account-recovery-update</id><content type="html" xml:base="https://hivedocs.info/tools/2021/03/09/hive-account-recovery-update.html">&lt;div id=&quot;content-arcange-hive-account-recovery-update&quot;&gt;&lt;center&gt;![](https://i.imgur.com/cBnUxCk.png)&lt;/center&gt;

Several months ago, I introduced Hive Recovery, a service that runs continuously and autonomously to help you recover your account if it were to be compromised.

For more information, I invite you to read the [introduction post](/hive/@arcange/introducing-hive-account-recovery).

Currently, many users have decided to define @hive.recovery as their recovery account and to date, none have yet had to use its services to recover it, which in itself is a good thing.

### One service with several working pieces

The services provided by @hive.recovery consist of two components:

1. The front-end

The front-end is a static HTML page that helps users to configure @hive.recovery as their recovery account. The front-end also helps to request @hive.recovery to initiate the recovery process

2. The back-end

The back-end is a javascript service running on a server that, upon request will verify the identity of an account and initiate the recovery process.

### Front-end improvements

I recently had to provide assistance to users who wanted to change their recovery account. No major issue, but it made me realize that there was still room for improvement, especially on the user interface part.

#### 1. Better error and edge case management

I first improved the error handling and fixed some small bugs regarding their notification.

I also added additional validations, among them the verification of the user's HIVE balance because the change request requires to have at least 0.001 HIVE available.

#### 2. New password and keys generator

I took the opportunity to add a feature intended for the recovery process itself: the possibility of generating a new password and keys.

Indeed, the recovery process requires you to provide your recovery account with the public owner key from a new password and keys set you previously generated for your account.

But to generate this new password and keys set, it was necessary to use an external service, and first to know where to find such a service. This is no longer necessary since this functionality is now directly integrated into the site.

![](https://i.imgur.com/cYYj2De.png)

If you do not have already generated a new password and keys set, you can do it by clicking the &quot;Generate new Password and Keys&quot; button. It will display a new dialog with a new randomly generated password and its related keys.

![](https://i.imgur.com/lFGHHr0.png)

After confirming you have saved your new credentials and clicked on &quot;Continue&quot;, it will automatically copy your new public owner key into the appropriate input field.

Of course, none of the displayed data is stored or transmitted. You can audit the source code that has been updated on [github](https://github.com/VIM-Arcange/hive-Recovery).

The [Hive Recovery User Guide](/hive/@hive.recovery/userguide), which contains all the details about this service has also been updated.

Little things that make your life easier.

---
&lt;center&gt;

### Check out my apps and services
&lt;a href=&quot;/hive/@hive.engage/stay-connected-with-your-hive-audience-and-catch-attention&quot;&gt;&lt;img src=&quot;https://i.imgur.com/GiNJqlm.png&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;/@hivebuzz&quot;&gt;&lt;img src=&quot;https://i.imgur.com/B4UTun2.png&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;/@hivesql&quot;&gt;&lt;img src=&quot;https://i.imgur.com/EPN8RW6.png&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;/hive/@arcange/introducing-hive-account-recovery&quot;&gt;&lt;img src=&quot;https://i.imgur.com/6TWeW7V.png&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;/@hive.autoclaim&quot;&gt;&lt;img src=&quot;https://i.imgur.com/ih2pEOw.png&quot; /&gt;&lt;/a&gt;&lt;/center&gt;
&lt;center&gt;

### [Vote for me as a witness ![](https://i.imgur.com/2bi4SnT.png)](https://hivesigner.com/sign/account-witness-vote?witness=arcange&amp;amp;approve=1)&amp;lt;/div&amp;gt;
&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=&quot; src=&quot;https://code.jquery.com/jquery-3.5.1.slim.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://unpkg.com/steem-content-renderer&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  $(document).ready(function() {
    try {
      const renderer = new SteemContentRenderer.DefaultRenderer({
        baseUrl: &quot;https://hive.blog/&quot;,
        breaks: true,
        skipSanitization: false,
        allowInsecureScriptTags: false,
        addNofollowToLinks: true,
        doNotShowImages: false,
        ipfsPrefix: &quot;&quot;,
        assetsWidth: 640,
        assetsHeight: 480,
        imageProxyFn: (url) =&gt; url,
        usertagUrlFn: (account) =&gt; &quot;/@arcange&quot;,
        hashtagUrlFn: (hashtag) =&gt; &quot;/hive-account-recovery-update&quot;,
        isLinkSafeFn: (url) =&gt; true,
      });
      
      const inputElem = $('#content-arcange-hive-account-recovery-update').html();
      const outputElem = $('#content-arcange-hive-account-recovery-update');
      const output = renderer.render(inputElem);
      
      outputElem.html(output);
    } catch(e) {
      console.log(e);
    }
  });
&lt;/script&gt;
&lt;style&gt;
  #content-arcange-hive-account-recovery-update {
    padding: 0 3rem;
    color: #444444;
    font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.8;
    text-shadow: 0 1px 0 #ffffff;
    padding: 0.5rem;
  }
  #content-arcange-hive-account-recovery-update code {
    background: white;
  }
  #content-arcange-hive-account-recovery-update a {
    border-bottom: 1px solid #444444; color: #444444; text-decoration: none;
  }
  #content-arcange-hive-account-recovery-update a:hover {
    border-bottom: 0;
  }
  #content-arcange-hive-account-recovery-update h1 {
    font-size: 2.2em;
  }
  #content-arcange-hive-account-recovery-update h2, h3, h4, h5 {
    margin-bottom: 0;
  }
  #content-arcange-hive-account-recovery-update header small {
    color: #999;
    font-size: 50%;
  }
  #content-arcange-hive-account-recovery-update img {
    max-width: 100%;
  }
&lt;/style&gt;

&lt;hr /&gt;
&lt;p&gt;
  See: &lt;a href=&quot;https://peakd.com/hive-139531/@arcange/hive-account-recovery-update&quot;&gt;Hive Account Recovery Update&lt;/a&gt;
  by
  &lt;a href=&quot;https://hive.blog/@arcange&quot;&gt;@arcange&lt;/a&gt;
&lt;/p&gt;

&lt;/center&gt;&lt;/div&gt;</content><author><name>arcange</name></author><category term="tools" /><summary type="html">![](https://i.imgur.com/cBnUxCk.png) Several months ago, I introduced Hive Recovery, a service that runs continuously and autonomously to help you recover your account if it were to be compromised. For more information, I invite you to read the [introduction post](/hive/@arcange/introducing-hive-account-recovery). Currently, many users have decided to define @hive.recovery as their recovery account and to date, none have yet had to use its services to recover it, which in itself is a good thing. ### One service with several working pieces The services provided by @hive.recovery consist of two components: 1. The front-end The front-end is a static HTML page that helps users to configure @hive.recovery as their recovery account. The front-end also helps to request @hive.recovery to initiate the recovery process 2. The back-end The back-end is a javascript service running on a server that, upon request will verify the identity of an account and initiate the recovery process. ### Front-end improvements I recently had to provide assistance to users who wanted to change their recovery account. No major issue, but it made me realize that there was still room for improvement, especially on the user interface part. #### 1. Better error and edge case management I first improved the error handling and fixed some small bugs regarding their notification. I also added additional validations, among them the verification of the user's HIVE balance because the change request requires to have at least 0.001 HIVE available. #### 2. New password and keys generator I took the opportunity to add a feature intended for the recovery process itself: the possibility of generating a new password and keys. Indeed, the recovery process requires you to provide your recovery account with the public owner key from a new password and keys set you previously generated for your account. But to generate this new password and keys set, it was necessary to use an external service, and first to know where to find such a service. This is no longer necessary since this functionality is now directly integrated into the site. ![](https://i.imgur.com/cYYj2De.png) If you do not have already generated a new password and keys set, you can do it by clicking the &quot;Generate new Password and Keys&quot; button. It will display a new dialog with a new randomly generated password and its related keys. ![](https://i.imgur.com/lFGHHr0.png) After confirming you have saved your new credentials and clicked on &quot;Continue&quot;, it will automatically copy your new public owner key into the appropriate input field. Of course, none of the displayed data is stored or transmitted. You can audit the source code that has been updated on [github](https://github.com/VIM-Arcange/hive-Recovery). The [Hive Recovery User Guide](/hive/@hive.recovery/userguide), which contains all the details about this service has also been updated. Little things that make your life easier. --- ### Check out my apps and services ### [Vote for me as a witness ![](https://i.imgur.com/2bi4SnT.png)](https://hivesigner.com/sign/account-witness-vote?witness=arcange&amp;amp;approve=1)&amp;lt;/div&amp;gt; See: Hive Account Recovery Update by @arcange</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://i.imgur.com/cBnUxCk.png" /><media:content medium="image" url="https://i.imgur.com/cBnUxCk.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>